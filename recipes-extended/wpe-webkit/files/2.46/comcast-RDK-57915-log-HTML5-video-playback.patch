From 191bdcdde6960984fe74ed16ffd763fef6d856f6 Mon Sep 17 00:00:00 2001
From: Andrzej Surdej <Andrzej_Surdej@comcast.com>
Date: Mon, 20 Oct 2025 15:04:31 +0100
Subject: [PATCH] comcast - RDK-57915 - log HTML5 video playback

WPE builds missing youtube playback progress logs

It has been noticed that, there is no log information that could point to youtube asset playback start, progress, pause and termination.
The non-WPE (QT) builds had the following information, that were useful.

%% original patch: comcast-RDK-57915-log-HTML5-video-playback.patch
---
 Source/WebCore/page/EventHandler.cpp          |  6 +++
 .../gstreamer/MediaPlayerPrivateGStreamer.cpp | 41 +++++++++++++++++--
 .../gstreamer/MediaPlayerPrivateGStreamer.h   |  6 +++
 .../mse/MediaPlayerPrivateGStreamerMSE.cpp    |  5 +++
 .../gstreamer/GStreamerQuirkWesteros.cpp      | 24 +++++++++++
 5 files changed, 79 insertions(+), 3 deletions(-)

diff --git a/Source/WebCore/page/EventHandler.cpp b/Source/WebCore/page/EventHandler.cpp
index d533129da85e..b31bcb5cb1d5 100644
--- a/Source/WebCore/page/EventHandler.cpp
+++ b/Source/WebCore/page/EventHandler.cpp
@@ -164,6 +164,9 @@
 
 namespace WebCore {
 
+// Implemented in GStreamerQuirkWesteros.cpp
+void noticeEnterKeyDownEvent();
+
 using namespace HTMLNames;
 
 #if ENABLE(DRAG_SUPPORT)
@@ -3749,6 +3752,9 @@ bool EventHandler::isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent& ke
 
 bool EventHandler::keyEvent(const PlatformKeyboardEvent& keyEvent)
 {
+    if (keyEvent.type() == PlatformEvent::Type::KeyDown && keyEvent.keyIdentifier() == "Enter"_s)
+        noticeEnterKeyDownEvent();
+
     Ref frame = m_frame.get();
     RefPtr topDocument = frame->document() ? &frame->document()->topDocument() : nullptr;
     MonotonicTime savedLastHandledUserGestureTimestamp;
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index b5dd44ab736d..08df87abc492 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -225,6 +225,8 @@ MediaPlayerPrivateGStreamer::MediaPlayerPrivateGStreamer(MediaPlayer* player)
     ensureGStreamerInitialized();
     m_audioSink = createAudioSink();
     ensureSeekFlags();
+
+    fprintf(stderr, "HTML5 video: Player constructed [%p]\n", this);
 }
 
 MediaPlayerPrivateGStreamer::~MediaPlayerPrivateGStreamer()
@@ -233,6 +235,8 @@ MediaPlayerPrivateGStreamer::~MediaPlayerPrivateGStreamer()
         m_gstreamerHolePunchHost->playerPrivateWillBeDestroyed();
 
     tearDown(true);
+
+    fprintf(stderr, "HTML5 video: Player Destroyed [%p]\n", this);
 }
 
 void MediaPlayerPrivateGStreamer::tearDown(bool clearMediaPlayer)
@@ -240,6 +244,9 @@ void MediaPlayerPrivateGStreamer::tearDown(bool clearMediaPlayer)
     GST_DEBUG_OBJECT(pipeline(), "Disposing player");
     m_isPlayerShuttingDown.store(true);
 
+    if (m_reportedPlaybackStarted && !(m_reportedPlaybackEOS || m_reportedPlaybackFailed))
+        fprintf(stderr, "HTML5 video: Playback terminated [%s]\n", m_url.string().utf8().data());
+
 #if ENABLE(MEDIA_TELEMETRY)
     MediaTelemetryReport::singleton().reportPlaybackState(MediaTelemetryReport::AVPipelineState::Stop);
 #endif
@@ -389,6 +396,11 @@ void MediaPlayerPrivateGStreamer::load(const String& urlString)
 
     registerWebKitGStreamerElements();
 
+    fprintf(stderr, "HTML5 video: Loading [%s]\n", urlString.utf8().data());
+    m_reportedPlaybackStarted = false; // Clean up the flags
+    m_reportedPlaybackFailed = false;
+    m_reportedPlaybackEOS = false;
+
     if (!m_pipeline)
         createGSTPlayBin(url);
     syncOnClock(true);
@@ -705,6 +717,10 @@ void MediaPlayerPrivateGStreamer::seekToTarget(const SeekTarget& inTarget)
         }
     } else {
         // We can seek now.
+        fprintf(stderr,"HTML5 video: Seeking from %s to %s seconds [%s]\n",
+                toString(currentTime()).utf8().data(), toString(target.time).utf8().data(),
+                m_url.string().utf8().data());
+
         if (!doSeek(target, player->rate())) {
             GST_DEBUG_OBJECT(pipeline(), "[Seek] seeking to %s failed", toString(target.time).utf8().data());
             return;
@@ -1088,6 +1104,15 @@ MediaPlayerPrivateGStreamer::ChangePipelineStateResult MediaPlayerPrivateGStream
 {
     ASSERT(m_pipeline);
 
+    if(newState == GST_STATE_PLAYING) {
+        fprintf(stderr,"HTML5 video: Play [%s]\n", m_url.string().utf8().data());
+        if (!m_reportedPlaybackStarted)
+            fprintf(stderr, "HTML5 video: Playback started [%s]\n",m_url.string().utf8().data());
+        m_reportedPlaybackStarted = true;
+    } else if(newState == GST_STATE_PAUSED) {
+        fprintf(stderr,"HTML5 video: Pause [%s]\n", m_url.string().utf8().data());
+    }
+
     if (m_isPausedByViewport && newState > GST_STATE_PAUSED) {
         GST_DEBUG_OBJECT(pipeline(), "Saving state for when player becomes visible: %s", gst_element_state_get_name(newState));
         m_invisiblePlayerState = newState;
@@ -2058,19 +2083,24 @@ void MediaPlayerPrivateGStreamer::handleMessage(GstMessage* message)
                 || g_error_matches(err.get(), GST_STREAM_ERROR, GST_STREAM_ERROR_FAILED)
                 || g_error_matches(err.get(), GST_CORE_ERROR, GST_CORE_ERROR_MISSING_PLUGIN)
                 || g_error_matches(err.get(), GST_CORE_ERROR, GST_CORE_ERROR_PAD)
-                || g_error_matches(err.get(), GST_RESOURCE_ERROR, GST_RESOURCE_ERROR_NOT_FOUND))
+                || g_error_matches(err.get(), GST_RESOURCE_ERROR, GST_RESOURCE_ERROR_NOT_FOUND)) {
+                fprintf(stderr, "HTML5 video: Playback failed: Format error [%s]\n", m_url.string().utf8().data());
                 error = MediaPlayer::NetworkState::FormatError;
-            else if (g_error_matches(err.get(), GST_STREAM_ERROR, GST_STREAM_ERROR_TYPE_NOT_FOUND)) {
+            } else if (g_error_matches(err.get(), GST_STREAM_ERROR, GST_STREAM_ERROR_TYPE_NOT_FOUND)) {
+                fprintf(stderr, "HTML5 video: Playback failed: element not found error [%s]\n", m_url.string().utf8().data());
                 GST_ERROR_OBJECT(pipeline(), "Decode error, let the Media element emit a stalled event.");
                 m_loadingStalled = true;
                 error = MediaPlayer::NetworkState::DecodeError;
                 attemptNextLocation = true;
             } else if (err->domain == GST_STREAM_ERROR
                 || g_error_matches(err.get(), GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE)) {
+                fprintf(stderr, "HTML5 video: Playback failed: Decode error [%s]\n",m_url.string().utf8().data());
                 error = MediaPlayer::NetworkState::DecodeError;
                 attemptNextLocation = true;
-            } else if (err->domain == GST_RESOURCE_ERROR)
+            } else if (err->domain == GST_RESOURCE_ERROR) {
+                fprintf(stderr, "HTML5 video: Playback failed: Network error [%s]\n",m_url.string().utf8().data());
                 error = MediaPlayer::NetworkState::NetworkError;
+        }
 
             if (attemptNextLocation)
                 issueError = !loadNextLocation();
@@ -3115,6 +3145,11 @@ void MediaPlayerPrivateGStreamer::didEnd()
     m_isEndReached = true;
     RefPtr player = m_player.get();
 
+    if (!m_reportedPlaybackEOS && (!player || !player->isLooping())) {
+        fprintf(stderr, "HTML5 video: End of Stream [%s]\n", m_url.string().utf8().data());
+        m_reportedPlaybackEOS = true;
+    }
+
     if (!duration().isFinite()) {
         // From the HTMLMediaElement spec.
         // If an "infinite" stream ends for some reason, then the duration would change from positive Infinity to the
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
index 5dfff9dd9516..2a09557da1ac 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
@@ -408,6 +408,8 @@ protected:
     bool isPipelineWaitingPreroll(GstState current, GstState pending, GstStateChangeReturn) const;
     bool isPipelineWaitingPreroll() const;
 
+    const URL& url() const { return m_url; }
+
     void didEnd();
 
     Ref<MainThreadNotifier<MainThreadNotification>> m_notifier;
@@ -622,6 +624,10 @@ private:
 
     void textureMapperPlatformLayerProxyWasInvalidated();
 
+    bool m_reportedPlaybackStarted { false };
+    bool m_reportedPlaybackFailed { false };
+    bool m_reportedPlaybackEOS { false };
+
     Atomic<bool> m_isPlayerShuttingDown;
     GRefPtr<GstElement> m_textSink;
     GUniquePtr<GstStructure> m_mediaLocations;
diff --git a/Source/WebCore/platform/graphics/gstreamer/mse/MediaPlayerPrivateGStreamerMSE.cpp b/Source/WebCore/platform/graphics/gstreamer/mse/MediaPlayerPrivateGStreamerMSE.cpp
index 7861a2fe3cfd..20eec45dfbcd 100644
--- a/Source/WebCore/platform/graphics/gstreamer/mse/MediaPlayerPrivateGStreamerMSE.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/mse/MediaPlayerPrivateGStreamerMSE.cpp
@@ -247,6 +247,11 @@ void MediaPlayerPrivateGStreamerMSE::seekToTarget(const SeekTarget& target)
 
 bool MediaPlayerPrivateGStreamerMSE::doSeek(const SeekTarget& target, float rate)
 {
+    fprintf(stderr,"HTML5 video: Seeking from %s to %s seconds [%s]\n",
+            toString(currentTime()).utf8().data(),
+            toString(target.time).utf8().data(),
+            url().string().utf8().data());
+
     // This method should only be called outside of MediaPlayerPrivateGStreamerMSE by MediaPlayerPrivateGStreamer::setRate().
 
     // Note: An important difference between seek with WebKitMediaSrc and regular playback is that seeking before
diff --git a/Source/WebCore/platform/gstreamer/GStreamerQuirkWesteros.cpp b/Source/WebCore/platform/gstreamer/GStreamerQuirkWesteros.cpp
index c7f62b7e33b8..347dc55af173 100644
--- a/Source/WebCore/platform/gstreamer/GStreamerQuirkWesteros.cpp
+++ b/Source/WebCore/platform/gstreamer/GStreamerQuirkWesteros.cpp
@@ -31,6 +31,25 @@ namespace WebCore {
 GST_DEBUG_CATEGORY_STATIC(webkit_westeros_quirks_debug);
 #define GST_CAT_DEFAULT webkit_westeros_quirks_debug
 
+MonotonicTime gEnterKeyDownTime;
+void noticeEnterKeyDownEvent()
+{
+    gEnterKeyDownTime = WTF::MonotonicTime::now();
+}
+static void noticeFirstVideoFrame()
+{
+    if (gEnterKeyDownTime) {
+        auto diffTime = WTF::MonotonicTime::now() - gEnterKeyDownTime;
+        gEnterKeyDownTime = MonotonicTime();
+        fprintf(stderr, "Media: browse-to-watch = %.2f ms\n", diffTime.milliseconds());
+    }
+
+}
+static void onFirstVideoFrameCallback(gpointer /*data*/)
+{
+    noticeFirstVideoFrame();
+}
+
 GStreamerQuirkWesteros::GStreamerQuirkWesteros()
 {
     GST_DEBUG_CATEGORY_INIT(webkit_westeros_quirks_debug, "webkitquirkswesteros", 0, "WebKit Westeros Quirks");
@@ -59,6 +78,11 @@ bool GStreamerQuirkWesteros::isPlatformSupported() const
 
 void GStreamerQuirkWesteros::configureElement(GstElement* element, const OptionSet<ElementRuntimeCharacteristics>& characteristics)
 {
+    if (!g_strcmp0(G_OBJECT_TYPE_NAME(G_OBJECT(element)), "GstWesterosSink") &&
+        !g_signal_handler_find(element, static_cast<GSignalMatchType>(G_SIGNAL_MATCH_FUNC),
+                               0, 0, nullptr, reinterpret_cast<gpointer>(G_CALLBACK(onFirstVideoFrameCallback)), nullptr)) {
+        g_signal_connect_swapped(element, "first-video-frame-callback", G_CALLBACK(onFirstVideoFrameCallback), nullptr);
+    }
     // Decodebin3 will try to autoplug available elements until it reaches a raw video format.
     // Set stop caps on decodebin3 to prevent it from decoding the stream.
     // Instead, it should expose a pad with encoded caps that platform sink can handle directly as a sink element.
-- 
2.43.0

