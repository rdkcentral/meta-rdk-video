From 4db7dadf92a85ccf1b6a2c4352133b0918958515 Mon Sep 17 00:00:00 2001
From: Andrzej Surdej <Andrzej_Surdej@comcast.com>
Date: Mon, 19 May 2025 14:42:22 +0200
Subject: [PATCH] comcast - RDK-57915 - log HTML5 video playback

WPE builds missing youtube playback progress logs

It has been noticed that, there is no log information that could point to youtube asset playback start, progress, pause and termination.
The non-WPE (QT) builds had the following information, that were useful.

%% original patch: comcast-RDK-57915-log-HTML5-video-playback.patch
---
 Source/WebCore/page/EventHandler.cpp          |  6 +++
 .../gstreamer/MediaPlayerPrivateGStreamer.cpp | 41 +++++++++++++++++--
 .../gstreamer/MediaPlayerPrivateGStreamer.h   |  6 +++
 .../mse/MediaPlayerPrivateGStreamerMSE.cpp    |  5 +++
 .../gstreamer/GStreamerQuirkWesteros.cpp      | 25 +++++++++++
 5 files changed, 80 insertions(+), 3 deletions(-)

diff --git a/Source/WebCore/page/EventHandler.cpp b/Source/WebCore/page/EventHandler.cpp
index d533129da85e..be70df994405 100644
--- a/Source/WebCore/page/EventHandler.cpp
+++ b/Source/WebCore/page/EventHandler.cpp
@@ -164,6 +164,9 @@
 
 namespace WebCore {
 
+// Implemented in GStreamerQuirkWesteros.cpp
+void noticeEnterKeyDownEvent();
+
 using namespace HTMLNames;
 
 #if ENABLE(DRAG_SUPPORT)
@@ -3749,6 +3752,9 @@ bool EventHandler::isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent& ke
 
 bool EventHandler::keyEvent(const PlatformKeyboardEvent& keyEvent)
 {
+    if (keyEvent.type() == PlatformEvent::Type::KeyDown && keyEvent.keyIdentifier() == "Enter"_s)
+        noticeEnterKeyDownEvent();
+
     Ref frame = m_frame.get();
     RefPtr topDocument = frame->document() ? &frame->document()->topDocument() : nullptr;
     MonotonicTime savedLastHandledUserGestureTimestamp;
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index 04c301d3c3d5..a19f2e7df2de 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -225,6 +225,8 @@ MediaPlayerPrivateGStreamer::MediaPlayerPrivateGStreamer(MediaPlayer* player)
     ensureGStreamerInitialized();
     m_audioSink = createAudioSink();
     ensureSeekFlags();
+
+    fprintf(stderr, "HTML5 video: Player constructed [%p]\n", this);
 }
 
 MediaPlayerPrivateGStreamer::~MediaPlayerPrivateGStreamer()
@@ -233,6 +235,8 @@ MediaPlayerPrivateGStreamer::~MediaPlayerPrivateGStreamer()
         m_gstreamerHolePunchHost->playerPrivateWillBeDestroyed();
 
     tearDown(true);
+
+    fprintf(stderr, "HTML5 video: Player Destroyed [%p]\n", this);
 }
 
 void MediaPlayerPrivateGStreamer::tearDown(bool clearMediaPlayer)
@@ -240,6 +244,9 @@ void MediaPlayerPrivateGStreamer::tearDown(bool clearMediaPlayer)
     GST_DEBUG_OBJECT(pipeline(), "Disposing player");
     m_isPlayerShuttingDown.store(true);
 
+    if (m_reportedPlaybackStarted && !(m_reportedPlaybackEOS || m_reportedPlaybackFailed))
+        fprintf(stderr, "HTML5 video: Playback terminated [%s]\n", m_url.string().utf8().data());
+
 #if ENABLE(MEDIA_TELEMETRY)
     MediaTelemetryReport::singleton().reportPlaybackState(MediaTelemetryReport::AVPipelineState::Stop);
 #endif
@@ -389,6 +396,11 @@ void MediaPlayerPrivateGStreamer::load(const String& urlString)
 
     registerWebKitGStreamerElements();
 
+    fprintf(stderr, "HTML5 video: Loading [%s]\n", urlString.utf8().data());
+    m_reportedPlaybackStarted = false; // Clean up the flags
+    m_reportedPlaybackFailed = false;
+    m_reportedPlaybackEOS = false;
+
     if (!m_pipeline)
         createGSTPlayBin(url);
     syncOnClock(true);
@@ -705,6 +717,10 @@ void MediaPlayerPrivateGStreamer::seekToTarget(const SeekTarget& inTarget)
         }
     } else {
         // We can seek now.
+        fprintf(stderr,"HTML5 video: Seeking from %s to %s seconds [%s]\n",
+                toString(currentTime()).utf8().data(), toString(target.time).utf8().data(),
+                m_url.string().utf8().data());
+
         if (!doSeek(target, player->rate())) {
             GST_DEBUG_OBJECT(pipeline(), "[Seek] seeking to %s failed", toString(target.time).utf8().data());
             return;
@@ -1088,6 +1104,15 @@ MediaPlayerPrivateGStreamer::ChangePipelineStateResult MediaPlayerPrivateGStream
 {
     ASSERT(m_pipeline);
 
+    if(newState == GST_STATE_PLAYING) {
+        fprintf(stderr,"HTML5 video: Play [%s]\n", m_url.string().utf8().data());
+        if (!m_reportedPlaybackStarted)
+            fprintf(stderr, "HTML5 video: Playback started [%s]\n",m_url.string().utf8().data());
+        m_reportedPlaybackStarted = true;
+    } else if(newState == GST_STATE_PAUSED) {
+        fprintf(stderr,"HTML5 video: Pause [%s]\n", m_url.string().utf8().data());
+    }
+
     if (m_isPausedByViewport && newState > GST_STATE_PAUSED) {
         GST_DEBUG_OBJECT(pipeline(), "Saving state for when player becomes visible: %s", gst_element_state_get_name(newState));
         m_invisiblePlayerState = newState;
@@ -2036,19 +2061,24 @@ void MediaPlayerPrivateGStreamer::handleMessage(GstMessage* message)
             || g_error_matches(err.get(), GST_STREAM_ERROR, GST_STREAM_ERROR_FAILED)
             || g_error_matches(err.get(), GST_CORE_ERROR, GST_CORE_ERROR_MISSING_PLUGIN)
             || g_error_matches(err.get(), GST_CORE_ERROR, GST_CORE_ERROR_PAD)
-            || g_error_matches(err.get(), GST_RESOURCE_ERROR, GST_RESOURCE_ERROR_NOT_FOUND))
+            || g_error_matches(err.get(), GST_RESOURCE_ERROR, GST_RESOURCE_ERROR_NOT_FOUND)) {
+            fprintf(stderr, "HTML5 video: Playback failed: Format error [%s]\n", m_url.string().utf8().data());
             error = MediaPlayer::NetworkState::FormatError;
-        else if (g_error_matches(err.get(), GST_STREAM_ERROR, GST_STREAM_ERROR_TYPE_NOT_FOUND)) {
+        } else if (g_error_matches(err.get(), GST_STREAM_ERROR, GST_STREAM_ERROR_TYPE_NOT_FOUND)) {
+            fprintf(stderr, "HTML5 video: Playback failed: element not found error [%s]\n", m_url.string().utf8().data());
             GST_ERROR_OBJECT(pipeline(), "Decode error, let the Media element emit a stalled event.");
             m_loadingStalled = true;
             error = MediaPlayer::NetworkState::DecodeError;
             attemptNextLocation = true;
         } else if (err->domain == GST_STREAM_ERROR
             || g_error_matches(err.get(), GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE)) {
+            fprintf(stderr, "HTML5 video: Playback failed: Decode error [%s]\n",m_url.string().utf8().data());
             error = MediaPlayer::NetworkState::DecodeError;
             attemptNextLocation = true;
-        } else if (err->domain == GST_RESOURCE_ERROR)
+        } else if (err->domain == GST_RESOURCE_ERROR) {
+            fprintf(stderr, "HTML5 video: Playback failed: Network error [%s]\n",m_url.string().utf8().data());
             error = MediaPlayer::NetworkState::NetworkError;
+        }
 
         if (attemptNextLocation)
             issueError = !loadNextLocation();
@@ -3083,6 +3113,11 @@ void MediaPlayerPrivateGStreamer::didEnd()
     m_isEndReached = true;
     RefPtr player = m_player.get();
 
+    if (!m_reportedPlaybackEOS && (!player || !player->isLooping())) {
+        fprintf(stderr, "HTML5 video: End of Stream [%s]\n", m_url.string().utf8().data());
+        m_reportedPlaybackEOS = true;
+    }
+
     if (!duration().isFinite()) {
         // From the HTMLMediaElement spec.
         // If an "infinite" stream ends for some reason, then the duration would change from positive Infinity to the
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
index 2f701ca943d3..723626cd0457 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
@@ -404,6 +404,8 @@ protected:
     bool isPipelineWaitingPreroll(GstState current, GstState pending, GstStateChangeReturn) const;
     bool isPipelineWaitingPreroll() const;
 
+    const URL& url() const { return m_url; }
+
     Ref<MainThreadNotifier<MainThreadNotification>> m_notifier;
     ThreadSafeWeakPtr<MediaPlayer> m_player;
     String m_referrer;
@@ -608,6 +610,10 @@ private:
 
     void textureMapperPlatformLayerProxyWasInvalidated();
 
+    bool m_reportedPlaybackStarted { false };
+    bool m_reportedPlaybackFailed { false };
+    bool m_reportedPlaybackEOS { false };
+
     Atomic<bool> m_isPlayerShuttingDown;
     GRefPtr<GstElement> m_textSink;
     GUniquePtr<GstStructure> m_mediaLocations;
diff --git a/Source/WebCore/platform/graphics/gstreamer/mse/MediaPlayerPrivateGStreamerMSE.cpp b/Source/WebCore/platform/graphics/gstreamer/mse/MediaPlayerPrivateGStreamerMSE.cpp
index ba044ce93ce5..fa9a63ab6957 100644
--- a/Source/WebCore/platform/graphics/gstreamer/mse/MediaPlayerPrivateGStreamerMSE.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/mse/MediaPlayerPrivateGStreamerMSE.cpp
@@ -230,6 +230,11 @@ void MediaPlayerPrivateGStreamerMSE::seekToTarget(const SeekTarget& target)
 
 bool MediaPlayerPrivateGStreamerMSE::doSeek(const SeekTarget& target, float rate)
 {
+    fprintf(stderr,"HTML5 video: Seeking from %s to %s seconds [%s]\n",
+            toString(currentTime()).utf8().data(),
+            toString(target.time).utf8().data(),
+            url().string().utf8().data());
+
     // This method should only be called outside of MediaPlayerPrivateGStreamerMSE by MediaPlayerPrivateGStreamer::setRate().
 
     // Note: An important difference between seek with WebKitMediaSrc and regular playback is that seeking before
diff --git a/Source/WebCore/platform/gstreamer/GStreamerQuirkWesteros.cpp b/Source/WebCore/platform/gstreamer/GStreamerQuirkWesteros.cpp
index b87cd01dd20b..089c878096d3 100644
--- a/Source/WebCore/platform/gstreamer/GStreamerQuirkWesteros.cpp
+++ b/Source/WebCore/platform/gstreamer/GStreamerQuirkWesteros.cpp
@@ -31,6 +31,25 @@ namespace WebCore {
 GST_DEBUG_CATEGORY_STATIC(webkit_westeros_quirks_debug);
 #define GST_CAT_DEFAULT webkit_westeros_quirks_debug
 
+MonotonicTime gEnterKeyDownTime;
+void noticeEnterKeyDownEvent()
+{
+    gEnterKeyDownTime = WTF::MonotonicTime::now();
+}
+static void noticeFirstVideoFrame()
+{
+    if (gEnterKeyDownTime) {
+        auto diffTime = WTF::MonotonicTime::now() - gEnterKeyDownTime;
+        gEnterKeyDownTime = MonotonicTime();
+        fprintf(stderr, "Media: browse-to-watch = %.2f ms\n", diffTime.milliseconds());
+    }
+
+}
+static void onFirstVideoFrameCallback(gpointer /*data*/)
+{
+    noticeFirstVideoFrame();
+}
+
 GStreamerQuirkWesteros::GStreamerQuirkWesteros()
 {
     GST_DEBUG_CATEGORY_INIT(webkit_westeros_quirks_debug, "webkitquirkswesteros", 0, "WebKit Westeros Quirks");
@@ -59,6 +78,12 @@ bool GStreamerQuirkWesteros::isPlatformSupported() const
 
 void GStreamerQuirkWesteros::configureElement(GstElement* element, const OptionSet<ElementRuntimeCharacteristics>& characteristics)
 {
+    if (!g_strcmp0(G_OBJECT_TYPE_NAME(G_OBJECT(element)), "GstWesterosSink") &&
+        !g_signal_handler_find(element, static_cast<GSignalMatchType>(G_SIGNAL_MATCH_FUNC),
+                               0, 0, nullptr, reinterpret_cast<gpointer>(G_CALLBACK(onFirstVideoFrameCallback)), nullptr)) {
+        g_signal_connect_swapped(element, "first-video-frame-callback", G_CALLBACK(onFirstVideoFrameCallback), nullptr);
+    }
+
     // Decodebin3 will try to autoplug available elements until it reaches a raw video format.
     // Set stop caps on decodebin3 to prevent it from decoding the stream.
     // Instead, it should expose a pad with encoded caps that platform sink can handle directly as a sink element.
-- 
2.48.1

