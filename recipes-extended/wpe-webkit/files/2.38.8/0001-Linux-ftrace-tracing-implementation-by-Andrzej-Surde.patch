From 04cd168cdf8cce60221e06dd86916432a516bf45 Mon Sep 17 00:00:00 2001
From: Glib Novodran <glib_novodran@comcast.com>
Date: Thu, 11 Sep 2025 15:49:07 +0000
Subject: [PATCH 1/2] Linux ftrace tracing implementation by Andrzej Surdej
 modifed to fit the investigation needs.

---
 Source/WTF/wtf/PlatformWPE.cmake           |   1 +
 Source/WTF/wtf/SystemTracing.h             | 120 +++++-
 Source/WTF/wtf/linux/SystemTracingFTrace.h | 475 +++++++++++++++++++++
 Source/cmake/OptionsWPE.cmake              |   1 +
 4 files changed, 595 insertions(+), 2 deletions(-)
 create mode 100644 Source/WTF/wtf/linux/SystemTracingFTrace.h

diff --git a/Source/WTF/wtf/PlatformWPE.cmake b/Source/WTF/wtf/PlatformWPE.cmake
index 1f4707a1dcae..32d5d14b20d9 100644
--- a/Source/WTF/wtf/PlatformWPE.cmake
+++ b/Source/WTF/wtf/PlatformWPE.cmake
@@ -13,6 +13,7 @@ list(APPEND WTF_PUBLIC_HEADERS
     linux/ProcessMemoryFootprint.h
     linux/CurrentProcessMemoryStatus.h
     linux/RealTimeThreads.h
+    linux/SystemTracingFTrace.h
 
     unix/UnixFileDescriptor.h
 )
diff --git a/Source/WTF/wtf/SystemTracing.h b/Source/WTF/wtf/SystemTracing.h
index 4a1ccdcaa96e..0aa5fffb7ed0 100644
--- a/Source/WTF/wtf/SystemTracing.h
+++ b/Source/WTF/wtf/SystemTracing.h
@@ -24,6 +24,7 @@
  */
 
 #pragma once
+#include <string.h>
 
 #if USE(APPLE_INTERNAL_SDK)
 #include <System/sys/kdebug.h>
@@ -38,6 +39,7 @@
 // Trace point codes can be up to 14 bits (0-16383).
 // When adding or changing these codes, update Tools/Tracing/SystemTracePoints.plist to match.
 enum TracePointCode {
+    NONE = -1,
     WTFRange = 0,
 
     JavaScriptRange = 2500,
@@ -146,12 +148,21 @@ enum TracePointCode {
 
 #ifdef __cplusplus
 
+#if USE(LINUX_FTRACE)
+#include <wtf/linux/SystemTracingFTrace.h>
+#endif
+
 namespace WTF {
 
 inline void tracePoint(TracePointCode code, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0)
 {
 #if HAVE(KDEBUG_H)
     kdebug_trace(ARIADNEDBG_CODE(WEBKIT_COMPONENT, code), data1, data2, data3, data4);
+#elif USE(LINUX_FTRACE)
+    SystemTracingFTrace::instance().tracePoint(code, data1);
+    UNUSED_PARAM(data2);
+    UNUSED_PARAM(data3);
+    UNUSED_PARAM(data4);
 #else
     UNUSED_PARAM(code);
     UNUSED_PARAM(data1);
@@ -161,23 +172,128 @@ inline void tracePoint(TracePointCode code, uint64_t data1 = 0, uint64_t data2 =
 #endif
 }
 
+inline void tracePoint(const char* message, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0)
+{
+#if USE(LINUX_FTRACE)
+    SystemTracingFTrace::instance().traceInstant(message);
+    UNUSED_PARAM(data1);
+    UNUSED_PARAM(data2);
+    UNUSED_PARAM(data3);
+    UNUSED_PARAM(data4);
+#else
+    UNUSED_PARAM(message);
+    UNUSED_PARAM(data1);
+    UNUSED_PARAM(data2);
+    UNUSED_PARAM(data3);
+    UNUSED_PARAM(data4);
+#endif
+}
+
+
+inline void tracePointBegin(const char* message, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0)
+{
+#if USE(LINUX_FTRACE)
+    SystemTracingFTrace::instance().traceBeginSync(message, data1);
+    UNUSED_PARAM(data2);
+    UNUSED_PARAM(data3);
+    UNUSED_PARAM(data4);
+#else
+    UNUSED_PARAM(message);
+    UNUSED_PARAM(data1);
+    UNUSED_PARAM(data2);
+    UNUSED_PARAM(data3);
+    UNUSED_PARAM(data4);
+#endif
+}
+
+inline void tracePointEnd(const char* message, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0)
+{
+#if USE(LINUX_FTRACE)
+    SystemTracingFTrace::instance().traceEndSync(message, data1);
+    UNUSED_PARAM(data2);
+    UNUSED_PARAM(data3);
+    UNUSED_PARAM(data4);
+#else
+    UNUSED_PARAM(message);
+    UNUSED_PARAM(data1);
+    UNUSED_PARAM(data2);
+    UNUSED_PARAM(data3);
+    UNUSED_PARAM(data4);
+#endif
+}
+
 class TraceScope {
     WTF_MAKE_FAST_ALLOCATED;
 public:
 
     TraceScope(TracePointCode entryCode, TracePointCode exitCode, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0)
-        : m_exitCode(exitCode)
+        : m_exitCode(exitCode), m_message(nullptr)
     {
         tracePoint(entryCode, data1, data2, data3, data4);
     }
 
+    TraceScope(const char* message, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0)
+        : m_exitCode(TracePointCode(-1))//, m_message(nullptr)
+    {
+#if 0
+        if (message) {
+            tracePointBegin(message, data1, data2, data3, data4);
+        } else {
+            tracePointBegin("TraceScope", data1, data2, data3, data4);
+        }
+#else
+        if (message) {
+            m_message = strdup(message);
+        }
+        if (m_message) {
+            tracePointBegin(m_message, data1, data2, data3, data4);
+        } else {
+            tracePointBegin("TraceScope", data1, data2, data3, data4);
+        }
+        //tracePointBegin(m_message, data1, data2, data3, data4);
+        //UNUSED_PARAM(message);
+        UNUSED_PARAM(data1);
+        UNUSED_PARAM(data2);
+        UNUSED_PARAM(data3);
+        UNUSED_PARAM(data4);
+        //m_message = message;
+#endif
+    }
+
     ~TraceScope()
     {
-        tracePoint(m_exitCode);
+        //WTFLogAlways("[GNN] ~TraceScope");
+#if 0
+        if (m_exitCode != TracePointCode(-1)) {
+            tracePoint(m_exitCode);
+            WTFLogAlways("[GNN] tracePoint(m_exitCode)");
+        } else {
+            WTFLogAlways("[GNN] tracePoint(message)");
+            tracePointEnd("END of TraceScope");
+        }
+
+#else
+        if (m_message == nullptr) {
+            //if (m_exitCode != TracePointCode(-1)) {
+                //WTFLogAlways("[GNN] tracePoint(m_exitCode)");
+                tracePoint(m_exitCode);
+                
+            //}
+        }
+        else
+        {
+            //WTFLogAlways("[GNN] m_message != nullptr");
+            tracePointEnd(m_message);
+            //tracePointEnd("END of TraceScope");
+            free(m_message); // Free the duplicated message
+            m_message = nullptr;
+        }
+#endif
     }
 
 private:
     TracePointCode m_exitCode;
+    char* m_message;
 };
 
 } // namespace WTF
diff --git a/Source/WTF/wtf/linux/SystemTracingFTrace.h b/Source/WTF/wtf/linux/SystemTracingFTrace.h
new file mode 100644
index 000000000000..04402dbf25df
--- /dev/null
+++ b/Source/WTF/wtf/linux/SystemTracingFTrace.h
@@ -0,0 +1,475 @@
+/*
+ * Copyright (C) 2024 Igalia, S.L.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#pragma once
+
+#if USE(LINUX_FTRACE)
+
+#include <wtf/Assertions.h>
+#include <wtf/SystemTracing.h>
+#include <wtf/text/ASCIILiteral.h>
+
+#include <cstdio>
+#include <cstring>
+#include <mutex>
+#include <string>
+#include <fcntl.h>
+#include <unistd.h>
+
+namespace WTF {
+
+class SystemTracingFTrace {
+public:
+    static SystemTracingFTrace& instance() {
+        static SystemTracingFTrace instance;
+        return instance;
+    }
+
+    inline void traceBeginSync(const char* str, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0) {
+        beginSyncMark(str);
+        UNUSED_PARAM(data1);
+        UNUSED_PARAM(data2);
+        UNUSED_PARAM(data3);
+        UNUSED_PARAM(data4);
+    }
+    inline void traceEndSync(const char* str, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0) {
+        endSyncMark(str);
+        UNUSED_PARAM(data1);
+        UNUSED_PARAM(data2);
+        UNUSED_PARAM(data3);
+        UNUSED_PARAM(data4);
+    }
+
+    inline void traceInstant(const char* str, uint64_t data1 = 0, uint64_t data2 = 0, uint64_t data3 = 0, uint64_t data4 = 0) {
+        instantMark(str);
+        UNUSED_PARAM(data1);
+        UNUSED_PARAM(data2);
+        UNUSED_PARAM(data3);
+        UNUSED_PARAM(data4);
+    }
+
+    inline void tracePoint(TracePointCode code, uint64_t cookie) {
+        // ftrace disabled in runtime
+        if (m_traceMarkerFd < 0) return;
+
+        switch (code) {
+        case VMEntryScopeStart:
+        case WebAssemblyCompileStart:
+        case WebAssemblyExecuteStart:
+        case DumpJITMemoryStart:
+        case FromJSStart:
+        case FetchCookiesStart:
+        case StyleRecalcStart:
+        case LayoutStart:
+        case RenderTreeBuildStart:
+        case PaintLayerStart:
+        case AsyncImageDecodeStart:
+        case RAFCallbackStart:
+        case MemoryPressureHandlerStart:
+        case UpdateTouchRegionsStart:
+        case DisplayListRecordStart:
+        case ComputeEventRegionsStart:
+        case RenderingUpdateStart:
+        case CompositingUpdateStart:
+        case DispatchTouchEventsStart:
+        case ParseHTMLStart:
+        case DisplayListReplayStart:
+        case ScrollingThreadRenderUpdateSyncStart:
+        case ScrollingThreadDisplayDidRefreshStart:
+        case WebHTMLViewPaintStart:
+        case BackingStoreFlushStart:
+        case BuildTransactionStart:
+        case SyncMessageStart:
+        case SyncTouchEventStart:
+        case InitializeWebProcessStart:
+        case RenderingUpdateRunLoopObserverStart:
+        case LayerTreeFreezeStart:
+        case FlushRemoteImageBufferStart:
+        case CreateInjectedBundleStart:
+        case PaintSnapshotStart:
+        case RenderServerSnapshotStart:
+        case TakeSnapshotStart:
+        case SyntheticMomentumStart:
+        case CommitLayerTreeStart:
+        case ProcessLaunchStart:
+        case InitializeSandboxStart:
+        case WakeUpAndApplyDisplayListStart:
+            beginSyncMark(code);
+            return;
+
+        case VMEntryScopeEnd:
+        case WebAssemblyCompileEnd:
+        case WebAssemblyExecuteEnd:
+        case DumpJITMemoryStop:
+        case FromJSStop:
+        case FetchCookiesEnd:
+        case StyleRecalcEnd:
+        case LayoutEnd:
+        case RenderTreeBuildEnd:
+        case PaintLayerEnd:
+        case AsyncImageDecodeEnd:
+        case RAFCallbackEnd:
+        case MemoryPressureHandlerEnd:
+        case UpdateTouchRegionsEnd:
+        case DisplayListRecordEnd:
+        case ComputeEventRegionsEnd:
+        case RenderingUpdateEnd:
+        case CompositingUpdateEnd:
+        case DispatchTouchEventsEnd:
+        case ParseHTMLEnd:
+        case DisplayListReplayEnd:
+        case ScrollingThreadRenderUpdateSyncEnd:
+        case ScrollingThreadDisplayDidRefreshEnd:
+        case WebHTMLViewPaintEnd:
+        case BackingStoreFlushEnd:
+        case BuildTransactionEnd:
+        case SyncMessageEnd:
+        case SyncTouchEventEnd:
+        case InitializeWebProcessEnd:
+        case RenderingUpdateRunLoopObserverEnd:
+        case LayerTreeFreezeEnd:
+        case FlushRemoteImageBufferEnd:
+        case CreateInjectedBundleEnd:
+        case PaintSnapshotEnd:
+        case RenderServerSnapshotEnd:
+        case TakeSnapshotEnd:
+        case SyntheticMomentumEnd:
+        case CommitLayerTreeEnd:
+        case ProcessLaunchEnd:
+        case InitializeSandboxEnd:
+        case WakeUpAndApplyDisplayListEnd:
+            endSyncMark(code);
+            return;
+
+        case MainResourceLoadDidStartProvisional:
+        case SubresourceLoadWillStart:
+            beginAsyncMark(code, cookie);
+            return;
+
+        case MainResourceLoadDidEnd:
+        case SubresourceLoadDidEnd:
+            endAsyncMark(code, cookie);
+            return;
+
+        case DisplayRefreshDispatchingToMainThread:
+        case ScheduleRenderingUpdate:
+        case TriggerRenderingUpdate:
+        case ScrollingTreeDisplayDidRefresh:
+        case SyntheticMomentumEvent:
+            instantMark(code);
+            return;
+
+        case WTFRange:
+        case JavaScriptRange:
+        case WebCoreRange:
+        case WebKitRange:
+        case WebKit2Range:
+        case UIProcessRange:
+        case GPUProcessRange:
+            break;
+        }
+
+        WTFLogAlways("Invalid trace point code %d", code);
+    }
+
+    ~SystemTracingFTrace() {
+        if (m_traceMarkerFd >= 0) {
+            close(m_traceMarkerFd);
+        }
+    }
+
+private:
+    inline void beginSyncMark(const char* message) {
+        // "B|<pid>|<name>"
+        std::string entry = std::string("B|") + std::to_string(m_pid) + "|" + (message != nullptr ? message : "");
+        //std::string entry = std::string("B|") + std::to_string(m_pid) + "|" + message;
+        writeFTraceMarker(entry.c_str());
+    }
+
+    inline void beginSyncMark(TracePointCode code) {
+        // "B|<pid>|<name>"
+        beginSyncMark(tracePointCodeName(code).characters());
+        //std::string message = std::string("B|") + std::to_string(m_pid) + "|" + tracePointCodeName(code).characters();
+        //writeFTraceMarker(message.c_str());
+    }
+
+    inline void endSyncMark(const char* message) {
+        //UNUSED_PARAM(message);
+        // "E|<pid>"
+        std::string entry = std::string("E|") + std::to_string(m_pid) + "|" + (message != nullptr ? message : "");
+        writeFTraceMarker(entry.c_str());
+    }
+
+    inline void endSyncMark(TracePointCode code) {
+        UNUSED_PARAM(code);
+        // "E|<pid>"
+        endSyncMark(tracePointCodeName(code).characters());
+        //std::string message = std::string("E|") + std::to_string(m_pid);
+        //writeFTraceMarker(message.c_str());
+    }
+
+    inline void beginAsyncMark(const char* message, uint64_t cookie) {
+        // "S|<pid>|<name>|<cookie>"
+        std::string entry = std::string("S|") + std::to_string(m_pid) + "|" 
+                            + (message != nullptr ? message : "") + "|" + std::to_string(cookie);
+        writeFTraceMarker(entry.c_str());
+    }
+
+    inline void beginAsyncMark(TracePointCode code, uint64_t cookie) {
+        // "S|<pid>|<name>|<cookie>"
+        beginAsyncMark(tracePointCodeName(code).characters(), cookie);
+        //std::string message = std::string("S|") + std::to_string(m_pid) + "|" + tracePointCodeName(code).characters() + "|" + std::to_string(cookie);
+        //writeFTraceMarker(message.c_str());
+    }
+
+    inline void endAsyncMark(const char* message, uint64_t cookie) {
+        // "F|<pid>|<name>|<cookie>"
+        std::string entry = std::string("F|") + std::to_string(m_pid) + "|" + (message != nullptr ? message : "")
+                            + "|" + std::to_string(cookie);
+        writeFTraceMarker(entry.c_str());
+    }
+
+    inline void endAsyncMark(TracePointCode code, uint64_t cookie) {
+        // "F|<pid>|<name>|<cookie>"
+        endAsyncMark(tracePointCodeName(code).characters(), cookie);
+        //std::string message = std::string("F|") + std::to_string(m_pid) + "|" + tracePointCodeName(code).characters() + "|" + std::to_string(cookie);
+        //writeFTraceMarker(message.c_str());
+    }
+
+    inline void instantMark(const char* message) {
+        // "I|<pid>|<name>"
+        std::string entry = std::string("I|") + std::to_string(m_pid) + "|" + (message != nullptr ? message : "");
+        //std::ostringstream oss;
+        //oss << "I|" << m_pid << "|" << (message != nullptr ? message : "");
+        //std::string entry = oss.str();
+        writeFTraceMarker(entry.c_str());
+    }
+
+    inline void instantMark(TracePointCode code) {
+        // "I|<pid>|<name>"
+        instantMark(tracePointCodeName(code).characters());
+        //std::ostringstream oss;
+        //oss << "I|" << m_pid << "|" << tracePointCodeName(code).characters();
+        //std::string message = oss.str();
+
+        //std::string message = std::string("I|") + std::to_string(m_pid) + "|" + tracePointCodeName(code).characters();
+        //writeFTraceMarker(message.c_str());
+    }
+
+    inline void writeFTraceMarker(const char* message) {
+        //RELEASE_ASSERT(m_traceMarkerFd >= 0);
+        if (m_traceMarkerFd < 0) {
+            //WTFLogAlways("Invalid trace file descriptor. Possibly ftrace not enabled");
+            return;
+        }
+        // make sure no other thread is writing at the same time
+        std::lock_guard<std::mutex> lock(m_mutex);
+        write(m_traceMarkerFd, message, strlen(message));
+    }
+
+    SystemTracingFTrace() {
+        // Need to enable in runtime with WEBKIT_USE_FTRACE
+        const char* env = getenv("WEBKIT_USE_FTRACE");
+        if (!env || strcmp(env, "1") != 0) {
+            return;
+        }
+
+        static constexpr const char* trace_marker = "/sys/kernel/debug/tracing/trace_marker";
+        m_traceMarkerFd = open(trace_marker, O_WRONLY);
+        if (m_traceMarkerFd < 0) {
+            WTFLogAlways("Failed to open %s", trace_marker);
+            return;
+        }
+
+        m_pid = getpid();
+    }
+
+    inline ASCIILiteral tracePointCodeName(TracePointCode code) {
+        switch (code) {
+        case VMEntryScopeStart:
+        case VMEntryScopeEnd:
+            return "VMEntryScope"_s;
+        case WebAssemblyCompileStart:
+        case WebAssemblyCompileEnd:
+            return "WebAssemblyCompile"_s;
+        case WebAssemblyExecuteStart:
+        case WebAssemblyExecuteEnd:
+            return "WebAssemblyExecute"_s;
+        case DumpJITMemoryStart:
+        case DumpJITMemoryStop:
+            return "DumpJITMemory"_s;
+        case FromJSStart:
+        case FromJSStop:
+            return "FromJS"_s;
+
+        case MainResourceLoadDidStartProvisional:
+        case MainResourceLoadDidEnd:
+            return "MainResourceLoad"_s;
+        case SubresourceLoadWillStart:
+        case SubresourceLoadDidEnd:
+            return "SubresourceLoad"_s;
+        case FetchCookiesStart:
+        case FetchCookiesEnd:
+            return "FetchCookies"_s;
+        case StyleRecalcStart:
+        case StyleRecalcEnd:
+            return "StyleRecalc"_s;
+        case LayoutStart:
+        case LayoutEnd:
+            return "Layout"_s;
+        case RenderTreeBuildStart:
+        case RenderTreeBuildEnd:
+            return "RenderTreeBuild"_s;
+        case PaintLayerStart:
+        case PaintLayerEnd:
+            return "PaintLayer"_s;
+        case AsyncImageDecodeStart:
+        case AsyncImageDecodeEnd:
+            return "AsyncImageDecode"_s;
+        case RAFCallbackStart:
+        case RAFCallbackEnd:
+            return "RAFCallback"_s;
+        case MemoryPressureHandlerStart:
+        case MemoryPressureHandlerEnd:
+            return "MemoryPressureHandler"_s;
+        case UpdateTouchRegionsStart:
+        case UpdateTouchRegionsEnd:
+            return "UpdateTouchRegions"_s;
+        case DisplayListRecordStart:
+        case DisplayListRecordEnd:
+            return "DisplayListRecord"_s;
+        case DisplayRefreshDispatchingToMainThread:
+            return "DisplayRefreshDispatchingToMainThread"_s;
+        case ComputeEventRegionsStart:
+        case ComputeEventRegionsEnd:
+            return "ComputeEventRegions"_s;
+        case ScheduleRenderingUpdate:
+            return "ScheduleRenderingUpdate"_s;
+        case TriggerRenderingUpdate:
+            return "TriggerRenderingUpdate"_s;
+        case RenderingUpdateStart:
+        case RenderingUpdateEnd:
+            return "RenderingUpdate"_s;
+        case CompositingUpdateStart:
+        case CompositingUpdateEnd:
+            return "CompositingUpdate"_s;
+        case DispatchTouchEventsStart:
+        case DispatchTouchEventsEnd:
+            return "DispatchTouchEvents"_s;
+        case ParseHTMLStart:
+        case ParseHTMLEnd:
+            return "ParseHTML"_s;
+        case DisplayListReplayStart:
+        case DisplayListReplayEnd:
+            return "DisplayListReplay"_s;
+        case ScrollingThreadRenderUpdateSyncStart:
+        case ScrollingThreadRenderUpdateSyncEnd:
+            return "ScrollingThreadRenderUpdateSync"_s;
+        case ScrollingThreadDisplayDidRefreshStart:
+        case ScrollingThreadDisplayDidRefreshEnd:
+            return "ScrollingThreadDisplayDidRefresh"_s;
+        case ScrollingTreeDisplayDidRefresh:
+            return "ScrollingTreeDisplayDidRefresh"_s;
+
+        case WebHTMLViewPaintStart:
+        case WebHTMLViewPaintEnd:
+            return "WebHTMLViewPaint"_s;
+
+        case BackingStoreFlushStart:
+        case BackingStoreFlushEnd:
+            return "BackingStoreFlush"_s;
+        case BuildTransactionStart:
+        case BuildTransactionEnd:
+            return "BuildTransaction"_s;
+        case SyncMessageStart:
+        case SyncMessageEnd:
+            return "SyncMessage"_s;
+        case SyncTouchEventStart:
+        case SyncTouchEventEnd:
+            return "SyncTouchEvent"_s;
+        case InitializeWebProcessStart:
+        case InitializeWebProcessEnd:
+            return "InitializeWebProcess"_s;
+        case RenderingUpdateRunLoopObserverStart:
+        case RenderingUpdateRunLoopObserverEnd:
+            return "RenderingUpdateRunLoopObserver"_s;
+        case LayerTreeFreezeStart:
+        case LayerTreeFreezeEnd:
+            return "LayerTreeFreeze"_s;
+        case FlushRemoteImageBufferStart:
+        case FlushRemoteImageBufferEnd:
+            return "FlushRemoteImageBuffer"_s;
+        case CreateInjectedBundleStart:
+        case CreateInjectedBundleEnd:
+            return "CreateInjectedBundle"_s;
+        case PaintSnapshotStart:
+        case PaintSnapshotEnd:
+            return "PaintSnapshot"_s;
+        case RenderServerSnapshotStart:
+        case RenderServerSnapshotEnd:
+            return "RenderServerSnapshot"_s;
+        case TakeSnapshotStart:
+        case TakeSnapshotEnd:
+            return "TakeSnapshot"_s;
+        case SyntheticMomentumStart:
+        case SyntheticMomentumEnd:
+            return "SyntheticMomentum"_s;
+        case SyntheticMomentumEvent:
+            return "SyntheticMomentumEvent"_s;
+
+        case CommitLayerTreeStart:
+        case CommitLayerTreeEnd:
+            return "CommitLayerTree"_s;
+        case ProcessLaunchStart:
+        case ProcessLaunchEnd:
+            return "ProcessLaunch"_s;
+        case InitializeSandboxStart:
+        case InitializeSandboxEnd:
+            return "InitializeSandbox"_s;
+
+        case WakeUpAndApplyDisplayListStart:
+        case WakeUpAndApplyDisplayListEnd:
+            return "WakeUpAndApplyDisplayList"_s;
+
+        // Markers, not intended to be used in tracePoint calls.
+        case WTFRange:
+        case JavaScriptRange:
+        case WebCoreRange:
+        case WebKitRange:
+        case WebKit2Range:
+        case UIProcessRange:
+        case GPUProcessRange:
+            break;
+        }
+        WTFLogAlways("Invalid trace point code %d", code);
+        return ""_s;
+    }
+
+    SystemTracingFTrace(const SystemTracingFTrace&) = delete;
+    SystemTracingFTrace& operator=(const SystemTracingFTrace&) = delete;
+
+private:
+    int m_traceMarkerFd = -1;
+    std::mutex m_mutex;
+    unsigned m_pid = -1;
+};
+
+} // namespace WTF
+
+#endif // USE(LINUX_FTRACE)
\ No newline at end of file
diff --git a/Source/cmake/OptionsWPE.cmake b/Source/cmake/OptionsWPE.cmake
index 6fb61bfbcf81..57d145825caf 100644
--- a/Source/cmake/OptionsWPE.cmake
+++ b/Source/cmake/OptionsWPE.cmake
@@ -108,6 +108,7 @@ WEBKIT_OPTION_DEFINE(USE_EXTERNAL_HOLEPUNCH "Whether to enable external holepunc
 WEBKIT_OPTION_DEFINE(ENABLE_ACCELERATED_2D_CANVAS "Whether to enable accelerated 2D canvas" PRIVATE OFF)
 WEBKIT_OPTION_DEFINE(ENABLE_OIPF_VK "Whether to enable OIPF keys for DAE applications" PRIVATE OFF)
 WEBKIT_OPTION_DEFINE(ENABLE_INSTANT_RATE_CHANGE "Whether to enable instant rate change" PRIVATE OFF)
+WEBKIT_OPTION_DEFINE(USE_LINUX_FTRACE "Whether to use ftrace based webkit tracing" PRIVATE ON)
 
 # Debug memory heap breakdown with malloc-zone allocator
 WEBKIT_OPTION_DEFINE(ENABLE_MALLOC_HEAP_BREAKDOWN "Whether to enable malloc heap breakdown" PRIVATE OFF)
-- 
2.25.1

