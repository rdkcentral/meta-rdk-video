diff --git a/Source/core/JSON.h b/Source/core/JSON.h
index e6293d876..5a10b955f 100644
--- a/Source/core/JSON.h
+++ b/Source/core/JSON.h
@@ -1937,7 +1937,7 @@ namespace Core {
                             // We are assumed to be opaque, but all quoted string stuff is enclosed between quotes
                             // and should be considered for scope counting.
                             // Check if we are entering or leaving a quoted area in the opaque object
-                            if ((current == '\"') && ((_value.empty() == true) || IsEscaped(_value))) {
+                            if ((current == '\"') && ((_value.empty() == true) || (_value[_value.length() - 2] != '\\'))) {
                                 // This is not an "escaped" quote, so it should be considered a real quote. It means
                                 // we are now entering or leaving a quoted area within the opaque struct...
                                 _flagsAndCounters ^= QuotedAreaBit;
@@ -2135,19 +2135,6 @@ namespace Core {
             }
 
         private:
-            bool IsEscaped(const string& value) const {
-                // This code determines if a lot of back slashes to esscape the backslash
-                // Is odd or even, so does it escape the last character..
-                // e.g. 'Test \\\\\\\\\\"' is not the escaping of the quote (")
-                //      'Test \\\\\\\\\" continued"'  is the escaping of th quote..
-                //      'Test \" and \" and than \\\"' are all escaped quotes 
-                uint32_t index = static_cast<uint32_t>(value.length() - 1);
-                uint32_t start = index;
-                while ( (index != static_cast<uint32_t>(~0)) && (value[index] == '\\') ) {
-                    index--;
-                }
-                return (((start - index) % 2) == 0);
-            }
             bool InScope(const ScopeBracket mode) {
                 bool added = false;
                 uint8_t depth = (_flagsAndCounters & 0x1F);
