diff --git a/Source/WPEFramework/PluginServer.cpp b/Source/WPEFramework/PluginServer.cpp
index 04bae6775..6019d94cf 100644
--- a/Source/WPEFramework/PluginServer.cpp
+++ b/Source/WPEFramework/PluginServer.cpp
@@ -274,6 +274,11 @@ namespace PluginHost
         _processAdministrator.Destroy();
     }
 
+    /* static */ Core::ProxyType<Core::IDispatch> Server::ServiceMap::CommunicatorServer::DanglingNotifierJob::Create(Server::ServiceMap::CommunicatorServer* commServer, RPC::Administrator::Proxies& deadProxies)
+    {
+        return (Core::ProxyType<Core::IDispatch>(Core::ProxyType<Server::ServiceMap::CommunicatorServer::DanglingNotifierJob>::Create(commServer, deadProxies)));
+    }
+
     /* virtual */ void* Server::Service::QueryInterface(const uint32_t id)
     {
         void* result = nullptr;
diff --git a/Source/WPEFramework/PluginServer.h b/Source/WPEFramework/PluginServer.h
index 317be4fd3..ee80c4411 100644
--- a/Source/WPEFramework/PluginServer.h
+++ b/Source/WPEFramework/PluginServer.h
@@ -2389,6 +2389,45 @@ namespace PluginHost {
                     CommunicatorServer& _parent;
                     string _observerPath;
                 };
+                class DanglingNotifierJob : public Core::IDispatch {
+                    protected:
+                        DanglingNotifierJob(CommunicatorServer* commServer, RPC::Administrator::Proxies& deadProxies)
+                            : _commServer(commServer)
+                            , _deadProxies(deadProxies)
+                        {
+                        }
+
+                    public:
+                        DanglingNotifierJob() = delete;
+                        DanglingNotifierJob(const DanglingNotifierJob&) = delete;
+                        DanglingNotifierJob& operator=(const DanglingNotifierJob&) = delete;
+
+                        ~DanglingNotifierJob() override
+                        {
+                            std::vector<ProxyStub::UnknownProxy*>::const_iterator loop(_deadProxies.begin());
+                            while (loop != _deadProxies.end()) {
+                                // To avoid race conditions, the creation of the deadProxies took a reference
+                                // on the interfaces, we presented here. Do not forget to release this reference.
+                                if ((*loop)->Parent()->Release()!= Core::ERROR_DESTRUCTION_SUCCEEDED) {
+                                    TRACE(Trace::Warning, (_T("Potentially a Proxy leak on interface %d"), (*loop)->InterfaceId()));
+                                }
+                                loop++;
+                            }
+                            _deadProxies.clear();
+                        }
+
+                    public:
+                        static Core::ProxyType<Core::IDispatch> Create(CommunicatorServer* commServer, RPC::Administrator::Proxies& deadProxies);
+
+                        void Dispatch() override
+                        {
+                            _commServer->NotifyDangling(_deadProxies);
+                        }
+
+                    private:
+                        CommunicatorServer* _commServer;
+                        RPC::Administrator::Proxies _deadProxies;
+                };
 
             public:
                 CommunicatorServer() = delete;
@@ -2537,7 +2576,21 @@ namespace PluginHost {
                         _adminLock.Unlock();
                     }
                 }
+                void NotifyDangling(RPC::Administrator::Proxies& deadProxies){
+                    // Oke time to notify the destruction of some proxies...
+                    _adminLock.Lock();
 
+                    std::vector<ProxyStub::UnknownProxy*>::const_iterator loop(deadProxies.begin());
+                    while (loop != deadProxies.end()) {
+                        _parent.Dangling((*loop)->Parent(), (*loop)->InterfaceId());
+
+                        for (IShell::ICOMLink::INotification* observer : _requestObservers) {
+                            observer->Dangling((*loop)->Parent(), (*loop)->InterfaceId());
+                        }
+                        loop++;
+                    }
+                    _adminLock.Unlock();
+                }
             private:
                 void Reload(const string& path) {
                     TRACE(Activity, (Core::Format(_T("Reloading ProxyStubs from %s."), path.c_str())));
@@ -2576,20 +2629,9 @@ namespace PluginHost {
                 {
                     return (_parent.Acquire(interfaceId, className, version));
                 }
-
-                void Dangling(const Core::IUnknown* source, const uint32_t interfaceId) override
+                void Dangling(RPC::Administrator::Proxies& deadProxies) override
                 {
-                    _adminLock.Lock();
-
-                    _parent.Dangling(source, interfaceId);
-
-                    for (auto& observer : _requestObservers) {
-                        observer->Dangling(source, interfaceId);
-                    }
-
-                    _adminLock.Unlock();
-
-                    TRACE(Activity, (_T("Dangling resource cleanup of interface: 0x%X"), interfaceId));
+                    Core::IWorkerPool::Instance().Submit(DanglingNotifierJob::Create(this, deadProxies));
                 }
 
                 void Revoke(const Core::IUnknown* remote, const uint32_t interfaceId) override
diff --git a/Source/com/Communicator.h b/Source/com/Communicator.h
index 9866f486b..91cb1b0f9 100644
--- a/Source/com/Communicator.h
+++ b/Source/com/Communicator.h
@@ -1521,18 +1521,11 @@ POP_WARNING()
             std::list<ProxyStub::UnknownProxy*> deadProxies;
 
             RPC::Administrator::Instance().DeleteChannel(channel, deadProxies);
-
-            std::list<ProxyStub::UnknownProxy*>::const_iterator loop(deadProxies.begin());
-            while (loop != deadProxies.end()) {
-                Dangling((*loop)->Parent(), (*loop)->InterfaceId());
-
-                // To avoid race conditions, the creation of the deadProxies took a reference
-                // on the interfaces, we presented here. Do not forget to release this reference.
-                if ((*loop)->Parent()->Release() != Core::ERROR_DESTRUCTION_SUCCEEDED) {
-                    // This is a leak, someone is still referencing a Proxy that is as dead as a pier !
-                    TRACE_L1("The Proxy for [%d] is still being referenced although the link is gone !!!", (*loop)->InterfaceId());
-                }
-                loop++;
+                
+            std::vector<ProxyStub::UnknownProxy*> _deadProxies(deadProxies.begin(), deadProxies.end());
+            if(deadProxies.size() > 0)
+            {
+                Dangling(_deadProxies);
             }
         }
         virtual void* Acquire(const string& /* className */, const uint32_t /* interfaceId */, const uint32_t /* version */)
@@ -1543,7 +1536,7 @@ POP_WARNING()
         }
         virtual void Revoke(const Core::IUnknown* /* remote */, const uint32_t /* interfaceId */) {
         }
-        virtual void Dangling(const Core::IUnknown* /* remote */, const uint32_t /* interfaceId */) {
+        virtual void Dangling(Administrator::Proxies& /* deadProxies*/) {
         }
 
     private:
