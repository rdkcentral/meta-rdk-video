diff --git a/Utils/PluginActivator/CMakeLists.txt b/Utils/PluginActivator/CMakeLists.txt
index bd465e3a..5f88d771 100644
--- a/Utils/PluginActivator/CMakeLists.txt
+++ b/Utils/PluginActivator/CMakeLists.txt
@@ -26,6 +26,7 @@ add_executable(${PROJECT_NAME}
     source/Module.cpp
     source/main.cpp
     source/COMRPCStarter.cpp
+    source/NotificationHandler.cpp
 )
 
 target_link_libraries(${PROJECT_NAME}
diff --git a/Utils/PluginActivator/source/COMRPCStarter.cpp b/Utils/PluginActivator/source/COMRPCStarter.cpp
index f2d27ed4..9a93c070 100644
--- a/Utils/PluginActivator/source/COMRPCStarter.cpp
+++ b/Utils/PluginActivator/source/COMRPCStarter.cpp
@@ -49,7 +49,10 @@ bool COMRPCStarter::activatePlugin(const uint8_t maxRetries, const uint16_t retr
     // Attempt to open the plugin shell
     bool success = false;
     int currentRetry = 1;
-
+    IPluginNotification pluginNotification;
+    Core::hresult result_changestate_notify=Core::ERROR_NONE;
+    bool result_waitstate = false;
+	
     while (!success && currentRetry <= maxRetries) {
         LOG_INF(_pluginName.c_str(), "Attempting to activate plugin - attempt %d/%d", currentRetry, maxRetries);
 
@@ -73,10 +76,37 @@ bool COMRPCStarter::activatePlugin(const uint8_t maxRetries, const uint16_t retr
             // Sleep, then try again
             std::this_thread::sleep_for(std::chrono::milliseconds(retryDelayMs));
         } else {
-            // Will block until plugin is activated
-            uint32_t result = lifetime->Activate(_pluginName.c_str());
 
-            auto duration = Core::Time::Now().Sub(start.MilliSeconds());
+	    LOG_INF(_pluginName.c_str(), "Before Register to state change activate plugin lifetime =  0x%x",lifetime);
+	    result_changestate_notify = lifetime->Register(&pluginNotification);
+           LOG_INF(_pluginName.c_str(), "Return Value result_changestate_notify=%u and Core::ERROR_NONE=%u",result_changestate_notify,Core::ERROR_NONE);			
+           if (result_changestate_notify == Core::ERROR_NONE) 
+	    {
+		  LOG_INF(_pluginName.c_str(), "New Register to state change activate plugin Success");
+	    } 
+	    else
+	    {
+	         LOG_INF(_pluginName.c_str(), "New Register to state change activate plugin Failed result_changestate_notify=%u",result_changestate_notify);
+           }
+	    LOG_INF(_pluginName.c_str(), "ResetActivationPluginFlag called for =%s",_pluginName.c_str());					
+	    pluginNotification.ResetActivationPluginFlag(_pluginName.c_str());		
+			
+    	    uint32_t result = lifetime->Activate(_pluginName.c_str());
+
+	    LOG_INF(_pluginName.c_str(), "Waiting to activate plugin and max limit 60 secs or 1 min");
+	    result_waitstate = pluginNotification.WaitforPluginActivationCompletion(_pluginName, PLUGIN_ACTIVATION_TIMEOUT_MS);
+	    if(!result_waitstate)
+	    {
+	    	LOG_INF(_pluginName.c_str(), "WaitforPluginActivationCompletion Timed out after timeout delay of %d msec",PLUGIN_ACTIVATION_TIMEOUT_MS);
+	    }
+	    else
+	    {
+	    	LOG_INF(_pluginName.c_str(), "Waiting to activate plugin Completed setting in CB and either waited or no wait ");		
+	    }
+           result_changestate_notify = lifetime->Unregister(&pluginNotification);
+           LOG_INF(_pluginName.c_str(), "Activate UnRegister is Completed");
+			
+           auto duration = Core::Time::Now().Sub(start.MilliSeconds());
 
             if (result != Core::ERROR_NONE) {
                 if (result == Core::ERROR_PENDING_CONDITIONS) {
@@ -91,7 +121,7 @@ bool COMRPCStarter::activatePlugin(const uint8_t maxRetries, const uint16_t retr
                 std::this_thread::sleep_for(std::chrono::milliseconds(retryDelayMs));
             } else {
                 // Our work here is done!
-                LOG_INF(_pluginName.c_str(), "Successfully activated plugin after %dms", duration.MilliSeconds());
+	        LOG_INF(_pluginName.c_str(), "Successfully activated plugin after %dms", duration.MilliSeconds());
                 success = true;
             }
             lifetime->Release();
diff --git a/Utils/PluginActivator/source/COMRPCStarter.h b/Utils/PluginActivator/source/COMRPCStarter.h
index 44fecef8..d7d8def4 100644
--- a/Utils/PluginActivator/source/COMRPCStarter.h
+++ b/Utils/PluginActivator/source/COMRPCStarter.h
@@ -21,6 +21,7 @@
 #include "Module.h"
 
 #include "IPluginStarter.h"
+#include "INotification.h"
 
 using namespace WPEFramework;
 
@@ -42,4 +43,4 @@ private:
 private:
     ControllerConnector _connector;
     const string _pluginName;
-};
\ No newline at end of file
+};
diff --git a/Utils/PluginActivator/source/INotification.h b/Utils/PluginActivator/source/INotification.h
new file mode 100755
index 00000000..c814bce5
--- /dev/null
+++ b/Utils/PluginActivator/source/INotification.h
@@ -0,0 +1,89 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 Metrological
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+#include "Module.h"
+#include "IPluginStarter.h"
+#include "IShell.h"
+#include <string>
+#include <mutex>
+#include <condition_variable>
+#include <unordered_map>
+#include <chrono>
+
+/**
+ * Interface to start a specified plugin
+ *
+ * Could be implemented with JSON-RPC or COM-RPC
+ */
+
+using namespace WPEFramework;
+using namespace Exchange;
+using namespace Controller;
+
+#define PLUGIN_ACTIVATION_TIMEOUT_MS      (180 * 1000)
+
+
+class IPluginNotification : public WPEFramework::Exchange::Controller::ILifeTime::INotification{
+private:
+    /*
+      * This is the mutex variable used to handle the other condition variables and lock it during accessing. 
+      */
+    std::mutex _mutex;
+    /*
+      * This is the Condition variable used to wait and signal for the activation.
+      */
+    std::unordered_map<std::string, std::condition_variable> _pluginCondVars;
+    /*
+      * This is the _pluginActivated variable used maintain the activation state, initally it will be set to false, 
+      * if plugin is activated, it will be set to true in call back.
+      */
+    std::unordered_map<std::string, bool> _pluginActivated;
+
+public:
+
+    IPluginNotification() = default;
+    ~IPluginNotification() override = default;
+
+    /**
+     * @brief Activate a Thunder plugin
+     *
+     * Will call back StateChange after the Transition has happened
+     *
+     * @param[in]   callsign 
+     *
+     * @param[in]   state  
+     *                             
+     * @param[in]   reason
+     */
+     void StateChange(const string& callsign, const PluginHost::IShell::state& state, const PluginHost::IShell::reason& reason) override;
+     void ResetActivationPluginFlag(const std::string& pluginName);
+     bool WaitforPluginActivationCompletion(const std::string& pluginName, int timeoutMs);
+     Core::hresult Register(INotification* sink);
+     Core::hresult Unregister(INotification* sink);
+     Core::hresult Activate(const string& callsign);
+     Core::hresult Deactivate(const string& callsign);
+     Core::hresult Unavailable(const string& callsign);
+     Core::hresult Hibernate(const string& callsign, const Core::hresult timeout);
+     Core::hresult Suspend(const string& callsign);
+     Core::hresult Resume(const string& callsign);
+     void AddRef() const;
+     uint32_t Release() const;
+     void* QueryInterface(const uint32_t interfaceNumber);
+};
diff --git a/Utils/PluginActivator/source/NotificationHandler.cpp b/Utils/PluginActivator/source/NotificationHandler.cpp
new file mode 100755
index 00000000..897f0efe
--- /dev/null
+++ b/Utils/PluginActivator/source/NotificationHandler.cpp
@@ -0,0 +1,130 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 Metrological
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "COMRPCStarter.h"
+
+#include "Log.h"
+
+#include <chrono>
+#include <thread>
+
+
+
+void IPluginNotification::StateChange(const std::string& callsign, const PluginHost::IShell::state& state, const PluginHost::IShell::reason& reason)
+{
+	LOG_INF(callsign.c_str(), "State Change Notification Received state=%d reason=%d", state, reason);
+	std::lock_guard<std::mutex> lock(_mutex);
+	if ((state == PluginHost::IShell::ACTIVATED) && (_pluginActivated[callsign] == false)) 
+	{
+		LOG_INF(callsign.c_str(), "State Change State is Activated and Signaling");
+        	_pluginActivated[callsign] = true;
+        	_pluginCondVars[callsign].notify_one();
+    	}
+	LOG_INF(callsign.c_str(), "State Change Exit");
+}
+
+
+bool IPluginNotification::WaitforPluginActivationCompletion(const std::string& pluginName, int timeoutMs) {
+	LOG_INF(pluginName.c_str(), "WaitforPluginActivationCompletion pluginName=%s and _pluginActivated[pluginName]=%s", pluginName.c_str(),_pluginActivated[pluginName] ? "true" : "false");
+
+	std::unique_lock<std::mutex> lock(_mutex);
+	auto& condVar = _pluginCondVars[pluginName];
+
+	/*
+	  * This is observed the intermittently before the WaitforPluginActivationCompletion waiting happening
+	  * The call back of the StateChange has been triggered with state as acivated, which will set the 
+	  * 
+	  * _pluginActivated state to true. 
+	  * This is a case if _pluginActivated is true, we need not wait for the plugin activation 
+	  * to activate as it is already true and activated.
+	  */
+	if(_pluginActivated[pluginName] == false)
+	{
+	    return condVar.wait_for(lock, std::chrono::milliseconds(timeoutMs), [&]() {
+	        return _pluginActivated[pluginName];
+	    });	
+	}
+	else
+	{
+	    LOG_INF(pluginName.c_str(), "WaitforPluginActivationCompletion is already True");
+	}
+	return _pluginActivated[pluginName];
+}
+
+void IPluginNotification::ResetActivationPluginFlag(const std::string& pluginName) {
+    std::unique_lock<std::mutex> lock(_mutex);
+     _pluginActivated[pluginName] = false;
+	LOG_INF(pluginName.c_str(), "ResetActivationPluginFlag _pluginActivated=%d", _pluginActivated[pluginName]);
+}
+
+Core::hresult IPluginNotification::Register(INotification* sink)
+{
+	return Core::ERROR_NONE;
+}
+ 
+Core::hresult IPluginNotification::Unregister(INotification* sink)
+{
+	return Core::ERROR_NONE;
+}
+
+Core::hresult IPluginNotification::Activate(const string& callsign)
+{
+	return Core::ERROR_NONE;
+}
+
+Core::hresult IPluginNotification::Deactivate(const string& callsign)
+{
+	return Core::ERROR_NONE;
+}
+
+Core::hresult IPluginNotification::Unavailable(const string& callsign)
+{
+	return Core::ERROR_NONE;
+}
+
+Core::hresult IPluginNotification::Hibernate(const string& callsign, const Core::hresult timeout)
+{
+	return Core::ERROR_NONE;
+}
+
+Core::hresult IPluginNotification::Suspend(const string& callsign)
+{
+	return Core::ERROR_NONE;
+}
+
+Core::hresult IPluginNotification::Resume(const string& callsign)
+{
+	return Core::ERROR_NONE;
+}
+
+
+void IPluginNotification::AddRef() const
+{
+
+}
+
+uint32_t IPluginNotification::Release() const
+{
+	 return 1;
+}	
+
+void* IPluginNotification::QueryInterface(const uint32_t interfaceNumber)
+{
+	return nullptr;
+}
