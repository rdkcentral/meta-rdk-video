From 260faaf7309f3f2d292352dd5e9c3b57d6374414 Mon Sep 17 00:00:00 2001
From: Arun Madhavan <arun_madhavan@comcast.com>
Date: Tue, 22 Apr 2025 09:04:29 -0400
Subject: [PATCH] RDKEMW-1012: framerate comrpc changes for testing

---
 CMakeLists.txt                            |  10 +
 FrameRate/CMakeLists.txt                  |  85 ++--
 FrameRate/FrameRate.conf.in               |   7 +
 FrameRate/FrameRate.config                |   9 +
 FrameRate/FrameRate.cpp                   | 556 ++++------------------
 FrameRate/FrameRate.h                     | 210 ++++----
 FrameRate/FrameRateImplementation.cpp     | 526 ++++++++++++++++++++
 FrameRate/FrameRateImplementation.h       | 166 +++++++
 Tests/CMakeLists.txt                      |  78 +++
 Tests/entServicesCOMRPC-FrameRateTest.cpp | 209 ++++++++
 10 files changed, 1274 insertions(+), 582 deletions(-)
 create mode 100644 FrameRate/FrameRateImplementation.cpp
 create mode 100644 FrameRate/FrameRateImplementation.h
 create mode 100644 Tests/CMakeLists.txt
 create mode 100644 Tests/entServicesCOMRPC-FrameRateTest.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2962b3c..55e2cd4 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -25,6 +25,16 @@ find_package(WPEFramework)
 # are located in the cmake directory. Include it in the search.
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/")
 
+# This configuration enables generation of Test binaries which can be used to test respective plugins.
+option(TESTBINARIES "Generate plugin specific test binaries" OFF)
+if(TESTBINARIES)
+    message(INFO "Enabling test binaries")
+    if(PLUGIN_FRAMERATE)
+        set(FRAMERATETESTAPP ON CACHE INTERNAL "Enable FrameRate test application")
+    endif()
+    add_subdirectory(Tests)
+endif()
+
 option(COMCAST_CONFIG "Comcast services configuration" ON)
 if(COMCAST_CONFIG)
     include(services.cmake)
diff --git a/FrameRate/CMakeLists.txt b/FrameRate/CMakeLists.txt
index cd7c3aa..76a5753 100644
--- a/FrameRate/CMakeLists.txt
+++ b/FrameRate/CMakeLists.txt
@@ -1,7 +1,7 @@
-# If not stated otherwise in this file or this component's license file the
+# If not stated otherwise in this file or this component's LICENSE file the
 # following copyright and licenses apply:
 #
-# Copyright 2020 RDK Management
+# Copyright 2025 RDK Management
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -17,56 +17,75 @@
 
 set(PLUGIN_NAME FrameRate)
 set(MODULE_NAME ${NAMESPACE}${PLUGIN_NAME})
+set(PLUGIN_IMPLEMENTATION ${MODULE_NAME}Implementation)
 
 set(PLUGIN_FRAMERATE_STARTUPORDER "" CACHE STRING "To configure startup order of FrameRate plugin")
 
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
+
 find_package(${NAMESPACE}Plugins REQUIRED)
+find_package(${NAMESPACE}Definitions REQUIRED)
+find_package(CompileSettingsDebug CONFIG REQUIRED)
+find_library(PROCPS_LIBRARIES NAMES procps)
 
 add_library(${MODULE_NAME} SHARED
-        FrameRate.cpp
-        Module.cpp)
+    FrameRate.cpp
+    Module.cpp)
 
 set_target_properties(${MODULE_NAME} PROPERTIES
-        CXX_STANDARD 11
-        CXX_STANDARD_REQUIRED YES)
+    CXX_STANDARD 11
+    CXX_STANDARD_REQUIRED YES)
+
+target_link_libraries(${MODULE_NAME}
+    PRIVATE
+    CompileSettingsDebug::CompileSettingsDebug
+    ${NAMESPACE}Plugins::${NAMESPACE}Plugins
+    ${NAMESPACE}Definitions::${NAMESPACE}Definitions)
+
+install(TARGETS ${MODULE_NAME}
+    DESTINATION ${CMAKE_INSTALL_PREFIX}/lib/${STORAGE_DIRECTORY}/plugins)
 
-target_compile_definitions(${MODULE_NAME} PRIVATE MODULE_NAME=Plugin_${PLUGIN_NAME})
+add_library(${PLUGIN_IMPLEMENTATION} SHARED
+    FrameRateImplementation.cpp
+    Module.cpp)
 
-if (NOT RDK_SERVICES_TEST)
-    target_compile_options(${MODULE_NAME} PRIVATE -Wno-error)
-endif ()
+include_directories(../helpers)
 
-list(APPEND CMAKE_MODULE_PATH
-        "${CMAKE_CURRENT_SOURCE_DIR}/cmake/")
+set_target_properties(${PLUGIN_IMPLEMENTATION} PROPERTIES
+    CXX_STANDARD 11
+    CXX_STANDARD_REQUIRED YES)
 
-find_package(IARMBus)
-if (IARMBus_FOUND)
-    target_include_directories(${MODULE_NAME} PRIVATE ${IARMBUS_INCLUDE_DIRS})
-    target_link_libraries(${MODULE_NAME} PRIVATE ${NAMESPACE}Plugins::${NAMESPACE}Plugins ${IARMBUS_LIBRARIES})
-else (IARMBus_FOUND)
-    message ("Module IARMBus required.")
-    target_include_directories(${MODULE_NAME} PRIVATE ${IARMBUS_INCLUDE_DIRS})
-    target_link_libraries(${MODULE_NAME} PRIVATE ${NAMESPACE}Plugins::${NAMESPACE}Plugins ${IARMBUS_LIBRARIES})
-endif(IARMBus_FOUND)
+if (RDK_SERVICE_L2_TEST)
+    find_library(TESTMOCKLIB_LIBRARIES NAMES TestMocklib)
+    if (TESTMOCKLIB_LIBRARIES)
+        message ("linking mock libraries ${TESTMOCKLIB_LIBRARIES} library")
+        target_link_libraries(${PLUGIN_IMPLEMENTATION} PRIVATE ${TESTMOCKLIB_LIBRARIES})
+    else (TESTMOCKLIB_LIBRARIES)
+        message ("Require ${TESTMOCKLIB_LIBRARIES} library")
+    endif (TESTMOCKLIB_LIBRARIES)
+endif (RDK_SERVICES_L2_TEST)
+
+if(PROCPS_LIBRARIES)
+    target_link_libraries(${PLUGIN_IMPLEMENTATION} PRIVATE ${PROCPS_LIBRARIES})
+endif(PROCPS_LIBRARIES)
 
 find_package(DS)
 if (DS_FOUND)
-        find_package(IARMBus)
+    find_package(IARMBus)
     add_definitions(-DDS_FOUND)
-    target_include_directories(${MODULE_NAME} PRIVATE ${IARMBUS_INCLUDE_DIRS})
-    target_include_directories(${MODULE_NAME} PRIVATE ${DS_INCLUDE_DIRS})
-    target_link_libraries(${MODULE_NAME} PRIVATE ${NAMESPACE}Plugins::${NAMESPACE}Plugins ${IARMBUS_LIBRARIES} ${DS_LIBRARIES})
+    target_include_directories(${PLUGIN_IMPLEMENTATION} PRIVATE ${IARMBUS_INCLUDE_DIRS})
+    target_include_directories(${PLUGIN_IMPLEMENTATION} PRIVATE ${DS_INCLUDE_DIRS})
+    target_link_libraries(${PLUGIN_IMPLEMENTATION} PRIVATE ${NAMESPACE}Plugins::${NAMESPACE}Plugins ${IARMBUS_LIBRARIES} ${DS_LIBRARIES})
 else (DS_FOUND)
-    target_link_libraries(${MODULE_NAME} PRIVATE ${NAMESPACE}Plugins::${NAMESPACE}Plugins)
+    target_link_libraries(${PLUGIN_IMPLEMENTATION} PRIVATE ${NAMESPACE}Plugins::${NAMESPACE}Plugins)
 endif(DS_FOUND)
 
-target_include_directories(${MODULE_NAME} PRIVATE ../helpers)
-
-set_source_files_properties(FrameRate.cpp PROPERTIES COMPILE_FLAGS "-fexceptions")
+target_link_libraries(${PLUGIN_IMPLEMENTATION}
+    PRIVATE
+    CompileSettingsDebug::CompileSettingsDebug
+    ${NAMESPACE}Plugins::${NAMESPACE}Plugins)
 
-target_link_libraries(${MODULE_NAME} PRIVATE ${NAMESPACE}Plugins::${NAMESPACE}Plugins ${IARMBUS_LIBRARIES} ${DS_LIBRARIES})
-
-install(TARGETS ${MODULE_NAME}
-        DESTINATION lib/${STORAGE_DIRECTORY}/plugins)
+install(TARGETS ${PLUGIN_IMPLEMENTATION}
+    DESTINATION ${CMAKE_INSTALL_PREFIX}/lib/${STORAGE_DIRECTORY}/plugins)
 
 write_config(${PLUGIN_NAME})
diff --git a/FrameRate/FrameRate.conf.in b/FrameRate/FrameRate.conf.in
index fddc798..7395365 100644
--- a/FrameRate/FrameRate.conf.in
+++ b/FrameRate/FrameRate.conf.in
@@ -2,3 +2,10 @@ precondition = ["Platform"]
 callsign = "org.rdk.FrameRate"
 autostart = "false"
 startuporder = "@PLUGIN_FRAMERATE_STARTUPORDER@"
+
+configuration = JSON()
+rootobject = JSON()
+
+rootobject.add("mode", "@PLUGIN_FRAMERATE_MODE@")
+rootobject.add("locator", "lib@PLUGIN_IMPLEMENTATION@.so")
+configuration.add("root", rootobject)
diff --git a/FrameRate/FrameRate.config b/FrameRate/FrameRate.config
index 6108533..0b4257a 100644
--- a/FrameRate/FrameRate.config
+++ b/FrameRate/FrameRate.config
@@ -5,3 +5,12 @@ set (callsign "org.rdk.FrameRate")
 if(PLUGIN_FRAMERATE_STARTUPORDER)
 set (startuporder ${PLUGIN_FRAMERATE_STARTUPORDER})
 endif()
+
+map()
+   key(root)
+   map()
+       kv(mode ${PLUGIN_FRAMERATE_MODE})
+       kv(locator lib${PLUGIN_IMPLEMENTATION}.so)
+   end()
+end()
+ans(configuration)
diff --git a/FrameRate/FrameRate.cpp b/FrameRate/FrameRate.cpp
index 0186120..11d2912 100644
--- a/FrameRate/FrameRate.cpp
+++ b/FrameRate/FrameRate.cpp
@@ -1,512 +1,164 @@
-/**
-* If not stated otherwise in this file or this component's LICENSE
-* file the following copyright and licenses apply:
-*
-* Copyright 2019 RDK Management
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-**/
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2025 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 #include "FrameRate.h"
-#include "host.hpp"
-#include "exception.hpp"
-#include "dsMgr.h"
-
-#include "UtilsJsonRpc.h"
-#include "UtilsIarm.h"
-
-// Methods
-#define METHOD_SET_COLLECTION_FREQUENCY "setCollectionFrequency"
-#define METHOD_START_FPS_COLLECTION "startFpsCollection"
-#define METHOD_STOP_FPS_COLLECTION "stopFpsCollection"
-#define METHOD_UPDATE_FPS_COLLECTION "updateFps"
-#define METHOD_SET_FRAME_MODE "setFrmMode"
-#define METHOD_GET_FRAME_MODE "getFrmMode"
-#define METHOD_GET_DISPLAY_FRAME_RATE "getDisplayFrameRate"
-#define METHOD_SET_DISPLAY_FRAME_RATE "setDisplayFrameRate"
-
-// Events
-#define EVENT_FPS_UPDATE "onFpsEvent"
-#define EVENT_FRAMERATE_PRECHANGE  "onDisplayFrameRateChanging"
-#define EVENT_FRAMERATE_POSTCHANGE    "onDisplayFrameRateChanged"
-
-//Defines
-#define DEFAULT_FPS_COLLECTION_TIME_IN_MILLISECONDS 10000
-#define MINIMUM_FPS_COLLECTION_TIME_IN_MILLISECONDS 100
-#define DEFAULT_MIN_FPS_VALUE 60
-#define DEFAULT_MAX_FPS_VALUE -1
-
-// TODO: remove this
-#define registerMethod(...) for (uint8_t i = 1; GetHandler(i); i++) GetHandler(i)->Register<JsonObject, JsonObject>(__VA_ARGS__)
 
 #define API_VERSION_NUMBER_MAJOR 1
 #define API_VERSION_NUMBER_MINOR 0
-#define API_VERSION_NUMBER_PATCH 5
+#define API_VERSION_NUMBER_PATCH 0
 
 namespace WPEFramework
 {
-    namespace {
-
+    namespace
+    {
         static Plugin::Metadata<Plugin::FrameRate> metadata(
-            // Version (Major, Minor, Patch)
-            API_VERSION_NUMBER_MAJOR, API_VERSION_NUMBER_MINOR, API_VERSION_NUMBER_PATCH,
-            // Preconditions
-            {},
-            // Terminations
-            {},
-            // Controls
-            {}
-        );
+                // Version (Major, Minor, Patch)
+                API_VERSION_NUMBER_MAJOR, API_VERSION_NUMBER_MINOR, API_VERSION_NUMBER_PATCH,
+                // Preconditions
+                {},
+                // Terminations
+                {},
+                // Controls
+                {}
+                );
     }
 
     namespace Plugin
     {
+        /*
+         *Register FrameRate module as wpeframework plugin
+         **/
         SERVICE_REGISTRATION(FrameRate, API_VERSION_NUMBER_MAJOR, API_VERSION_NUMBER_MINOR, API_VERSION_NUMBER_PATCH);
 
-        FrameRate* FrameRate::_instance = nullptr;
-
-        FrameRate::FrameRate()
-        : PluginHost::JSONRPC()
-          , m_fpsCollectionFrequencyInMs(DEFAULT_FPS_COLLECTION_TIME_IN_MILLISECONDS)
-          , m_minFpsValue(DEFAULT_MIN_FPS_VALUE), m_maxFpsValue(DEFAULT_MAX_FPS_VALUE)
-          , m_totalFpsValues(0), m_numberOfFpsUpdates(0), m_fpsCollectionInProgress(false), m_lastFpsValue(-1)
+        FrameRate::FrameRate() : _service(nullptr), _connectionId(0), _FrameRate(nullptr), _FrameRateNotification(this)
         {
-            FrameRate::_instance = this;
-
-            CreateHandler({2});
-            registerMethod(METHOD_SET_COLLECTION_FREQUENCY, &FrameRate::setCollectionFrequencyWrapper, this);
-            registerMethod(METHOD_START_FPS_COLLECTION, &FrameRate::startFpsCollectionWrapper, this);
-            registerMethod(METHOD_STOP_FPS_COLLECTION, &FrameRate::stopFpsCollectionWrapper, this);
-            registerMethod(METHOD_UPDATE_FPS_COLLECTION, &FrameRate::updateFpsWrapper, this);
-            registerMethod(METHOD_SET_FRAME_MODE, &FrameRate::setFrmMode, this);
-            registerMethod(METHOD_GET_FRAME_MODE, &FrameRate::getFrmMode, this);
-            registerMethod(METHOD_GET_DISPLAY_FRAME_RATE, &FrameRate::getDisplayFrameRate, this);
-            registerMethod(METHOD_SET_DISPLAY_FRAME_RATE, &FrameRate::setDisplayFrameRate, this);
-
-            m_reportFpsTimer.connect( std::bind( &FrameRate::onReportFpsTimer, this ) );
+            SYSLOG(Logging::Startup, (_T("FrameRate Constructor")));
         }
 
         FrameRate::~FrameRate()
         {
+            SYSLOG(Logging::Shutdown, (string(_T("FrameRate Destructor"))));
         }
 
-	const string FrameRate::Initialize(PluginHost::IShell * /* service */)
-        {
-		InitializeIARM();
-                return "";
-        }
-
-	void FrameRate::InitializeIARM()
-        {
-            LOGWARN("FrameRate::InitializeIARM");
-	    if(Utils::IARM::init())
-	    {
-
-		    IARM_Result_t res;
-		    IARM_CHECK( IARM_Bus_RegisterEventHandler(IARM_BUS_DSMGR_NAME,IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE, FrameRatePreChange) );
-		    IARM_CHECK( IARM_Bus_RegisterEventHandler(IARM_BUS_DSMGR_NAME,IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE, FrameRatePostChange) );
-	    }
-	}
-
-	void FrameRate::DeinitializeIARM()
-	{
-            if (Utils::IARM::isConnected())
-            {
-                IARM_Result_t res;
-                IARM_CHECK( IARM_Bus_RemoveEventHandler(IARM_BUS_DSMGR_NAME,IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE, FrameRatePreChange) );
-                IARM_CHECK( IARM_Bus_RemoveEventHandler(IARM_BUS_DSMGR_NAME, IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE, FrameRatePostChange) );
-            }
-        }
-
-        void FrameRate::Deinitialize(PluginHost::IShell* /* service */)
-        {
-		DeinitializeIARM();
-    		FrameRate::_instance = nullptr;
-        }
-
-        string FrameRate::Information() const
-        {
-            return (string());
-        }
-
-        uint32_t FrameRate::setCollectionFrequencyWrapper(const JsonObject& parameters, JsonObject& response)
-        {
-            std::lock_guard<std::mutex> guard(m_callMutex);
-
-            LOGINFOMETHOD();
-	    bool retValue = false;
-	    try{
-		    if (parameters.HasLabel("frequency"))
-		    {
-			    int fpsFrequencyInMilliseconds = DEFAULT_FPS_COLLECTION_TIME_IN_MILLISECONDS;
-			    fpsFrequencyInMilliseconds = std::stod(parameters["frequency"].String());
-			    if( fpsFrequencyInMilliseconds >= 100) // make sure min freq is 100 and not less than that.
-			    {
-				    setCollectionFrequency(fpsFrequencyInMilliseconds);
-				    retValue = true;
-			    }
-			    else{
-				    LOGWARN("Minimum FrameRate is 100.");
-				    retValue = false;
-			    }
-		    }
-		    else{
-			     LOGWARN("Please enter valid FrameRate Parameter name.");
-			     retValue = false;
-		    }
-	    }
-	    catch(...){
-		    LOGERR("Please enter valid FrameRate value");
-		    retValue = false;
-	    }
-	    returnResponse(retValue);
-        }
-        
-        uint32_t FrameRate::startFpsCollectionWrapper(const JsonObject& parameters, JsonObject& response)
-        {
-            std::lock_guard<std::mutex> guard(m_callMutex);
-
-            LOGINFOMETHOD();
-
-            returnResponse(startFpsCollection());
-        }
-        
-        uint32_t FrameRate::stopFpsCollectionWrapper(const JsonObject& parameters, JsonObject& response)
+        const string FrameRate::Initialize(PluginHost::IShell* service)
         {
-            std::lock_guard<std::mutex> guard(m_callMutex);
+            string message="";
 
-            LOGINFOMETHOD();
+            ASSERT(nullptr != service);
+            ASSERT(nullptr == _service);
+            ASSERT(nullptr == _FrameRate);
+            ASSERT(0 == _connectionId);
 
-            returnResponse(stopFpsCollection());
-        }
-        
-        uint32_t FrameRate::updateFpsWrapper(const JsonObject& parameters, JsonObject& response)
-        {
-            std::lock_guard<std::mutex> guard(m_callMutex);
+            SYSLOG(Logging::Startup, (_T("FrameRate::Initialize: PID=%u"), getpid()));
 
-            LOGINFOMETHOD();
-            
-            if (!parameters.HasLabel("newFpsValue"))
-            {
-                returnResponse(false);
-            }
-            
-            updateFps(parameters["newFpsValue"].Number());
-
-            returnResponse(true);
-        }
-        
-	uint32_t FrameRate::setFrmMode(const JsonObject& parameters, JsonObject& response)
-        {
-            std::lock_guard<std::mutex> guard(m_callMutex);
-
-            LOGINFOMETHOD();
-            returnIfParamNotFound(parameters, "frmmode");
-
-            string sPortId = parameters["frmmode"].String();
-            int frfmode = 0;
-            try {
-                frfmode = stoi(sPortId);
-            }catch (const device::Exception& err) {
-                LOG_DEVICE_EXCEPTION1(sPortId);
-                returnResponse(false);
-            }
+            _service = service;
+            _service->AddRef();
+            _service->Register(&_FrameRateNotification);
+            _FrameRate = _service->Root<Exchange::IFrameRate>(_connectionId, 5000, _T("FrameRateImplementation"));
 
-            bool success = true;
-            try
+            if (nullptr != _FrameRate)
             {
-                device::VideoDevice &device = device::Host::getInstance().getVideoDevices().at(0);
-                device.setFRFMode(frfmode);
+                // Register for notifications
+                _FrameRate->Register(&_FrameRateNotification);
+                // Invoking Plugin API register to wpeframework
+                Exchange::JFrameRate::Register(*this, _FrameRate);
             }
-            catch (const device::Exception& err)
+            else
             {
-                LOG_DEVICE_EXCEPTION1(sPortId);
-                success = false;
+                SYSLOG(Logging::Startup, (_T("FrameRate::Initialize: Failed to initialise FrameRate plugin")));
+                message = _T("FrameRate plugin could not be initialised");
             }
-            returnResponse(success);
-        }
-
-        uint32_t FrameRate::getFrmMode(const JsonObject& parameters, JsonObject& response)
-        {
-            std::lock_guard<std::mutex> guard(m_callMutex);
 
-            LOGINFOMETHOD();
-
-            int frmmode = dsHDRSTANDARD_NONE;
-            bool success = true;
-            try
-            {
-                device::VideoDevice &device = device::Host::getInstance().getVideoDevices().at(0);
-                device.getFRFMode(&frmmode);
-            }
-            catch(const device::Exception& err)
+            if (0 != message.length())
             {
-                LOG_DEVICE_EXCEPTION0();
-                success = false;
+                Deinitialize(service);
             }
 
-            response["auto-frm-mode"] = frmmode;
-            returnResponse(success);
+            return message;
         }
 
-        uint32_t FrameRate::setDisplayFrameRate(const JsonObject& parameters, JsonObject& response)
+        void FrameRate::Deinitialize(PluginHost::IShell* service)
         {
-            std::lock_guard<std::mutex> guard(m_callMutex);
+            ASSERT(_service == service);
 
-            LOGINFOMETHOD();
-            returnIfParamNotFound(parameters, "framerate");
-
-            string sFramerate = parameters["framerate"].String();
-
-            bool success = true;
-            try
-            {
-                device::VideoDevice &device = device::Host::getInstance().getVideoDevices().at(0);
-                device.setDisplayframerate(sFramerate.c_str());
-            }
-            catch (const device::Exception& err)
-            {
-                LOG_DEVICE_EXCEPTION1(sFramerate);
-                success = false;
-            }
-            returnResponse(success);
-        }
+            SYSLOG(Logging::Shutdown, (string(_T("FrameRate::Deinitialize"))));
 
-        uint32_t FrameRate::getDisplayFrameRate(const JsonObject& parameters, JsonObject& response)
-        {
-            std::lock_guard<std::mutex> guard(m_callMutex);
+            // Make sure the Activated and Deactivated are no longer called before we start cleaning up..
+            _service->Unregister(&_FrameRateNotification);
 
-            LOGINFOMETHOD();
-            char sFramerate[20] ={0};
-            bool success = true;
-            try
-            {
-                device::VideoDevice &device = device::Host::getInstance().getVideoDevices().at(0);
-                device.getCurrentDisframerate(sFramerate);
-            }
-            catch (const device::Exception& err)
+            if (nullptr != _FrameRate)
             {
-                LOG_DEVICE_EXCEPTION1(std::string(sFramerate));
-                success = false;
-            }
+                _FrameRate->Unregister(&_FrameRateNotification);
+                Exchange::JFrameRate::Unregister(*this);
 
-            response["framerate"] = std::string(sFramerate);
-            returnResponse(success);
-        }
+                // Stop processing:
+                RPC::IRemoteConnection* connection = service->RemoteConnection(_connectionId);
+                VARIABLE_IS_NOT_USED uint32_t result = _FrameRate->Release();
 
-        /**
-        * @brief This function is used to get the amount of collection interval per milliseconds.
-        *
-        * @return Integer value of Amount of milliseconds per collection interval .
-        */
-        int FrameRate::getCollectionFrequency()
-        {
-            return m_fpsCollectionFrequencyInMs;
-        }
+                _FrameRate = nullptr;
 
-        /**
-        * @brief This function is used to set the amount of collection interval per milliseconds.
-        *
-        * @param[in] frequencyInMs Amount of milliseconds per collection interval.
-        * @ingroup SERVMGR_ABSFRAMERATE_API
-        */
-        void FrameRate::setCollectionFrequency(int frequencyInMs)
-        {
-            m_fpsCollectionFrequencyInMs = frequencyInMs;
-        }
+                // It should have been the last reference we are releasing,
+                // so it should endup in a DESTRUCTION_SUCCEEDED, if not we
+                // are leaking...
+                ASSERT(result == Core::ERROR_DESTRUCTION_SUCCEEDED);
 
-        /**
-        * @brief This function is used to start the fps collection. Stop the fps timer before
-        * start the fps collection frequency. Fps collection frequency is updated to minimum fps
-        * collection time if the fps collection frequency is less than the minimum fps collection time
-        * and start the fps timer.
-        *
-        * @return true on success else false if there was an error.
-        * @ingroup SERVMGR_ABSFRAMERATE_API
-        */
-        bool FrameRate::startFpsCollection()
-        {
-            if (m_fpsCollectionInProgress)
-            {
-                return false;
-            }
-            if (m_reportFpsTimer.isActive())
-            {
-                m_reportFpsTimer.stop();
-            }
-            m_minFpsValue = DEFAULT_MIN_FPS_VALUE;
-            m_maxFpsValue = DEFAULT_MAX_FPS_VALUE;
-            m_totalFpsValues = 0;
-            m_numberOfFpsUpdates = 0;
-            m_fpsCollectionInProgress = true;
-            int fpsCollectionFrequency = m_fpsCollectionFrequencyInMs;
-            if (fpsCollectionFrequency < MINIMUM_FPS_COLLECTION_TIME_IN_MILLISECONDS)
-            {
-                fpsCollectionFrequency = MINIMUM_FPS_COLLECTION_TIME_IN_MILLISECONDS;
-            }
-            m_reportFpsTimer.start(fpsCollectionFrequency);
-            enableFpsCollection();
-            return true;
-        }
-
-        /**
-        * @brief This function is used to stops the fps collection. Stop the fps timer before disable the
-        * fps collection. If the number of fps updates is greater than 0, update the fps collection by
-        * passing the minimum fps, maximum fps and average fps values  and disable the fps collection.
-        *
-        * @return true on success or false if there was an error.
-        * @ingroup SERVMGR_ABSFRAMERATE_API
-        */
-        bool FrameRate::stopFpsCollection()
-        {
-            if (m_reportFpsTimer.isActive())
-            {
-                m_reportFpsTimer.stop();
-            }
-            if (m_fpsCollectionInProgress)
-            {
-                m_fpsCollectionInProgress = false;
-                int averageFps = -1;
-                int minFps = -1;
-                int maxFps = -1;
-                if (m_numberOfFpsUpdates > 0)
+                // If this was running in a (container) process...
+                if (nullptr != connection)
                 {
-                averageFps = (m_totalFpsValues / m_numberOfFpsUpdates);
-                minFps = m_minFpsValue;
-                maxFps = m_maxFpsValue;
-                fpsCollectionUpdate(averageFps, minFps, maxFps);
-                }
-                disableFpsCollection();
-            }
-            return true;
-        }
-
-        /**
-        * @brief This function is used to update the FPS value.
-        *
-        * @param[in] newFpsValue Latest amount of milliseconds per collection interval.
-        * @ingroup SERVMGR_ABSFRAMERATE_API
-        */
-        void FrameRate::updateFps(int newFpsValue)
-        {
-            if (newFpsValue > m_maxFpsValue)
-            {
-                m_maxFpsValue = newFpsValue;
-            }
-            if (newFpsValue < m_minFpsValue)
-            {
-                m_minFpsValue = newFpsValue;
-            }
-            m_totalFpsValues += newFpsValue;
-            m_numberOfFpsUpdates++;
-            m_lastFpsValue = newFpsValue;
-        }
-        
-        void FrameRate::fpsCollectionUpdate( int averageFps, int minFps, int maxFps )
-        {
-            JsonObject params;
-            params["average"] = averageFps;
-            params["min"] = minFps;
-            params["max"] = maxFps;
-            
-            sendNotify(EVENT_FPS_UPDATE, params);
-        }
-        
-        void FrameRate::onReportFpsTimer()
-        {
-            std::lock_guard<std::mutex> guard(m_callMutex);
-            
-            int averageFps = -1;
-            int minFps = -1;
-            int maxFps = -1;
-            if (m_numberOfFpsUpdates > 0)
-            {
-                averageFps = (m_totalFpsValues / m_numberOfFpsUpdates);
-                minFps = m_minFpsValue;
-                maxFps = m_maxFpsValue;
-            }
-            fpsCollectionUpdate(averageFps, minFps, maxFps);
-            if (m_lastFpsValue >= 0)
-            {
-                // store the last fps value just in case there are no updates
-                m_minFpsValue = m_lastFpsValue;
-                m_maxFpsValue = m_lastFpsValue;
-                m_totalFpsValues = m_lastFpsValue;
-                m_numberOfFpsUpdates = 1;
-            }
-            else
-            {
-                m_minFpsValue = DEFAULT_MIN_FPS_VALUE;
-                m_maxFpsValue = DEFAULT_MAX_FPS_VALUE;
-                m_totalFpsValues = 0;
-                m_numberOfFpsUpdates = 0;
-            }
-        }
-
-	void FrameRate::FrameRatePreChange(const char *owner, IARM_EventId_t eventId, void *data, size_t len)
-        {
-	    char dispFrameRate[20] ={0};
-            if (strcmp(owner, IARM_BUS_DSMGR_NAME) == 0)
-            {
-                switch (eventId) {
-                    case IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE:
-                        IARM_Bus_DSMgr_EventData_t *eventData = (IARM_Bus_DSMgr_EventData_t *)data;
-                        strncpy(dispFrameRate,eventData->data.DisplayFrameRateChange.framerate, sizeof(dispFrameRate));
-                        dispFrameRate[sizeof(dispFrameRate) - 1] = '\0';
-                        break;
+                    // Lets trigger the cleanup sequence for
+                    // out-of-process code. Which will guard
+                    // that unwilling processes, get shot if
+                    // not stopped friendly :-)
+                    try
+                    {
+                        connection->Terminate();
+                        // Log success if needed
+                        LOGWARN("Connection terminated successfully.");
+                    }
+                    catch (const std::exception& e)
+                    {
+                        std::string errorMessage = "Failed to terminate connection: ";
+                        errorMessage += e.what();
+                        LOGWARN("%s",errorMessage.c_str());
+                    }
+
+                    connection->Release();
                 }
             }
 
-            if(FrameRate::_instance)
-            {
-                FrameRate::_instance->frameRatePreChange(dispFrameRate);
-            }
+            _connectionId = 0;
+            _service->Release();
+            _service = nullptr;
+            SYSLOG(Logging::Shutdown, (string(_T("FrameRate de-initialised"))));
         }
 
-        void FrameRate::frameRatePreChange(char *displayFrameRate)
+        string FrameRate::Information() const
         {
-            JsonObject params;
-            params["displayFrameRate"] = std::string(displayFrameRate);
-            sendNotify(EVENT_FRAMERATE_PRECHANGE, params);
+            return ("This FrameRate Plugin facilitates communication between Thunder plugins and the PwrMgr IARM manager");
         }
 
-        void FrameRate::FrameRatePostChange(const char *owner, IARM_EventId_t eventId, void *data, size_t len)
+        void FrameRate::Deactivated(RPC::IRemoteConnection* connection)
         {
-	    char dispFrameRate[20] ={0};
-            if (strcmp(owner, IARM_BUS_DSMGR_NAME) == 0)
-            {
-                switch (eventId) {
-                    case IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE:
-                        IARM_Bus_DSMgr_EventData_t *eventData = (IARM_Bus_DSMgr_EventData_t *)data;
-                        strncpy(dispFrameRate,eventData->data.DisplayFrameRateChange.framerate, sizeof(dispFrameRate));
-                        dispFrameRate[sizeof(dispFrameRate) - 1] = '\0';
-                        break;
-                }
-            }
-
-            if(FrameRate::_instance)
-            {
-                FrameRate::_instance->frameRatePostChange(dispFrameRate);
+            if (connection->Id() == _connectionId) {
+                ASSERT(nullptr != _service);
+                Core::IWorkerPool::Instance().Submit(PluginHost::IShell::Job::Create(_service, PluginHost::IShell::DEACTIVATED, PluginHost::IShell::FAILURE));
             }
         }
-
-        void FrameRate::frameRatePostChange(char *displayFrameRate)
-        {
-            JsonObject params;
-            params["displayFrameRate"] = std::string(displayFrameRate);
-            sendNotify(EVENT_FRAMERATE_POSTCHANGE, params);
-        }
-
-        
     } // namespace Plugin
 } // namespace WPEFramework
diff --git a/FrameRate/FrameRate.h b/FrameRate/FrameRate.h
index fe520e5..5b152c4 100644
--- a/FrameRate/FrameRate.h
+++ b/FrameRate/FrameRate.h
@@ -1,105 +1,121 @@
 /**
-* If not stated otherwise in this file or this component's LICENSE
-* file the following copyright and licenses apply:
-*
-* Copyright 2019 RDK Management
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-**/
+ * If not stated otherwise in this file or this component's LICENSE
+ * file the following copyright and licenses apply:
+ *
+ * Copyright 2025 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ **/
 
 #pragma once
 
-#include <mutex>
-
 #include "Module.h"
-
-#include "tptimer.h"
-
-#include "libIARM.h"
-
-namespace WPEFramework {
-
-    namespace Plugin {
-
-        class FrameRate : public PluginHost::IPlugin, public PluginHost::JSONRPC {
-        private:
-
-            // We do not allow this plugin to be copied !!
-            FrameRate(const FrameRate&) = delete;
-            FrameRate& operator=(const FrameRate&) = delete;
-
-            //Begin methods
-            uint32_t setCollectionFrequencyWrapper(const JsonObject& parameters, JsonObject& response);
-            uint32_t startFpsCollectionWrapper(const JsonObject& parameters, JsonObject& response);
-            uint32_t stopFpsCollectionWrapper(const JsonObject& parameters, JsonObject& response);
-            uint32_t updateFpsWrapper(const JsonObject& parameters, JsonObject& response);
-            uint32_t setFrmMode(const JsonObject& parameters, JsonObject& response);
-	    uint32_t getFrmMode(const JsonObject& parameters, JsonObject& response);
-	    uint32_t getDisplayFrameRate(const JsonObject& parameters, JsonObject& response);
-	    uint32_t setDisplayFrameRate(const JsonObject& parameters, JsonObject& response);
-	    //End methods
-            
-            int getCollectionFrequency();
-            void setCollectionFrequency(int frequencyInMs);
-            bool startFpsCollection();
-            bool stopFpsCollection();
-            void updateFps(int newFpsValue);
-
-            void fpsCollectionUpdate( int averageFps, int minFps, int maxFps );
-            
-            virtual void enableFpsCollection() {}
-            virtual void disableFpsCollection() {}
-            
-            void onReportFpsTimer();
-            void onReportFpsTimerTest();
-
-	    void InitializeIARM();
-            void DeinitializeIARM();
-
-            void frameRatePreChange(char *displayFrameRate);
-            static void FrameRatePreChange(const char *owner, IARM_EventId_t eventId, void *data, size_t len);
-
-            void frameRatePostChange(char *displayFrameRate);
-            static void FrameRatePostChange(const char *owner, IARM_EventId_t eventId, void *data, size_t len);
-
-
-        public:
-            FrameRate();
-            virtual ~FrameRate();
-	    virtual const string Initialize(PluginHost::IShell* service) override;
-            virtual void Deinitialize(PluginHost::IShell* service) override;
-
-            virtual string Information() const override;
-
-            BEGIN_INTERFACE_MAP(FrameRate)
-            INTERFACE_ENTRY(PluginHost::IPlugin)
-            INTERFACE_ENTRY(PluginHost::IDispatcher)
-            END_INTERFACE_MAP
-
-        public:
-            static FrameRate* _instance;
-        private:
-            int m_fpsCollectionFrequencyInMs;
-            int m_minFpsValue;
-            int m_maxFpsValue;
-            int m_totalFpsValues;
-            int m_numberOfFpsUpdates;
-            bool m_fpsCollectionInProgress;
-            //QTimer m_reportFpsTimer;
-            TpTimer m_reportFpsTimer;
-            int m_lastFpsValue;
-            
-            std::mutex m_callMutex;
+#include <interfaces/IFrameRate.h>
+#include <interfaces/json/JFrameRate.h>
+#include <interfaces/json/JsonData_FrameRate.h>
+#include "UtilsLogging.h"
+#include "tracing/Logging.h"
+
+namespace WPEFramework
+{
+    namespace Plugin
+    {
+        class FrameRate : public PluginHost::IPlugin, public PluginHost::JSONRPC
+        {
+            private:
+                class Notification : public RPC::IRemoteConnection::INotification, public Exchange::IFrameRate::INotification
+            {
+                private:
+                    Notification() = delete;
+                    Notification(const Notification&) = delete;
+                    Notification& operator=(const Notification&) = delete;
+
+                public:
+                    explicit Notification(FrameRate* parent)
+                        : _parent(*parent)
+                    {
+                        ASSERT(parent != nullptr);
+                    }
+
+                    virtual ~Notification()
+                    {
+                    }
+
+                    BEGIN_INTERFACE_MAP(Notification)
+                        INTERFACE_ENTRY(Exchange::IFrameRate::INotification)
+                        INTERFACE_ENTRY(RPC::IRemoteConnection::INotification)
+                    END_INTERFACE_MAP
+
+                    void Activated(RPC::IRemoteConnection*) override
+                    {
+                        LOGINFO("FrameRate Notification Activated");
+                    }
+
+                    void Deactivated(RPC::IRemoteConnection *connection) override
+                    {
+                        LOGINFO("FrameRate Notification Deactivated");
+                        _parent.Deactivated(connection);
+                    }
+
+                    void OnFpsEvent( int average, int min, int max ) override
+                    {
+                        LOGINFO("OnFpsEvent: FPS DATA %d %d %d\n", average, min, max);
+                        Exchange::JFrameRate::Event::OnFpsEvent(_parent, average, min, max);
+                    }
+
+                    void OnDisplayFrameRateChanging(const string& displayFrameRate) override
+                    {
+                        LOGINFO("OnDisplayFrameRateChanging: displayFrameRate %s\n", displayFrameRate.c_str());
+                        Exchange::JFrameRate::Event::OnDisplayFrameRateChanging(_parent, displayFrameRate);
+                    }
+
+                    void OnDisplayFrameRateChanged(const string& displayFrameRate) override
+                    {
+                        LOGINFO("OnDisplayFrameRateChanged: displayFrameRate %s\n", displayFrameRate.c_str());
+                        Exchange::JFrameRate::Event::OnDisplayFrameRateChanged(_parent, displayFrameRate);
+                    }
+
+                private:
+                    FrameRate& _parent;
+            };
+
+            public:
+                FrameRate(const FrameRate&) = delete;
+                FrameRate& operator=(const FrameRate&) = delete;
+
+                FrameRate();
+                virtual ~FrameRate();
+
+                BEGIN_INTERFACE_MAP(FrameRate)
+                    INTERFACE_ENTRY(PluginHost::IPlugin)
+                    INTERFACE_ENTRY(PluginHost::IDispatcher)
+                    INTERFACE_AGGREGATE(Exchange::IFrameRate, _FrameRate)
+                END_INTERFACE_MAP
+
+                //  IPlugin methods
+                // -------------------------------------------------------------------------------------------------------
+                const string Initialize(PluginHost::IShell* service) override;
+                void Deinitialize(PluginHost::IShell* service) override;
+                string Information() const override;
+
+            private:
+                void Deactivated(RPC::IRemoteConnection* connection);
+
+            private:
+                PluginHost::IShell* _service{};
+                uint32_t _connectionId{};
+                Exchange::IFrameRate* _FrameRate{};
+                Core::Sink<Notification> _FrameRateNotification;
         };
     } // namespace Plugin
 } // namespace WPEFramework
diff --git a/FrameRate/FrameRateImplementation.cpp b/FrameRate/FrameRateImplementation.cpp
new file mode 100644
index 0000000..6300092
--- /dev/null
+++ b/FrameRate/FrameRateImplementation.cpp
@@ -0,0 +1,526 @@
+/**
+ * If not stated otherwise in this file or this component's LICENSE
+ * file the following copyright and licenses apply:
+ *
+ * Copyright 2025 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ **/
+#include <stdlib.h>
+#include <errno.h>
+#include <string>
+#include <iomanip>
+#include <sys/prctl.h>
+#include <mutex>
+
+#include "FrameRateImplementation.h"
+#include "host.hpp"
+#include "exception.hpp"
+#include "dsMgr.h"
+
+#include "UtilsJsonRpc.h"
+#include "UtilsIarm.h"
+#include "UtilsProcess.h"
+
+//Defines
+#define DEFAULT_FPS_COLLECTION_TIME_IN_MILLISECONDS 10000
+#define MINIMUM_FPS_COLLECTION_TIME_IN_MILLISECONDS 100
+#define DEFAULT_MIN_FPS_VALUE 60
+#define DEFAULT_MAX_FPS_VALUE -1
+
+// TODO: remove this
+#define registerMethod(...) for (uint8_t i = 1; GetHandler(i); i++) GetHandler(i)->Register<JsonObject, JsonObject>(__VA_ARGS__)
+
+#define API_VERSION_NUMBER_MAJOR 1
+#define API_VERSION_NUMBER_MINOR 0
+#define API_VERSION_NUMBER_PATCH 5
+
+namespace WPEFramework
+{
+    namespace Plugin
+    {
+        static void _frameEventHandler(const char *owner, IARM_EventId_t eventId, void *data, size_t len);
+
+        SERVICE_REGISTRATION(FrameRateImplementation, 1, 0);
+
+        FrameRateImplementation* FrameRateImplementation::_instance = nullptr;
+
+        FrameRateImplementation::FrameRateImplementation()
+        {
+            FrameRateImplementation::_instance = this;
+            InitializeIARM();
+        }
+
+        FrameRateImplementation::~FrameRateImplementation()
+        {
+            DeinitializeIARM();
+        }
+
+        void FrameRateImplementation::InitializeIARM()
+        {
+            LOGWARN("FrameRateImplementation::InitializeIARM");
+            if (Utils::IARM::init())
+            {
+                IARM_Result_t res;
+                IARM_CHECK( IARM_Bus_RegisterEventHandler(IARM_BUS_DSMGR_NAME, IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE, _frameEventHandler));
+                IARM_CHECK( IARM_Bus_RegisterEventHandler(IARM_BUS_DSMGR_NAME, IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE, _frameEventHandler));
+            }
+        }
+
+        void FrameRateImplementation::DeinitializeIARM()
+        {
+            if (Utils::IARM::isConnected())
+            {
+                IARM_Result_t res;
+                IARM_CHECK( IARM_Bus_RemoveEventHandler(IARM_BUS_DSMGR_NAME, IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE, _frameEventHandler));
+                IARM_CHECK( IARM_Bus_RemoveEventHandler(IARM_BUS_DSMGR_NAME, IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE, _frameEventHandler));
+            }
+        }
+
+        void FrameRateImplementation::dispatchOnDisplayFrameRateChangingEvent(const string& displayFrameRate)
+        {
+            std::list<Exchange::IFrameRate::INotification*>::const_iterator index(_framerateNotification.begin());
+            while (index != _framerateNotification.end())
+            {
+                (*index)->OnDisplayFrameRateChanging(displayFrameRate);
+                ++index;
+            }
+        }
+
+        void FrameRateImplementation::dispatchOnDisplayFrameRateChangedEvent(const string& displayFrameRate)
+        {
+            std::list<Exchange::IFrameRate::INotification*>::const_iterator index(_framerateNotification.begin());
+            while (index != _framerateNotification.end())
+            {
+                (*index)->OnDisplayFrameRateChanged(displayFrameRate);
+                ++index;
+            }
+        }
+
+        void FrameRateImplementation::Dispatch(Event event, const JsonValue params)
+        {
+            _adminLock.Lock();
+            switch (event)
+            {
+                case  DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE:
+                    dispatchOnDisplayFrameRateChangingEvent(params.String());
+                    break;
+                case  DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE:
+                    dispatchOnDisplayFrameRateChangedEvent(params.String());
+                    break;
+            }
+            _adminLock.Unlock();
+        }
+
+        void _frameEventHandler(const char *owner, IARM_EventId_t eventId, void *data, size_t len)
+        {
+            switch (eventId)
+            {
+                case  IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE:
+                    {
+                        char dispFrameRate[20] ={0};
+                        IARM_Bus_DSMgr_EventData_t *eventData = (IARM_Bus_DSMgr_EventData_t *)data;
+                        strncpy(dispFrameRate,eventData->data.DisplayFrameRateChange.framerate, sizeof(dispFrameRate));
+                        dispFrameRate[sizeof(dispFrameRate) - 1] = '\0';
+
+                        Core::IWorkerPool::Instance().Submit(FrameRateImplementation::Job::Create(FrameRateImplementation::_instance,
+                                    FrameRateImplementation::DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE,
+                                    dispFrameRate));
+
+                        LOGINFO("IARM Event triggered for Display framerate prechange: %s", dispFrameRate);
+                    }
+                    break;
+                case  IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE:
+                    {
+                        char dispFrameRate[20] ={0};
+                        IARM_Bus_DSMgr_EventData_t *eventData = (IARM_Bus_DSMgr_EventData_t *)data;
+                        strncpy(dispFrameRate,eventData->data.DisplayFrameRateChange.framerate, sizeof(dispFrameRate));
+                        dispFrameRate[sizeof(dispFrameRate) - 1] = '\0';
+                        Core::IWorkerPool::Instance().Submit(FrameRateImplementation::Job::Create(FrameRateImplementation::_instance,
+                                    FrameRateImplementation::DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE,
+                                    dispFrameRate));
+
+                        LOGINFO("IARM Event triggered for Display framerate postchange: %s", dispFrameRate);
+                    }
+                    break;
+            }
+        }
+
+        uint32_t FrameRateImplementation::Register(Exchange::IFrameRate::INotification *notification)
+        {
+            ASSERT (nullptr != notification);
+            _adminLock.Lock();
+
+            // Make sure we can't register the same notification callback multiple times
+            if (std::find(_framerateNotification.begin(), _framerateNotification.end(), notification) == _framerateNotification.end())
+            {
+                _framerateNotification.push_back(notification);
+                notification->AddRef();
+            }
+            else
+            {
+                LOGERR("same notification is registered already");
+            }
+
+            _adminLock.Unlock();
+
+            return Core::ERROR_NONE;
+        }
+
+        uint32_t FrameRateImplementation::Unregister(Exchange::IFrameRate::INotification *notification)
+        {
+            uint32_t status = Core::ERROR_GENERAL;
+
+            ASSERT (nullptr != notification);
+
+            _adminLock.Lock();
+
+            // we just unregister one notification once
+            auto itr = std::find(_framerateNotification.begin(), _framerateNotification.end(), notification);
+            if (itr != _framerateNotification.end())
+            {
+                (*itr)->Release();
+                _framerateNotification.erase(itr);
+                status = Core::ERROR_NONE;
+            }
+            else
+            {
+                LOGERR("notification not found");
+            }
+
+            _adminLock.Unlock();
+
+            return status;
+        }
+
+        uint32_t FrameRateImplementation::SetCollectionFrequency(int frequency, bool& success)
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+            LOGINFO();
+
+            bool retValue = false;
+            try
+            {
+                if (frequency >= 0)
+                {
+                    int fpsFrequencyInMilliseconds = DEFAULT_FPS_COLLECTION_TIME_IN_MILLISECONDS;
+                    fpsFrequencyInMilliseconds = frequency;
+                    if (fpsFrequencyInMilliseconds >= 100) // make sure min freq is 100 and not less than that.
+                    {
+                        m_fpsCollectionFrequencyInMs = fpsFrequencyInMilliseconds;
+                        retValue = true;
+                    }
+                    else
+                    {
+                        LOGWARN("Minimum FrameRate is 100.");
+                        retValue = false;
+                    }
+                }
+                else
+                {
+                    LOGWARN("Please enter valid FrameRate Parameter name.");
+                    retValue = false;
+                }
+            }
+            catch (...)
+            {
+                LOGERR("Please enter valid FrameRate value");
+                retValue = false;
+            }
+            success = retValue;
+            return Core::ERROR_GENERAL;
+        }
+
+        uint32_t FrameRateImplementation::StartFpsCollection(bool& success)
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+            LOGINFO();
+
+            if (m_fpsCollectionInProgress)
+            {
+                success = false;
+            }
+            if (m_reportFpsTimer.isActive())
+            {
+                m_reportFpsTimer.stop();
+            }
+
+            m_minFpsValue = DEFAULT_MIN_FPS_VALUE;
+            m_maxFpsValue = DEFAULT_MAX_FPS_VALUE;
+            m_totalFpsValues = 0;
+            m_numberOfFpsUpdates = 0;
+            m_fpsCollectionInProgress = true;
+            int fpsCollectionFrequency = m_fpsCollectionFrequencyInMs;
+
+            if (fpsCollectionFrequency < MINIMUM_FPS_COLLECTION_TIME_IN_MILLISECONDS)
+            {
+                fpsCollectionFrequency = MINIMUM_FPS_COLLECTION_TIME_IN_MILLISECONDS;
+            }
+            m_reportFpsTimer.start(fpsCollectionFrequency);
+            enableFpsCollection();
+
+            success = true;
+            return Core::ERROR_GENERAL;
+        }
+
+        uint32_t FrameRateImplementation::StopFpsCollection(bool& success)
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+
+            LOGINFO();
+
+            if (m_reportFpsTimer.isActive())
+            {
+                m_reportFpsTimer.stop();
+            }
+            if (m_fpsCollectionInProgress)
+            {
+                m_fpsCollectionInProgress = false;
+                int averageFps = -1;
+                int minFps = -1;
+                int maxFps = -1;
+                if (m_numberOfFpsUpdates > 0)
+                {
+                    averageFps = (m_totalFpsValues / m_numberOfFpsUpdates);
+                    minFps = m_minFpsValue;
+                    maxFps = m_maxFpsValue;
+                    fpsCollectionUpdate(averageFps, minFps, maxFps);
+                }
+                disableFpsCollection();
+            }
+            success = true;
+            return Core::ERROR_GENERAL;
+        }
+
+        uint32_t FrameRateImplementation::UpdateFps(int newFpsValue, bool& success)
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+
+            LOGINFO();
+
+            if (newFpsValue > m_maxFpsValue)
+            {
+                m_maxFpsValue = newFpsValue;
+            }
+            if (newFpsValue < m_minFpsValue)
+            {
+                m_minFpsValue = newFpsValue;
+            }
+            m_totalFpsValues += newFpsValue;
+            m_numberOfFpsUpdates++;
+            m_lastFpsValue = newFpsValue;
+
+            success = true;
+            return Core::ERROR_GENERAL;
+        }
+
+        uint32_t FrameRateImplementation::SetFrmMode(int frmmode, bool& success)
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+
+            LOGINFO();
+            int frfmode = 0;
+            try
+            {
+                frfmode = frmmode;
+            }
+            catch (const device::Exception& err)
+            {
+                success = false;
+                return Core::ERROR_GENERAL;
+            }
+            success = true;
+
+            try
+            {
+                device::VideoDevice &device = device::Host::getInstance().getVideoDevices().at(0);
+                device.setFRFMode(frfmode);
+            }
+            catch (const device::Exception& err)
+            {
+                //LOG_DEVICE_EXCEPTION1(sPortId);
+                success = false;
+            }
+            return Core::ERROR_GENERAL;
+        }
+
+        uint32_t FrameRateImplementation::GetFrmMode(int &frmmode, bool& success)
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+
+            LOGINFO();
+            success = true;
+            try
+            {
+                device::VideoDevice &device = device::Host::getInstance().getVideoDevices().at(0);
+                device.getFRFMode(&frmmode);
+            }
+            catch(const device::Exception& err)
+            {
+                //LOG_DEVICE_EXCEPTION0();
+                success = false;
+            }
+            return Core::ERROR_GENERAL;
+        }
+
+        uint32_t FrameRateImplementation::SetDisplayFrameRate(const string& framerate, bool& success)
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+
+            LOGINFO();
+
+            string sFramerate = framerate;
+
+            success = true;
+            try
+            {
+                device::VideoDevice &device = device::Host::getInstance().getVideoDevices().at(0);
+                device.setDisplayframerate(sFramerate.c_str());
+            }
+            catch (const device::Exception& err)
+            {
+                //LOG_DEVICE_EXCEPTION1(sFramerate);
+                success = false;
+            }
+            return Core::ERROR_GENERAL;
+        }
+
+        uint32_t FrameRateImplementation::GetDisplayFrameRate(string& framerate, bool& success)
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+
+            LOGINFO();
+            char sFramerate[20] ={0};
+            success = true;
+            try
+            {
+                device::VideoDevice &device = device::Host::getInstance().getVideoDevices().at(0);
+                device.getCurrentDisframerate(sFramerate);
+            }
+            catch (const device::Exception& err)
+            {
+                //LOG_DEVICE_EXCEPTION1(std::string(sFramerate));
+                success = false;
+            }
+
+            framerate = std::string(sFramerate);
+            return Core::ERROR_GENERAL;
+        }
+
+        /**
+         * @brief This function is used to get the amount of collection interval per milliseconds.
+         *
+         * @return Integer value of Amount of milliseconds per collection interval .
+         */
+        int FrameRateImplementation::getCollectionFrequency()
+        {
+            return m_fpsCollectionFrequencyInMs;
+        }
+
+        void FrameRateImplementation::fpsCollectionUpdate( int averageFps, int minFps, int maxFps)
+        {
+            JsonObject params;
+            params["average"] = averageFps;
+            params["min"] = minFps;
+            params["max"] = maxFps;
+
+            //sendNotify(EVENT_FPS_UPDATE, params);
+        }
+
+        void FrameRateImplementation::onReportFpsTimer()
+        {
+            std::lock_guard<std::mutex> guard(m_callMutex);
+
+            int averageFps = -1;
+            int minFps = -1;
+            int maxFps = -1;
+            if (m_numberOfFpsUpdates > 0)
+            {
+                averageFps = (m_totalFpsValues / m_numberOfFpsUpdates);
+                minFps = m_minFpsValue;
+                maxFps = m_maxFpsValue;
+            }
+            fpsCollectionUpdate(averageFps, minFps, maxFps);
+            if (m_lastFpsValue >= 0)
+            {
+                // store the last fps value just in case there are no updates
+                m_minFpsValue = m_lastFpsValue;
+                m_maxFpsValue = m_lastFpsValue;
+                m_totalFpsValues = m_lastFpsValue;
+                m_numberOfFpsUpdates = 1;
+            }
+            else
+            {
+                m_minFpsValue = DEFAULT_MIN_FPS_VALUE;
+                m_maxFpsValue = DEFAULT_MAX_FPS_VALUE;
+                m_totalFpsValues = 0;
+                m_numberOfFpsUpdates = 0;
+            }
+        }
+
+        void FrameRateImplementation::FrameRatePreChange(const char *owner, IARM_EventId_t eventId, void *data, size_t len)
+        {
+            char dispFrameRate[20] ={0};
+            if (strcmp(owner, IARM_BUS_DSMGR_NAME) == 0)
+            {
+                switch (eventId) {
+                    case IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE:
+                        IARM_Bus_DSMgr_EventData_t *eventData = (IARM_Bus_DSMgr_EventData_t *)data;
+                        strncpy(dispFrameRate,eventData->data.DisplayFrameRateChange.framerate, sizeof(dispFrameRate));
+                        dispFrameRate[sizeof(dispFrameRate) - 1] = '\0';
+                        break;
+                }
+            }
+
+            if (FrameRateImplementation::_instance)
+            {
+                FrameRateImplementation::_instance->frameRatePreChange(dispFrameRate);
+            }
+        }
+
+        void FrameRateImplementation::frameRatePreChange(char *displayFrameRate)
+        {
+            string status;
+            status = std::string(displayFrameRate);
+            //sendNotify(EVENT_FRAMERATE_PRECHANGE, status);
+        }
+
+        void FrameRateImplementation::FrameRatePostChange(const char *owner, IARM_EventId_t eventId, void *data, size_t len)
+        {
+            char dispFrameRate[20] ={0};
+            if (strcmp(owner, IARM_BUS_DSMGR_NAME) == 0)
+            {
+                switch (eventId)
+                {
+                    case IARM_BUS_DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE:
+                        IARM_Bus_DSMgr_EventData_t *eventData = (IARM_Bus_DSMgr_EventData_t *)data;
+                        strncpy(dispFrameRate,eventData->data.DisplayFrameRateChange.framerate, sizeof(dispFrameRate));
+                        dispFrameRate[sizeof(dispFrameRate) - 1] = '\0';
+                        break;
+                }
+            }
+
+            if (FrameRateImplementation::_instance)
+            {
+                FrameRateImplementation::_instance->frameRatePostChange(dispFrameRate);
+            }
+        }
+
+        void FrameRateImplementation::frameRatePostChange(char *displayFrameRate)
+        {
+            string status;
+            status = std::string(displayFrameRate);
+            //sendNotify(EVENT_FRAMERATE_POSTCHANGE, status);
+        }
+    } // namespace Plugin
+} // namespace WPEFramework
diff --git a/FrameRate/FrameRateImplementation.h b/FrameRate/FrameRateImplementation.h
new file mode 100644
index 0000000..f236c2d
--- /dev/null
+++ b/FrameRate/FrameRateImplementation.h
@@ -0,0 +1,166 @@
+/**
+ * If not stated otherwise in this file or this component's LICENSE
+ * file the following copyright and licenses apply:
+ *
+ * Copyright 2025 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ **/
+
+#pragma once
+
+#include <mutex>
+
+#include "Module.h"
+#include <interfaces/Ids.h>
+#include <interfaces/IFrameRate.h>
+#include <com/com.h>
+#include <core/core.h>
+#include <plugins/plugins.h>
+
+#include "tptimer.h"
+#include "libIARM.h"
+
+#include "tracing/Logging.h"
+
+#include <vector>
+#include <boost/variant.hpp>
+
+namespace WPEFramework {
+    namespace Plugin {
+        class FrameRateImplementation : public Exchange::IFrameRate {
+            public:
+                // We do not allow this plugin to be copied !!
+                FrameRateImplementation();
+                ~FrameRateImplementation() override;
+
+                static FrameRateImplementation* instance(FrameRateImplementation *FrameRateImpl = nullptr);
+
+                // We do not allow this plugin to be copied !!
+                FrameRateImplementation(const FrameRateImplementation&) = delete;
+                FrameRateImplementation& operator=(const FrameRateImplementation&) = delete;
+
+                BEGIN_INTERFACE_MAP(FrameRateImplementation)
+                    INTERFACE_ENTRY(Exchange::IFrameRate)
+                END_INTERFACE_MAP
+
+            public:
+                enum Event {
+                    //ON_FPS_EVENT,
+                    DSMGR_EVENT_DISPLAY_FRAMRATE_PRECHANGE,
+                    DSMGR_EVENT_DISPLAY_FRAMRATE_POSTCHANGE
+                };
+                class EXTERNAL Job : public Core::IDispatch {
+                    protected:
+                        Job(FrameRateImplementation* FrameRateImplementation, Event event, JsonValue &params)
+                            : _framerateImplementation(FrameRateImplementation)
+                              , _event(event)
+                              , _params(params) {
+                                  if (_framerateImplementation != nullptr) {
+                                      _framerateImplementation->AddRef();
+                                  }
+                              }
+
+                    public:
+                        Job() = delete;
+                        Job(const Job&) = delete;
+                        Job& operator=(const Job&) = delete;
+                        ~Job() {
+                            if (_framerateImplementation != nullptr) {
+                                _framerateImplementation->Release();
+                            }
+                        }
+
+                    public:
+                        static Core::ProxyType<Core::IDispatch> Create(FrameRateImplementation* framerateImplementation, Event event, JsonValue params) {
+#ifndef USE_THUNDER_R4
+                            return (Core::proxy_cast<Core::IDispatch>(Core::ProxyType<Job>::Create(framerateImplementation, event, params)));
+#else
+                            return (Core::ProxyType<Core::IDispatch>(Core::ProxyType<Job>::Create(framerateImplementation, event, params)));
+#endif
+                        }
+
+                        virtual void Dispatch() {
+                            _framerateImplementation->Dispatch(_event, _params);
+                        }
+
+                    private:
+                        FrameRateImplementation *_framerateImplementation;
+                        const Event _event;
+                        JsonValue _params;
+                };
+            public:
+                virtual uint32_t Register(Exchange::IFrameRate::INotification *notification ) override;
+                virtual uint32_t Unregister(Exchange::IFrameRate::INotification *notification ) override;
+
+                //Begin methods
+                uint32_t GetDisplayFrameRate(string& framerate, bool& success) override;
+                uint32_t GetFrmMode(int &frmmode, bool& success) override;
+                uint32_t SetCollectionFrequency(int frequency, bool& success) override;
+                uint32_t SetDisplayFrameRate(const string& framerate, bool& success) override;
+                uint32_t SetFrmMode(int frmmode, bool& success) override;
+                uint32_t StartFpsCollection(bool& success)override;
+                uint32_t StopFpsCollection(bool& success) override;
+                uint32_t UpdateFps(int newFpsValue, bool& success) override;
+                //End methods
+
+                int getCollectionFrequency();
+                void fpsCollectionUpdate(int averageFps, int minFps, int maxFps);
+
+                virtual void enableFpsCollection() {}
+                virtual void disableFpsCollection() {}
+
+                void onReportFpsTimer();
+                void onReportFpsTimerTest();
+
+                void InitializeIARM();
+                void DeinitializeIARM();
+
+                void frameRatePreChange(char *displayFrameRate);
+                static void FrameRatePreChange(const char *owner, IARM_EventId_t eventId, void *data, size_t len);
+
+                void frameRatePostChange(char *displayFrameRate);
+                static void FrameRatePostChange(const char *owner, IARM_EventId_t eventId, void *data, size_t len);
+
+                static FrameRateImplementation* _instance;
+
+            private:
+                std::shared_ptr<WPEFramework::JSONRPC::LinkType<WPEFramework::Core::JSON::IElement>> m_systemServiceConnection;
+
+                mutable Core::CriticalSection _adminLock;
+                Core::ProxyType<RPC::InvokeServerType<1, 0, 4>> _engine;
+                Core::ProxyType<RPC::CommunicatorClient> _communicatorClient;
+                PluginHost::IShell* _service;
+                std::list<Exchange::IFrameRate::INotification*> _framerateNotification;
+
+                void dispatchOnFpsEvent(int average, int min, int max);
+                void dispatchOnDisplayFrameRateChangingEvent(const string& displayFrameRate);
+                void dispatchOnDisplayFrameRateChangedEvent(const string& displayFrameRate);
+                void Dispatch(Event event, const JsonValue params);
+
+            private:
+                int m_fpsCollectionFrequencyInMs;
+                int m_minFpsValue;
+                int m_maxFpsValue;
+                int m_totalFpsValues;
+                int m_numberOfFpsUpdates;
+                bool m_fpsCollectionInProgress;
+                TpTimer m_reportFpsTimer;
+                int m_lastFpsValue;
+
+                std::mutex m_callMutex;
+
+                friend class Job;
+        };
+    } // namespace Plugin
+} // namespace WPEFramework
diff --git a/Tests/CMakeLists.txt b/Tests/CMakeLists.txt
new file mode 100644
index 0000000..787424b
--- /dev/null
+++ b/Tests/CMakeLists.txt
@@ -0,0 +1,78 @@
+# If not stated otherwise in this file or this component's LICENSE file the
+# following copyright and licenses apply:
+#
+# Copyright 2025 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.3)
+
+set(PROJECT_NAME "ENTSRVICECOMRPCTestClients")
+set(DESCRIPTION "EntServices COMRPC Client to test the COMRPC implementation.")
+set(DEFAULT_BUILD_TYPE "Release")
+
+project(${PROJECT_NAME} VERSION 1.0.0 LANGUAGES CXX)
+set(CMAKE_CXX_STANDARD 14)
+set(CMAKE_CXX_STANDARD_REQUIRED YES)
+
+set(TESTBINPREFIX "ComRPCPlugin")
+set(MODULE_NAME ${TESTBINPREFIX})
+
+# Include common directories and libraries
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(WPEFRAMEWORKCORE REQUIRED WPEFrameworkCore)
+pkg_check_modules(WPEFRAMEWORKWEBSOCKET REQUIRED WPEFrameworkWebSocket)
+pkg_check_modules(WPEFRAMEWORKDEFINITIONS REQUIRED WPEFrameworkDefinitions)
+pkg_check_modules(WPEFRAMEWORKPLUGINS REQUIRED WPEFrameworkPlugins)
+
+set(COMMON_INCLUDE_DIRS
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${WPEFRAMEWORKCORE_INCLUDE_DIRS}
+    ${WPEFRAMEWORKWEBSOCKET_INCLUDE_DIRS}
+    ${WPEFRAMEWORKDEFINITIONS_INCLUDE_DIRS}
+    ${WPEFRAMEWORKPLUGINS_INCLUDE_DIRS}
+    )
+
+set(COMMON_LIBRARIES
+    ${WPEFRAMEWORKCORE_LIBRARIES}
+    ${WPEFRAMEWORKWEBSOCKET_LIBRARIES}
+    ${WPEFRAMEWORKDEFINITIONS_LIBRARIES}
+    ${WPEFRAMEWORKPLUGINS_LIBRARIES}
+    )
+
+message(STATUS "Common include directories: ${COMMON_INCLUDE_DIRS}")
+message(STATUS "Common libraries: ${COMMON_LIBRARIES}")
+
+include(GNUInstallDirs)
+
+# List to hold dynamically added targets
+set(TEST_TARGETS)
+
+if (FRAMERATETESTAPP)
+    message(STATUS "Framerate test application is enabled.")
+    set(FRAMERATE_EXECUTABLE_NAME "${TESTBINPREFIX}FrameRateTest")
+    add_executable(${FRAMERATE_EXECUTABLE_NAME} entServicesCOMRPC-FrameRateTest.cpp)
+    target_compile_definitions(${FRAMERATE_EXECUTABLE_NAME} PUBLIC MODULE_NAME=${FRAMERATE_EXECUTABLE_NAME})
+    target_include_directories(${FRAMERATE_EXECUTABLE_NAME} PRIVATE ${COMMON_INCLUDE_DIRS})
+    target_link_libraries(${FRAMERATE_EXECUTABLE_NAME} PRIVATE ${COMMON_LIBRARIES})
+    list(APPEND TEST_TARGETS ${FRAMERATE_EXECUTABLE_NAME})
+else()
+    message(STATUS "Framerate test application is disabled.")
+endif()
+
+# Install dynamically added targets
+if (TEST_TARGETS)
+    install(TARGETS ${TEST_TARGETS} RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
+else()
+    message(STATUS "No test applications enabled for installation.")
+endif()
diff --git a/Tests/entServicesCOMRPC-FrameRateTest.cpp b/Tests/entServicesCOMRPC-FrameRateTest.cpp
new file mode 100644
index 0000000..fa246d5
--- /dev/null
+++ b/Tests/entServicesCOMRPC-FrameRateTest.cpp
@@ -0,0 +1,209 @@
+/**
+ * If not stated otherwise in this file or this component's LICENSE
+ * file the following copyright and licenses apply:
+ *
+ * Copyright 2025 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ **/
+
+#ifndef MODULE_NAME
+#define MODULE_NAME COMRPCTestApp
+#endif
+
+#include <chrono>
+#include <string>
+#include <iostream>
+#include <mutex>
+#include <csignal>
+#include <WPEFramework/com/com.h>
+#include <WPEFramework/core/core.h>
+#include "WPEFramework/interfaces/IFrameRate.h"
+
+/************************************ Wrapper for Logging *************************************/
+class Logger {
+public:
+    explicit Logger(const std::string& binaryName) : _binaryName(binaryName) {}
+
+    void Log(const std::string& message) const {
+        std::lock_guard<std::mutex> lock(_mutex);
+        std::cout << "[" << _binaryName << "] " << message << std::endl;
+    }
+
+    void Error(const std::string& message) const {
+        std::lock_guard<std::mutex> lock(_mutex);
+        std::cerr << "[" << _binaryName << "] " << message << std::endl;
+    }
+
+private:
+    std::string _binaryName;
+    mutable std::mutex _mutex;
+};
+
+/********************************* Test FrameRate COMRPC Impl **********************************/
+
+using namespace WPEFramework;
+
+// RAII Wrapper for IFrameRate
+class FrameRateProxy {
+public:
+    explicit FrameRateProxy(Exchange::IFrameRate* frameRate, const Logger& logger)
+        : _frameRate(frameRate), _logger(logger) {}
+    ~FrameRateProxy() {
+        if (_frameRate != nullptr) {
+            _logger.Log("Releasing FrameRate proxy...");
+            _frameRate->Release();
+        }
+    }
+
+    Exchange::IFrameRate* operator->() const { return _frameRate; }
+    Exchange::IFrameRate* Get() const { return _frameRate; }
+
+private:
+    Exchange::IFrameRate* _frameRate;
+    const Logger& _logger;
+};
+
+/********************************* Test All IFrameRate Events **********************************/
+class FrameRateEventHandler : public Exchange::IFrameRate::INotification {
+public:
+    explicit FrameRateEventHandler(const Logger& logger) : _logger(logger) {}
+
+    void OnFpsEvent(int average, int min, int max) override {
+        _logger.Log("FPS Event - Average: " + std::to_string(average) +
+                    ", Min: " + std::to_string(min) +
+                    ", Max: " + std::to_string(max));
+    }
+
+    void OnDisplayFrameRateChanging(const std::string& displayFrameRate) override {
+        _logger.Log("Display Frame Rate Changing to: " + displayFrameRate);
+    }
+
+    void OnDisplayFrameRateChanged(const std::string& displayFrameRate) override {
+        _logger.Log("Display Frame Rate Changed to: " + displayFrameRate);
+    }
+
+    void AddRef() const override {}
+    uint32_t Release() const override { return 0; }
+
+    BEGIN_INTERFACE_MAP(FrameRateEventHandler)
+        INTERFACE_ENTRY(Exchange::IFrameRate::INotification)
+    END_INTERFACE_MAP
+
+private:
+    const Logger& _logger;
+};
+
+/*************************************** Helper Functions ***************************************/
+bool HandleResult(const Logger& logger, const std::string& methodName, uint32_t result, bool success) {
+    if (result == Core::ERROR_NONE && success) {
+        logger.Log(methodName + " succeeded.");
+        return true;
+    } else {
+        logger.Error(methodName + " failed with error: " + std::to_string(result));
+        return false;
+    }
+}
+
+void TestFrameRateMethods(FrameRateProxy& frameRate, const Logger& logger) {
+    bool success = false;
+
+    // Test GetDisplayFrameRate
+    std::string displayFrameRate;
+    HandleResult(logger, "GetDisplayFrameRate", frameRate->GetDisplayFrameRate(displayFrameRate, success), success);
+
+    // Test GetFrmMode
+    int frmmode = 0;
+    HandleResult(logger, "GetFrmMode", frameRate->GetFrmMode(frmmode, success), success);
+
+    // Test SetCollectionFrequency
+    int frequency = 30;
+    HandleResult(logger, "SetCollectionFrequency", frameRate->SetCollectionFrequency(frequency, success), success);
+
+    // Test SetDisplayFrameRate
+    const char* newDisplayFrameRate = "60";
+    HandleResult(logger, "SetDisplayFrameRate", frameRate->SetDisplayFrameRate(newDisplayFrameRate, success), success);
+
+    // Test SetFrmMode
+    int autoFrameRate = 1;
+    HandleResult(logger, "SetFrmMode", frameRate->SetFrmMode(autoFrameRate, success), success);
+
+    // Test StartFpsCollection
+    HandleResult(logger, "StartFpsCollection", frameRate->StartFpsCollection(success), success);
+
+    // Test StopFpsCollection
+    HandleResult(logger, "StopFpsCollection", frameRate->StopFpsCollection(success), success);
+
+    // Test UpdateFps
+    int fps = 60;
+    HandleResult(logger, "UpdateFps", frameRate->UpdateFps(fps, success), success);
+}
+
+/*************************************** Signal Handling ****************************************/
+volatile bool keepRunning = true;
+
+void SignalHandler(int signal) {
+    keepRunning = false;
+}
+
+/******************************************** Main *********************************************/
+int main(int argc, char* argv[]) {
+    /*************************************** Logger Setup ****************************************/
+    const std::string binaryName = (argc > 0) ? argv[0] : "entServicesCOMRPC-FrameRateTest";
+    Logger logger(binaryName);
+
+    /******************************************* Init *******************************************/
+    const char* thunderAccess = std::getenv("THUNDER_ACCESS");
+    std::string envThunderAccess = (thunderAccess != nullptr) ? thunderAccess : "/tmp/communicator";
+    logger.Log("Using THUNDER_ACCESS: " + envThunderAccess);
+
+    Core::SystemInfo::SetEnvironment(_T("THUNDER_ACCESS"), envThunderAccess.c_str());
+    Core::ProxyType<RPC::CommunicatorClient> client = Core::ProxyType<RPC::CommunicatorClient>::Create(
+        Core::NodeId(envThunderAccess.c_str()));
+
+    if (!client.IsValid()) {
+        logger.Error("Failed to create COMRPC client.");
+        return 1;
+    }
+
+    /************************************* Plugin Connector **************************************/
+    Exchange::IFrameRate* rawFrameRate = client->Open<Exchange::IFrameRate>(_T("FrameRate"));
+    if (rawFrameRate == nullptr) {
+        logger.Error("Failed to connect to FrameRate plugin.");
+        return 1;
+    }
+    logger.Log("Connected to FrameRate plugin.");
+
+    // Use RAII wrapper for FrameRate proxy
+    FrameRateProxy frameRate(rawFrameRate, logger);
+
+    /************************************ Subscribe to Events ************************************/
+    FrameRateEventHandler eventHandler(logger);
+    frameRate->Register(&eventHandler);
+    logger.Log("Event handler registered.");
+
+    /************************************* Test All Methods **************************************/
+    TestFrameRateMethods(frameRate, logger);
+
+    /************************************ Wait for Notifications ************************************/
+    logger.Log("Waiting for events... Press Ctrl+C to exit.");
+    std::signal(SIGINT, SignalHandler);
+    while (keepRunning) {
+        std::this_thread::sleep_for(std::chrono::seconds(1));
+    }
+
+    /******************************************* Clean-Up *******************************************/
+    logger.Log("Exiting...");
+    frameRate->Unregister(&eventHandler);
+    return 0;
+}
-- 
2.34.1.windows.1

