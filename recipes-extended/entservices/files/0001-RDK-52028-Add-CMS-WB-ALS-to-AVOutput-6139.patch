From 1fd8cdc47370a83dafeea5fa6c291e05065fc0d3 Mon Sep 17 00:00:00 2001
From: tamilselvanak <103931647+tamilselvanak@users.noreply.github.com>
Date: Tue, 18 Mar 2025 18:49:28 +0530
Subject: [PATCH] RDK-52028 : Add CMS,WB,ALS to AVOutput (#6139)

---
 AVOutput/AVOutputTV.cpp       | 2170 +++++++++++++++++++++++----------
 AVOutput/AVOutputTV.h         |  136 ++-
 AVOutput/AVOutputTVHelper.cpp | 1740 +++++++++++++++++---------
 AVOutput/CHANGELOG.md         |    4 +
 4 files changed, 2807 insertions(+), 1243 deletions(-)

diff --git a/AVOutput/AVOutputTV.cpp b/AVOutput/AVOutputTV.cpp
index e9bd4fb..e95b81e 100644
--- a/AVOutput/AVOutputTV.cpp
+++ b/AVOutput/AVOutputTV.cpp
@@ -270,73 +270,93 @@ namespace Plugin {
         LOGINFO("CTOR\n");
         AVOutputTV::instance = this;
 
-	InitializeIARM();
-
-	registerMethod("getBacklight", &AVOutputTV::getBacklight, this);
-	registerMethod("setBacklight", &AVOutputTV::setBacklight, this);
-	registerMethod("resetBacklight", &AVOutputTV::resetBacklight, this);
-	registerMethod("getBacklightCaps", &AVOutputTV::getBacklightCaps, this);
-	registerMethod("getBrightnessCaps", &AVOutputTV::getBrightnessCaps, this);
-	registerMethod("getBrightness", &AVOutputTV::getBrightness, this);
-	registerMethod("setBrightness", &AVOutputTV::setBrightness, this);
-	registerMethod("resetBrightness", &AVOutputTV::resetBrightness, this);
-	registerMethod("getContrast", &AVOutputTV::getContrast, this);
-	registerMethod("setContrast", &AVOutputTV::setContrast, this);
-	registerMethod("resetContrast", &AVOutputTV::resetContrast, this);
-	registerMethod("getContrastCaps", &AVOutputTV::getContrastCaps, this);
-	registerMethod("getSharpness", &AVOutputTV::getSharpness, this);
-	registerMethod("setSharpness", &AVOutputTV::setSharpness, this);
-	registerMethod("resetSharpness", &AVOutputTV::resetSharpness, this);
-	registerMethod("getSharpnessCaps", &AVOutputTV::getSharpnessCaps, this);
-	registerMethod("getSaturation", &AVOutputTV::getSaturation, this);
-	registerMethod("setSaturation", &AVOutputTV::setSaturation, this);
-	registerMethod("resetSaturation", &AVOutputTV::resetSaturation, this);
-	registerMethod("getSaturationCaps", &AVOutputTV::getSaturationCaps, this);
-	registerMethod("getHue", &AVOutputTV::getHue, this);
-	registerMethod("setHue", &AVOutputTV::setHue, this);
-	registerMethod("resetHue", &AVOutputTV::resetHue, this);
-	registerMethod("getHueCaps", &AVOutputTV::getHueCaps, this);
-	registerMethod("getColorTemperature", &AVOutputTV::getColorTemperature, this);
-	registerMethod("setColorTemperature", &AVOutputTV::setColorTemperature, this);
-	registerMethod("resetColorTemperature", &AVOutputTV::resetColorTemperature, this);
-	registerMethod("getColorTemperatureCaps", &AVOutputTV::getColorTemperatureCaps, this);
-
-	registerMethod("getBacklightDimmingMode", &AVOutputTV::getBacklightDimmingMode, this);
-	registerMethod("setBacklightDimmingMode", &AVOutputTV::setBacklightDimmingMode, this);
-	registerMethod("resetBacklightDimmingMode", &AVOutputTV::resetBacklightDimmingMode, this);
-	registerMethod("getBacklightDimmingModeCaps", &AVOutputTV::getBacklightDimmingModeCaps, this);
-
-	registerMethod("getSupportedDolbyVisionModes", &AVOutputTV::getSupportedDolbyVisionModes, this);
-	registerMethod("getDolbyVisionMode", &AVOutputTV::getDolbyVisionMode, this);
-	registerMethod("setDolbyVisionMode", &AVOutputTV::setDolbyVisionMode, this);
-	registerMethod("resetDolbyVisionMode", &AVOutputTV::resetDolbyVisionMode, this);
-	registerMethod("getDolbyVisionModeCaps", &AVOutputTV::getDolbyVisionModeCaps, this);
-	registerMethod("getVideoFormat", &AVOutputTV::getVideoFormat, this);
-	registerMethod("getVideoSource", &AVOutputTV::getVideoSource, this);
-	registerMethod("getVideoFrameRate", &AVOutputTV::getVideoFrameRate, this);
-	registerMethod("getVideoResolution", &AVOutputTV::getVideoResolution, this);
-	registerMethod("getVideoContentType", &AVOutputTV::getVideoContentType, this);
-
-	registerMethod("getZoomMode", &AVOutputTV::getZoomMode, this);
-	registerMethod("setZoomMode", &AVOutputTV::setZoomMode, this);
-	registerMethod("resetZoomMode", &AVOutputTV::resetZoomMode, this);
-	registerMethod("getZoomModeCaps", &AVOutputTV::getZoomModeCaps, this);
-
-	registerMethod("getPictureMode", &AVOutputTV::getPictureMode, this);
-	registerMethod("setPictureMode", &AVOutputTV::setPictureMode, this);
-	registerMethod("signalFilmMakerMode", &AVOutputTV::signalFilmMakerMode, this);
-	registerMethod("resetPictureMode", &AVOutputTV::resetPictureMode, this);
-	registerMethod("getPictureModeCaps", &AVOutputTV::getPictureModeCaps, this);
-	registerMethod("getSupportedPictureModes", &AVOutputTV::getSupportedPictureModes, this);
-	registerMethod("getVideoSourceCaps", &AVOutputTV::getVideoSourceCaps, this);
-	registerMethod("getVideoFormatCaps", &AVOutputTV::getVideoFormatCaps, this);
-	registerMethod("getVideoFrameRateCaps", &AVOutputTV::getVideoFrameRateCaps, this);
-	registerMethod("getVideoResolutionCaps", &AVOutputTV::getVideoResolutionCaps, this);
-
-	registerMethod("getLowLatencyState", &AVOutputTV::getLowLatencyState, this);
-	registerMethod("setLowLatencyState", &AVOutputTV::setLowLatencyState, this);
-	registerMethod("resetLowLatencyState", &AVOutputTV::resetLowLatencyState, this);
-	registerMethod("getLowLatencyStateCaps", &AVOutputTV::getLowLatencyStateCaps, this);
+        InitializeIARM();
+
+        registerMethod("getBacklight", &AVOutputTV::getBacklight, this);
+        registerMethod("setBacklight", &AVOutputTV::setBacklight, this);
+        registerMethod("resetBacklight", &AVOutputTV::resetBacklight, this);
+        registerMethod("getBacklightCaps", &AVOutputTV::getBacklightCaps, this);
+        registerMethod("getBrightnessCaps", &AVOutputTV::getBrightnessCaps, this);
+        registerMethod("getBrightness", &AVOutputTV::getBrightness, this);
+        registerMethod("setBrightness", &AVOutputTV::setBrightness, this);
+        registerMethod("resetBrightness", &AVOutputTV::resetBrightness, this);
+        registerMethod("getContrast", &AVOutputTV::getContrast, this);
+        registerMethod("setContrast", &AVOutputTV::setContrast, this);
+        registerMethod("resetContrast", &AVOutputTV::resetContrast, this);
+        registerMethod("getContrastCaps", &AVOutputTV::getContrastCaps, this);
+        registerMethod("getSharpness", &AVOutputTV::getSharpness, this);
+        registerMethod("setSharpness", &AVOutputTV::setSharpness, this);
+        registerMethod("resetSharpness", &AVOutputTV::resetSharpness, this);
+        registerMethod("getSharpnessCaps", &AVOutputTV::getSharpnessCaps, this);
+        registerMethod("getSaturation", &AVOutputTV::getSaturation, this);
+        registerMethod("setSaturation", &AVOutputTV::setSaturation, this);
+        registerMethod("resetSaturation", &AVOutputTV::resetSaturation, this);
+        registerMethod("getSaturationCaps", &AVOutputTV::getSaturationCaps, this);
+        registerMethod("getHue", &AVOutputTV::getHue, this);
+        registerMethod("setHue", &AVOutputTV::setHue, this);
+        registerMethod("resetHue", &AVOutputTV::resetHue, this);
+        registerMethod("getHueCaps", &AVOutputTV::getHueCaps, this);
+        registerMethod("getColorTemperature", &AVOutputTV::getColorTemperature, this);
+        registerMethod("setColorTemperature", &AVOutputTV::setColorTemperature, this);
+        registerMethod("resetColorTemperature", &AVOutputTV::resetColorTemperature, this);
+        registerMethod("getColorTemperatureCaps", &AVOutputTV::getColorTemperatureCaps, this);
+
+        registerMethod("getBacklightDimmingMode", &AVOutputTV::getBacklightDimmingMode, this);
+        registerMethod("setBacklightDimmingMode", &AVOutputTV::setBacklightDimmingMode, this);
+        registerMethod("resetBacklightDimmingMode", &AVOutputTV::resetBacklightDimmingMode, this);
+        registerMethod("getBacklightDimmingModeCaps", &AVOutputTV::getBacklightDimmingModeCaps, this);
+
+        registerMethod("getSupportedDolbyVisionModes", &AVOutputTV::getSupportedDolbyVisionModes, this);
+        registerMethod("getDolbyVisionMode", &AVOutputTV::getDolbyVisionMode, this);
+        registerMethod("setDolbyVisionMode", &AVOutputTV::setDolbyVisionMode, this);
+        registerMethod("resetDolbyVisionMode", &AVOutputTV::resetDolbyVisionMode, this);
+        registerMethod("getDolbyVisionModeCaps", &AVOutputTV::getDolbyVisionModeCaps, this);
+        registerMethod("getVideoFormat", &AVOutputTV::getVideoFormat, this);
+        registerMethod("getVideoSource", &AVOutputTV::getVideoSource, this);
+        registerMethod("getVideoFrameRate", &AVOutputTV::getVideoFrameRate, this);
+        registerMethod("getVideoResolution", &AVOutputTV::getVideoResolution, this);
+        registerMethod("getVideoContentType", &AVOutputTV::getVideoContentType, this);
+
+        registerMethod("getZoomMode", &AVOutputTV::getZoomMode, this);
+        registerMethod("setZoomMode", &AVOutputTV::setZoomMode, this);
+        registerMethod("resetZoomMode", &AVOutputTV::resetZoomMode, this);
+        registerMethod("getZoomModeCaps", &AVOutputTV::getZoomModeCaps, this);
+
+        registerMethod("getPictureMode", &AVOutputTV::getPictureMode, this);
+        registerMethod("setPictureMode", &AVOutputTV::setPictureMode, this);
+        registerMethod("signalFilmMakerMode", &AVOutputTV::signalFilmMakerMode, this);
+        registerMethod("resetPictureMode", &AVOutputTV::resetPictureMode, this);
+        registerMethod("getPictureModeCaps", &AVOutputTV::getPictureModeCaps, this);
+        registerMethod("getSupportedPictureModes", &AVOutputTV::getSupportedPictureModes, this);
+        registerMethod("getVideoSourceCaps", &AVOutputTV::getVideoSourceCaps, this);
+        registerMethod("getVideoFormatCaps", &AVOutputTV::getVideoFormatCaps, this);
+        registerMethod("getVideoFrameRateCaps", &AVOutputTV::getVideoFrameRateCaps, this);
+        registerMethod("getVideoResolutionCaps", &AVOutputTV::getVideoResolutionCaps, this);
+
+        registerMethod("getLowLatencyState", &AVOutputTV::getLowLatencyState, this);
+        registerMethod("setLowLatencyState", &AVOutputTV::setLowLatencyState, this);
+        registerMethod("resetLowLatencyState", &AVOutputTV::resetLowLatencyState, this);
+        registerMethod("getLowLatencyStateCaps", &AVOutputTV::getLowLatencyStateCaps, this);
+
+        registerMethod("getCMS", &AVOutputTV::getCMS, this);
+        registerMethod("setCMS", &AVOutputTV::setCMS, this);
+        registerMethod("resetCMS", &AVOutputTV::resetCMS, this);
+        registerMethod("getCMSCaps", &AVOutputTV::getCMSCaps, this);
+
+        registerMethod("get2PointWB", &AVOutputTV::get2PointWB, this);
+        registerMethod("set2PointWB", &AVOutputTV::set2PointWB, this);
+        registerMethod("reset2PointWB", &AVOutputTV::reset2PointWB, this);
+        registerMethod("get2PointWBCaps", &AVOutputTV::get2PointWBCaps, this);
+
+        registerMethod("getHDRMode", &AVOutputTV::getHDRMode, this);
+        registerMethod("setHDRMode", &AVOutputTV::setHDRMode, this);
+        registerMethod("resetHDRMode", &AVOutputTV::resetHDRMode, this);
+        registerMethod("getHDRModeCaps", &AVOutputTV::getHDRModeCaps, this);
+
+        registerMethod("getAutoBacklightMode", &AVOutputTV::getAutoBacklightMode, this);
+        registerMethod("setAutoBacklightMode", &AVOutputTV::setAutoBacklightMode, this);
+        registerMethod("resetAutoBacklightMode", &AVOutputTV::resetAutoBacklightMode, this);
+        registerMethod("getAutoBacklightModeCaps", &AVOutputTV::getAutoBacklightModeCaps, this);
 
         LOGINFO("Exit\n");
     }
@@ -403,8 +423,8 @@ namespace Plugin {
 
         locatePQSettingsFile();
 
-	// Get Index from PQ capabailites
-	if (getPqParamIndex() != 0) {
+        // Get Index from PQ capabailites
+        if (getPqParamIndex() != 0) {
             LOGWARN("Failed to get the supported index from capability \n");
         }
 
@@ -442,10 +462,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getZoomModeCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray rangeArray;
         JsonArray pqmodeArray;
@@ -454,33 +471,33 @@ namespace Plugin {
 
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"AspectRatio");
+        tvError_t ret = getParamsCaps("AspectRatio",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
-	else {
-            for (index = 0; index < range.size(); index++) {
-                rangeArray.Add(range[index]);
-	    }
+        else {
+            for (index = 0; index < info.rangeVector.size(); index++) {
+            rangeArray.Add(info.rangeVector[index]);
+        }
 
             response["options"]=rangeArray;
 
-            if (pqmode.front().compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if (info.pqmodeVector.front().compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -494,9 +511,7 @@ namespace Plugin {
         LOGINFO("Entry\n");
         std::string value;
         tvDisplayMode_t mode = tvDisplayMode_16x9;
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
 
 
         value = parameters.HasLabel("zoomMode") ? parameters["zoomMode"].String() : "";
@@ -507,12 +522,12 @@ namespace Plugin {
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "AspectRatio",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters,"AspectRatio",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-	if( !isCapablityCheckPassed( pqmode, source, format, "AspectRatio" )) {
+	    if( !isCapablityCheckPassed( "AspectRatio",inputInfo )) {
             LOGERR("%s: CapablityCheck failed for AspectRatio\n", __FUNCTION__);
             returnResponse(false);
         }
@@ -546,19 +561,17 @@ namespace Plugin {
         }
         else {
             //Save DisplayMode to localstore and ssm_data
-            int params[3]={0};
-            params[0]=mode;
-            int retval=updateAVoutputTVParam("set","AspectRatio",pqmode,source,format,PQ_PARAM_ASPECT_RATIO,params);
+            int retval=updateAVoutputTVParam("set","AspectRatio",inputInfo,PQ_PARAM_ASPECT_RATIO,mode);
 
             if(retval != 0) {
                 LOGERR("Failed to Save DisplayMode to ssm_data\n");
-		returnResponse(false);
+                returnResponse(false);
             }
 
             tr181ErrorCode_t err = setLocalParam(rfc_caller_id, AVOUTPUT_ASPECTRATIO_RFC_PARAM, value.c_str());
             if ( err != tr181Success ) {
                 LOGERR("setLocalParam for %s Failed : %s\n", AVOUTPUT_ASPECTRATIO_RFC_PARAM, getTR181ErrorString(err));
-		returnResponse(false);
+                returnResponse(false);
             }
             else {
                 LOGINFO("setLocalParam for %s Successful, Value: %s\n", AVOUTPUT_ASPECTRATIO_RFC_PARAM, value.c_str());
@@ -623,17 +636,15 @@ namespace Plugin {
     uint32_t AVOutputTV::resetZoomMode(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry\n");
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "AspectRatio",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "AspectRatio",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-	if( !isCapablityCheckPassed( pqmode, source, format, "AspectRatio" )) {
+        if( !isCapablityCheckPassed( "AspectRatio",inputInfo )) {
             LOGERR("%s: CapablityCheck failed for AspectRatio\n", __FUNCTION__);
             returnResponse(false);
         }
@@ -644,9 +655,9 @@ namespace Plugin {
             ret  = tvERROR_GENERAL;
         }
         else {
-            ret = setDefaultAspectRatio(pqmode,source,format);
+            ret = setDefaultAspectRatio(inputInfo.pqmode,inputInfo.source,inputInfo.format);
         }
-	if(ret != tvERROR_NONE) {
+        if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
@@ -707,29 +718,26 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
         std::string key;
-
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        paramIndex_t indexInfo;
         int backlight = 0,err = 0;
 
-        if (parsingGetInputArgument(parameters, "Backlight",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "Backlight",inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
         if (isPlatformSupport("Backlight") != 0) {
-	    returnResponse(false);
-	}
+            returnResponse(false);
+        }
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("Backlight", inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        err = getLocalparam("Backlight",formatIndex,pqIndex,sourceIndex,backlight, PQ_PARAM_BACKLIGHT);
+        err = getLocalparam("Backlight",indexInfo,backlight, PQ_PARAM_BACKLIGHT);
         if( err == 0 ) {
             response["backlight"] = backlight;
             LOGINFO("Exit : Backlight Value: %d \n", backlight);
@@ -745,9 +753,7 @@ namespace Plugin {
         LOGINFO("Entry\n");
 
         std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
         int backlight = 0;
         tvError_t ret  = tvERROR_NONE;
 
@@ -760,21 +766,21 @@ namespace Plugin {
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "Backlight",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters,"Backlight",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
         if (isPlatformSupport("Backlight") != 0 ) {
-	    returnResponse(false);
-	}
+            returnResponse(false);
+        }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Backlight" )) {
+        if( !isCapablityCheckPassed( "Backlight" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Backlight\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired(pqmode,source,format) ) {
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
             LOGINFO("Proceed with setBacklight\n");
             ret = SetBacklight(backlight);
         }
@@ -784,9 +790,7 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=backlight;
-            int retval= updateAVoutputTVParam("set","Backlight",pqmode,source,format,PQ_PARAM_BACKLIGHT,params);
+            int retval= updateAVoutputTVParam("set","Backlight",inputInfo,PQ_PARAM_BACKLIGHT,backlight);
             if(retval != 0 ) {
                 LOGERR("Failed to Save Backlight to ssm_data\n");
                 returnResponse(false);
@@ -800,39 +804,39 @@ namespace Plugin {
     uint32_t AVOutputTV::resetBacklight(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry\n");
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,backlight=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        int backlight=0;
+        paramIndex_t indexInfo;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "Backlight",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Backlight",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
         if (isPlatformSupport("Backlight") != 0) {
-	    returnResponse(false);
-	}
+            returnResponse(false);
+        }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Backlight" )) {
+        if( !isCapablityCheckPassed( "Backlight",inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Backlight\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","Backlight",pqmode,source,format,PQ_PARAM_BACKLIGHT,params);
+        int retval= updateAVoutputTVParam("reset","Backlight",inputInfo,PQ_PARAM_BACKLIGHT,backlight);
         if(retval != 0 ) {
             LOGERR("Failed to reset Backlight\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("Backlight",formatIndex,pqIndex,sourceIndex,backlight, PQ_PARAM_BACKLIGHT);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("Backlight", inputInfo,indexInfo);
+                int err = getLocalparam("Backlight",indexInfo,backlight, PQ_PARAM_BACKLIGHT);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex,backlight);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex,backlight);
                     ret = SetBacklight(backlight);
                 }
                 else {
@@ -854,14 +858,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getBacklightCaps(const JsonObject& parameters, JsonObject& response)
      {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
-
-        std::string isPlatformSupport;
-        std::vector<std::string> indexInfo;
-
+        capVectors_t vectorInfo;
         JsonObject rangeObj;
         JsonArray pqmodeArray;
         JsonArray formatArray;
@@ -869,33 +866,33 @@ namespace Plugin {
 
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"Backlight", isPlatformSupport, indexInfo);
+        tvError_t ret = getParamsCaps("Backlight", vectorInfo );
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            response["platformSupport"] = (isPlatformSupport.compare("true") == 0)  ? true : false;
+            response["platformSupport"] = (vectorInfo.isPlatformSupportVector[0].compare("true") == 0)  ? true : false;
 
-            rangeObj["from"] = stoi(range[0]);
-            rangeObj["to"] = stoi(range[1]);
+            rangeObj["from"] = std::stoi(vectorInfo.rangeVector[0]);
+            rangeObj["to"] = std::stoi(vectorInfo.rangeVector[1]);
             response["rangeInfo"]=rangeObj;
 
-            if ((pqmode.front()).compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if ((vectorInfo.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < vectorInfo.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(vectorInfo.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((vectorInfo.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < vectorInfo.sourceVector.size(); index++) {
+                    sourceArray.Add(vectorInfo.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((vectorInfo.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < vectorInfo.formatVector.size(); index++) {
+                    formatArray.Add(vectorInfo.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -908,24 +905,21 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        std::string key;
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int brightness = 0;
 
-        if (parsingGetInputArgument(parameters, "Brightness",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "Brightness",inputInfo) != 0) {
             LOGERR("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("Brightness", inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int err = getLocalparam("Brightness",formatIndex,pqIndex,sourceIndex,brightness, PQ_PARAM_BRIGHTNESS);
+        int err = getLocalparam("Brightness",indexInfo,brightness, PQ_PARAM_BRIGHTNESS);
         if( err == 0 ) {
             response["brightness"] = brightness;
             LOGINFO("Exit : Brightness Value: %d \n", brightness);
@@ -941,9 +935,7 @@ namespace Plugin {
         LOGINFO("Entry\n");
 
         std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
         int brightness = 0;
         tvError_t ret = tvERROR_NONE;
 
@@ -956,17 +948,17 @@ namespace Plugin {
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "Brightness",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Brightness",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Brightness" )) {
+        if( !isCapablityCheckPassed( "Brightness",inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Brightness\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired(pqmode,source,format) ) {
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
              LOGINFO("Proceed with %s \n",__FUNCTION__);
              ret = SetBrightness(brightness);
         }
@@ -976,9 +968,7 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=brightness;
-            int retval= updateAVoutputTVParam("set","Brightness",pqmode,source,format,PQ_PARAM_BRIGHTNESS,params);
+            int retval= updateAVoutputTVParam("set","Brightness",inputInfo,PQ_PARAM_BRIGHTNESS,brightness);
             if(retval != 0 ) {
                 LOGERR("Failed to Save Brightness to ssm_data\n");
                 returnResponse(false);
@@ -996,34 +986,35 @@ namespace Plugin {
         LOGINFO("Entry\n");
 
         std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,brightness=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int brightness=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "Brightness",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Brightness",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Brightness" )) {
+        if( !isCapablityCheckPassed( "Brightness",inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Brightness\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","Brightness",pqmode,source,format,PQ_PARAM_BRIGHTNESS,params);
+        int retval= updateAVoutputTVParam("reset","Brightness",inputInfo,PQ_PARAM_BRIGHTNESS,brightness);
         if(retval != 0 ) {
             LOGWARN("Failed to reset Brightness\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("Brightness",formatIndex,pqIndex,sourceIndex,brightness, PQ_PARAM_BRIGHTNESS);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("Brightness", inputInfo,indexInfo);
+                int err = getLocalparam("Brightness",indexInfo,brightness, PQ_PARAM_BRIGHTNESS);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex,brightness);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex,brightness);
                     ret = SetBrightness(brightness);
                 }
                 else {
@@ -1046,10 +1037,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getBrightnessCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray pqmodeArray;
         JsonArray formatArray;
@@ -1058,31 +1046,31 @@ namespace Plugin {
 
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"Brightness");
+        tvError_t ret = getParamsCaps("Brightness",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            rangeObj["from"] = stoi(range[0]);
-            rangeObj["to"] = stoi(range[1]);
+            rangeObj["from"] = stoi(info.rangeVector[0]);
+            rangeObj["to"] = stoi(info.rangeVector[1]);
             response["rangeInfo"]=rangeObj;
 
-            if ((pqmode.front()).compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -1095,24 +1083,21 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        std::string key;
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int contrast = 0;
 
-        if (parsingGetInputArgument(parameters, "Contrast",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "Contrast",inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("Contrast",inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int err = getLocalparam("Contrast",formatIndex,pqIndex,sourceIndex,contrast, PQ_PARAM_CONTRAST);
+        int err = getLocalparam("Contrast",indexInfo,contrast, PQ_PARAM_CONTRAST);
         if( err == 0 ) {
             response["contrast"] = contrast;
             LOGINFO("Exit : Contrast Value: %d \n", contrast);
@@ -1127,33 +1112,31 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
         int contrast = 0;
         tvError_t ret = tvERROR_NONE;
+        std::string value;
 
         value = parameters.HasLabel("contrast") ? parameters["contrast"].String() : "";
         returnIfParamNotFound(parameters,"contrast");
-        contrast = stoi(value);
+        contrast = std::stoi(value);
 
         if (validateIntegerInputParameter("Contrast", contrast) != 0) {
             LOGERR("Failed in contrast range validation:%s", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "Contrast",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Contrast",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Contrast" )) {
+        if( !isCapablityCheckPassed( "Contrast" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Contrast\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired(pqmode,source,format) ) {
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
              LOGINFO("Proceed with %s \n",__FUNCTION__);
              ret = SetContrast(contrast);
         }
@@ -1163,9 +1146,7 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=contrast;
-            int retval= updateAVoutputTVParam("set","Contrast",pqmode,source,format,PQ_PARAM_CONTRAST,params);
+            int retval= updateAVoutputTVParam("set","Contrast",inputInfo,PQ_PARAM_CONTRAST,contrast);
             if(retval != 0 ) {
                 LOGERR("Failed to Save Contrast to ssm_data\n");
                 returnResponse(false);
@@ -1181,36 +1162,36 @@ namespace Plugin {
 
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,contrast=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int contrast=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "Contrast",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Contrast",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Contrast" )) {
+        if( !isCapablityCheckPassed( "Contrast" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Contrast\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","Contrast",pqmode,source,format,PQ_PARAM_CONTRAST,params);
+        int retval= updateAVoutputTVParam("reset","Contrast",inputInfo,PQ_PARAM_CONTRAST,contrast);
 
         if(retval != 0 ) {
             LOGWARN("Failed to reset Contrast\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("Contrast",formatIndex,pqIndex,sourceIndex,contrast, PQ_PARAM_CONTRAST);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("Contrast", inputInfo,indexInfo);
+                int err = getLocalparam("Contrast",indexInfo,contrast, PQ_PARAM_CONTRAST);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex,contrast);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex,contrast);
                     ret = SetContrast(contrast);
                 }
                 else {
@@ -1233,10 +1214,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getContrastCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray rangeArray;
         JsonArray pqmodeArray;
@@ -1246,31 +1224,31 @@ namespace Plugin {
         JsonObject rangeObj;
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"Contrast");
+        tvError_t ret = getParamsCaps("Contrast",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            rangeObj["from"] = stoi(range[0]);
-            rangeObj["to"] = stoi(range[1]);
+            rangeObj["from"] = stoi(info.rangeVector[0]);
+            rangeObj["to"] = stoi(info.rangeVector[1]);
             response["rangeInfo"]=rangeObj;
 
-            if ((pqmode.front()).compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -1283,24 +1261,21 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        std::string key;
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int saturation = 0;
 
-        if (parsingGetInputArgument(parameters, "Saturation",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "Saturation",inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("Saturation", inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int err = getLocalparam("Saturation",formatIndex,pqIndex,sourceIndex,saturation, PQ_PARAM_SATURATION);
+        int err = getLocalparam("Saturation",indexInfo,saturation, PQ_PARAM_SATURATION);
         if( err == 0 ) {
             response["saturation"] = saturation;
             LOGINFO("Exit : Saturation Value: %d \n", saturation);
@@ -1315,33 +1290,31 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
+        capDetails_t inputInfo;
         std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
         int saturation = 0;
         tvError_t ret = tvERROR_NONE;
 
         value = parameters.HasLabel("saturation") ? parameters["saturation"].String() : "";
         returnIfParamNotFound(parameters,"saturation");
-        saturation = stoi(value);
+        saturation = std::stoi(value);
 
         if (validateIntegerInputParameter("Saturation",saturation) != 0) {
             LOGERR("Failed in saturation range validation:%s", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "Saturation",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Saturation",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Saturation" )) {
+        if( !isCapablityCheckPassed( "Saturation" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Saturation\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired(pqmode,source,format) ) {
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
              LOGINFO("Proceed with %s\n",__FUNCTION__);
              ret = SetSaturation(saturation);
         }
@@ -1351,9 +1324,7 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=saturation;
-            int retval= updateAVoutputTVParam("set","Saturation",pqmode,source,format,PQ_PARAM_SATURATION,params);
+            int retval= updateAVoutputTVParam("set","Saturation",inputInfo,PQ_PARAM_SATURATION,saturation);
             if(retval != 0 ) {
                 LOGERR("Failed to Save Saturation to ssm_data\n");
                 returnResponse(false);
@@ -1369,36 +1340,36 @@ namespace Plugin {
 
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,saturation=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int saturation=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "Saturation",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Saturation", inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Saturation" )) {
+        if( !isCapablityCheckPassed( "Saturation", inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Saturation\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","Saturation",pqmode,source,format,PQ_PARAM_SATURATION,params);
+        int retval= updateAVoutputTVParam("reset","Saturation",inputInfo,PQ_PARAM_SATURATION,saturation);
 
         if(retval != 0 ) {
             LOGERR("Failed to reset Saturation\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("Saturation",formatIndex,pqIndex,sourceIndex, saturation, PQ_PARAM_SATURATION);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("Saturation",inputInfo,indexInfo);
+                int err = getLocalparam("Saturation",indexInfo, saturation, PQ_PARAM_SATURATION);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex,saturation);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex,saturation);
                     ret = SetSaturation(saturation);
                 }
                 else {
@@ -1421,10 +1392,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getSaturationCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray rangeArray;
         JsonArray pqmodeArray;
@@ -1434,32 +1402,32 @@ namespace Plugin {
         unsigned int index = 0;
         JsonObject rangeObj;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"Saturation");
+        tvError_t ret = getParamsCaps("Saturation",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            rangeObj["from"] = stoi(range[0]);
-            rangeObj["to"] = stoi(range[1]);
+            rangeObj["from"] = stoi(info.rangeVector[0]);
+            rangeObj["to"] = stoi(info.rangeVector[1]);
             response["rangeInfo"]=rangeObj;
 
 
-            if ((pqmode.front()).compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -1472,24 +1440,21 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        std::string key;
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int sharpness = 0;
 
-        if (parsingGetInputArgument(parameters, "Sharpness",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "Sharpness",inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("Sharpness",inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int err = getLocalparam("Sharpness",formatIndex,pqIndex,sourceIndex,sharpness, PQ_PARAM_SHARPNESS);
+        int err = getLocalparam("Sharpness",indexInfo,sharpness, PQ_PARAM_SHARPNESS);
         if( err == 0 ) {
             response["sharpness"] = sharpness;
             LOGINFO("Exit : Sharpness Value: %d \n", sharpness);
@@ -1504,33 +1469,31 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
         int sharpness = 0;
         tvError_t ret = tvERROR_NONE;
+        std::string value;
 
         value = parameters.HasLabel("sharpness") ? parameters["sharpness"].String() : "";
         returnIfParamNotFound(parameters,"sharpness");
-        sharpness = stoi(value);
+        sharpness = std::stoi(value);
 
         if (validateIntegerInputParameter("Sharpness",sharpness) != 0) {
             LOGERR("Failed in sharpness range validation:%s", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "Sharpness",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Sharpness", inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Sharpness" )) {
+        if( !isCapablityCheckPassed( "Sharpness", inputInfo  )) {
             LOGERR("%s: CapablityCheck failed for Sharpness\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired(pqmode,source,format) ) {
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
              LOGINFO("Proceed with %s\n",__FUNCTION__);
              ret = SetSharpness(sharpness);
         }
@@ -1540,9 +1503,7 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=sharpness;
-            int retval= updateAVoutputTVParam("set","Sharpness",pqmode,source,format,PQ_PARAM_SHARPNESS,params);
+            int retval= updateAVoutputTVParam("set","Sharpness",inputInfo,PQ_PARAM_SHARPNESS,sharpness);
             if(retval != 0 ) {
                 LOGERR("Failed to Save Sharpness to ssm_data\n");
                 returnResponse(false);
@@ -1558,36 +1519,36 @@ namespace Plugin {
 
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,sharpness=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int sharpness=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "Sharpness",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Sharpness",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Sharpness" )) {
+        if( !isCapablityCheckPassed( "Sharpness" , inputInfo)) {
             LOGERR("%s: CapablityCheck failed for Sharpness\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","Sharpness",pqmode,source,format,PQ_PARAM_SHARPNESS,params);
+        int retval= updateAVoutputTVParam("reset","Sharpness", inputInfo,PQ_PARAM_SHARPNESS,sharpness);
 
         if(retval != 0 ) {
             LOGERR("Failed to reset Sharpness\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("Sharpness",formatIndex,pqIndex,sourceIndex, sharpness, PQ_PARAM_SHARPNESS);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("Sharpness",inputInfo,indexInfo);
+                int err = getLocalparam("Sharpness",indexInfo, sharpness, PQ_PARAM_SHARPNESS);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex,sharpness);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex,sharpness);
                     ret = SetSharpness(sharpness);
                 }
                 else {
@@ -1610,10 +1571,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getSharpnessCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray rangeArray;
         JsonArray pqmodeArray;
@@ -1623,31 +1581,31 @@ namespace Plugin {
         JsonObject rangeObj;
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"Sharpness");
+        tvError_t ret = getParamsCaps("Sharpness",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            rangeObj["from"] = stoi(range[0]);
-            rangeObj["to"] = stoi(range[1]);
+            rangeObj["from"] = stoi(info.rangeVector[0]);
+            rangeObj["to"] = stoi(info.rangeVector[1]);
             response["rangeInfo"]=rangeObj;
 
-            if ((pqmode.front()).compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -1660,24 +1618,21 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        std::string key;
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int hue = 0;
 
-        if (parsingGetInputArgument(parameters, "Hue",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "Hue", inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("Hue",inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int err = getLocalparam("Hue",formatIndex,pqIndex,sourceIndex,hue, PQ_PARAM_HUE);
+        int err = getLocalparam("Hue",indexInfo,hue, PQ_PARAM_HUE);
         if( err == 0 ) {
             response["hue"] = hue;
             LOGINFO("Exit : Hue Value: %d \n", hue);
@@ -1692,33 +1647,31 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
         int hue = 0;
         tvError_t ret = tvERROR_NONE;
+        std::string value;
 
         value = parameters.HasLabel("hue") ? parameters["hue"].String() : "";
         returnIfParamNotFound(parameters,"hue");
-        hue = stoi(value);
+        hue = std::stoi(value);
 
         if (validateIntegerInputParameter("Hue",hue) != 0) {
             LOGERR("Failed in hue range validation:%s", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "Hue",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Hue",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Hue" )) {
+        if( !isCapablityCheckPassed( "Hue", inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Hue\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired(pqmode,source,format) ) {
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
              LOGINFO("Proceed with %s\n",__FUNCTION__);
              ret = SetHue(hue);
         }
@@ -1728,9 +1681,7 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=hue;
-            int retval= updateAVoutputTVParam("set","Hue",pqmode,source,format,PQ_PARAM_HUE,params);
+            int retval= updateAVoutputTVParam("set","Hue",inputInfo,PQ_PARAM_HUE,hue);
             if(retval != 0 ) {
                 LOGERR("Failed to Save Hue to ssm_data\n");
                 returnResponse(false);
@@ -1746,36 +1697,36 @@ namespace Plugin {
 
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,hue=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int hue=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "Hue",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "Hue",inputInfo)!= 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "Hue" )) {
+        if( !isCapablityCheckPassed( "Hue" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for Hue\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","Hue",pqmode,source,format,PQ_PARAM_HUE,params);
+        int retval= updateAVoutputTVParam("reset","Hue", inputInfo,PQ_PARAM_HUE,hue);
 
         if(retval != 0 ) {
             LOGERR("Failed to reset Hue\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("Hue",formatIndex,pqIndex,sourceIndex, hue, PQ_PARAM_HUE);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("Hue",inputInfo,indexInfo);
+                int err = getLocalparam("Hue",indexInfo, hue, PQ_PARAM_HUE);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex,hue);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex,hue);
                     ret = SetHue(hue);
                 }
                 else {
@@ -1798,10 +1749,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getHueCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray rangeArray;
         JsonArray pqmodeArray;
@@ -1811,31 +1759,31 @@ namespace Plugin {
         JsonObject rangeObj;
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"Hue");
+        tvError_t ret = getParamsCaps("Hue",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            rangeObj["from"] = stoi(range[0]);
-            rangeObj["to"] = stoi(range[1]);
+            rangeObj["from"] = stoi(info.rangeVector[0]);
+            rangeObj["to"] = stoi(info.rangeVector[1]);
             response["rangeInfo"]=rangeObj;
 
-            if ((pqmode.front()).compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -1848,24 +1796,21 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        std::string key;
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int colortemp = 0;
 
-        if (parsingGetInputArgument(parameters, "ColorTemperature",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "ColorTemperature", inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("ColorTemperature",inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int err = getLocalparam("ColorTemp",formatIndex,pqIndex,sourceIndex,colortemp,PQ_PARAM_COLOR_TEMPERATURE);
+        int err = getLocalparam("ColorTemp",indexInfo,colortemp,PQ_PARAM_COLOR_TEMPERATURE);
         if( err == 0 ) {
             switch(colortemp) {
                 case tvColorTemp_STANDARD:
@@ -1885,7 +1830,7 @@ namespace Plugin {
 
                 case tvColorTemp_USER:
                     LOGINFO("Color Temp Value: User Defined\n");
-                    response["colorTemperature"] = "User Defined";
+                    response["colorTemperature"] = "UserDefined";
                     break;
 
                 default:
@@ -1905,10 +1850,8 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
+        capDetails_t inputInfo;
         std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
         tvColorTemp_t colortemp = tvColorTemp_MAX;
         tvError_t ret = tvERROR_NONE;
 
@@ -1923,24 +1866,24 @@ namespace Plugin {
         else if (!value.compare("Cold")) {
             colortemp = tvColorTemp_COLD;
         }
-        else if (!value.compare("User Defined")) {
+        else if (!value.compare("UserDefined")) {
             colortemp = tvColorTemp_USER;
         }
         else {
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "ColorTemperature",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "ColorTemperature",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "ColorTemperature" )) {
+        if( !isCapablityCheckPassed( "ColorTemperature", inputInfo )) {
             LOGERR("%s: CapablityCheck failed for colorTemperature\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired(pqmode,source,format) ) {
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
              LOGINFO("Proceed with %s\n",__FUNCTION__);
              ret = SetColorTemperature((tvColorTemp_t)colortemp);
         }
@@ -1950,9 +1893,7 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=(int)colortemp;
-            int retval= updateAVoutputTVParam("set","ColorTemp",pqmode,source,format,PQ_PARAM_COLOR_TEMPERATURE,params);
+            int retval= updateAVoutputTVParam("set","ColorTemp", inputInfo,PQ_PARAM_COLOR_TEMPERATURE,(int)colortemp);
             if(retval != 0 ) {
                 LOGERR("Failed to Save ColorTemperature to ssm_data\n");
                 returnResponse(false);
@@ -1967,36 +1908,36 @@ namespace Plugin {
 
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,colortemp=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int colortemp=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "ColorTemperature",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "ColorTemperature", inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "ColorTemperature" )) {
+        if( !isCapablityCheckPassed( "ColorTemperature", inputInfo )) {
             LOGERR("%s: CapablityCheck failed for colorTemperature\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","ColorTemp",pqmode,source,format,PQ_PARAM_COLOR_TEMPERATURE,params);
+        int retval= updateAVoutputTVParam("reset","ColorTemp", inputInfo,PQ_PARAM_COLOR_TEMPERATURE,colortemp);
 
         if(retval != 0 ) {
             LOGERR("Failed to reset ColorTemperature\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("ColorTemp",formatIndex,pqIndex,sourceIndex, colortemp, PQ_PARAM_COLOR_TEMPERATURE);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("ColorTemperature",inputInfo,indexInfo);
+                int err = getLocalparam("ColorTemp",indexInfo, colortemp, PQ_PARAM_COLOR_TEMPERATURE);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex, colortemp);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex, colortemp);
                     ret = SetColorTemperature((tvColorTemp_t)colortemp);
                 }
                 else {
@@ -2018,10 +1959,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getColorTemperatureCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray rangeArray;
         JsonArray pqmodeArray;
@@ -2030,33 +1968,33 @@ namespace Plugin {
 
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"ColorTemperature");
+        tvError_t ret = getParamsCaps("ColorTemperature",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            for (index = 0; index < range.size(); index++) {
-                rangeArray.Add(range[index]);
-	    }
+            for (index = 0; index < info.rangeVector.size(); index++) {
+                rangeArray.Add(info.rangeVector[index]);
+            }
 
             response["options"]=rangeArray;
 
-            if (((pqmode.front()).compare("none") != 0)) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if (((info.pqmodeVector.front()).compare("none") != 0)) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -2069,25 +2007,22 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        std::string key;
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int dimmingMode = 0;
 
-        if (parsingGetInputArgument(parameters, "DimmingMode",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "DimmingMode", inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("DimmingMode",inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
 
-        int err = getLocalparam("DimmingMode",formatIndex,pqIndex,sourceIndex,dimmingMode, PQ_PARAM_DIMMINGMODE);
+        int err = getLocalparam("DimmingMode",indexInfo,dimmingMode, PQ_PARAM_DIMMINGMODE);
         if( err == 0 ) {
             switch(dimmingMode) {
                 case tvDimmingMode_Fixed:
@@ -2118,12 +2053,10 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
         int dimmingMode = 0;
         tvError_t ret = tvERROR_NONE;
+        std::string value;
 
         value = parameters.HasLabel("DimmingMode") ? parameters["DimmingMode"].String() : "";
         returnIfParamNotFound(parameters,"DimmingMode");
@@ -2134,17 +2067,17 @@ namespace Plugin {
         }
         dimmingMode = getDimmingModeIndex(value);
 
-        if (parsingSetInputArgument(parameters, "DimmingMode",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "DimmingMode",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "DimmingMode" )) {
+        if( !isCapablityCheckPassed( "DimmingMode" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for DimmingMode\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired(pqmode,source,format) ) {
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
              LOGINFO("Proceed with %s\n",__FUNCTION__);
              ret = SetTVDimmingMode(value.c_str());
         }
@@ -2154,9 +2087,7 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=(int)dimmingMode;
-            int retval= updateAVoutputTVParam("set","DimmingMode",pqmode,source,format,PQ_PARAM_DIMMINGMODE,params);
+            int retval= updateAVoutputTVParam("set","DimmingMode",inputInfo,PQ_PARAM_DIMMINGMODE,(int)dimmingMode);
             if(retval != 0 ) {
                 LOGERR("Failed to Save DimmingMode to ssm_data\n");
                 returnResponse(false);
@@ -2171,25 +2102,23 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;std::string dimmingMode;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,dMode=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        std::string dimmingMode;
+        int dMode=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "DimmingMode",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "DimmingMode", inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "DimmingMode" )) {
+        if( !isCapablityCheckPassed( "DimmingMode" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for DimmingMode\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","DimmingMode",pqmode,source,format,PQ_PARAM_DIMMINGMODE,params);
+        int retval= updateAVoutputTVParam("reset","DimmingMode", inputInfo,PQ_PARAM_DIMMINGMODE,dMode);
 
         if(retval != 0 ) {
             LOGERR("Failed to reset ldim\n");
@@ -2197,11 +2126,14 @@ namespace Plugin {
         }
 
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("DimmingMode",formatIndex,pqIndex,sourceIndex, dMode, PQ_PARAM_DIMMINGMODE);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("DimmingMode",inputInfo,indexInfo);
+                int err = getLocalparam("DimmingMode",indexInfo, dMode, PQ_PARAM_DIMMINGMODE);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex, dMode);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex, dMode);
                     getDimmingModeStringFromEnum(dMode,dimmingMode);
                     ret = SetTVDimmingMode(dimmingMode.c_str());
                 }
@@ -2224,10 +2156,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getBacklightDimmingModeCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> supportedDimmingMode;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray supportedDimmingModeArray;
         JsonArray pqmodeArray;
@@ -2236,33 +2165,33 @@ namespace Plugin {
 
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(supportedDimmingMode,pqmode,source,format,"DimmingMode");
+        tvError_t ret = getParamsCaps("DimmingMode",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            for (index = 0; index < supportedDimmingMode.size(); index++) {
-                supportedDimmingModeArray.Add(supportedDimmingMode[index]);
+            for (index = 0; index < info.rangeVector.size(); index++) {
+                supportedDimmingModeArray.Add(info.rangeVector[index]);
             }
 
             response["options"]=supportedDimmingModeArray;
 
-            if (((pqmode.front()).compare("none") != 0)) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if (((info.pqmodeVector.front()).compare("none") != 0)) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -2273,7 +2202,6 @@ namespace Plugin {
 
     uint32_t AVOutputTV::getSupportedDolbyVisionModes(const JsonObject& parameters, JsonObject& response)
     {
-
         LOGINFO("Entry\n");
         tvDolbyMode_t dvModes[tvMode_Max];
         tvDolbyMode_t *dvModesPtr = dvModes; // Pointer to statically allocated tvDolbyMode_t array 
@@ -2297,21 +2225,18 @@ namespace Plugin {
             LOGINFO("Exit\n");
             returnResponse(true);
         }
-
     }
 
+
     uint32_t AVOutputTV::getDolbyVisionMode(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::string pqmode;
-        std::string source;
-        std::string format;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int dolbyMode = 0;
         int err = 0;
 
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
-
-        if (parsingGetInputArgument(parameters, "DolbyVisionMode",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "DolbyVisionMode",inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
@@ -2320,15 +2245,13 @@ namespace Plugin {
 	    returnResponse(false);
 	}
 
-        // Since it is dolby vision mode, to should get only for dolby vision format
-        format = "DV";
 
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("DolbyVisionMode",inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        err = getLocalparam("DolbyVisionMode",formatIndex,pqIndex,sourceIndex,dolbyMode, PQ_PARAM_DOLBY_MODE);
+        err = getLocalparam("DolbyVisionMode",indexInfo,dolbyMode, PQ_PARAM_DOLBY_MODE);
         if( err == 0 ) {
             response["dolbyVisionMode"] = getDolbyModeStringFromEnum((tvDolbyMode_t)dolbyMode);
             LOGINFO("Exit : DolbyVisionMode Value: %d \n", dolbyMode);
@@ -2344,35 +2267,33 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
+        capDetails_t inputInfo;
         std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
         tvError_t ret  = tvERROR_NONE;
 
         value = parameters.HasLabel("dolbyVisionMode") ? parameters["dolbyVisionMode"].String() : "";
         returnIfParamNotFound(parameters,"dolbyVisionMode");
 
-        if (parsingSetInputArgument(parameters, "DolbyVisionMode",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "DolbyVisionMode",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
         if (isPlatformSupport("DolbyVisionMode") != 0) {
-	    returnResponse(false);
-	}
+            returnResponse(false);
+        }
 
         if (validateInputParameter("DolbyVisionMode",value) != 0) {
             LOGERR("%s: Range validation failed for DolbyVisionMode\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "DolbyVisionMode" )) {
+        if( !isCapablityCheckPassed( "DolbyVisionMode" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for DolbyVisionMode\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired("Current",source,"DV") ) {
+        if( isSetRequired("Current",inputInfo.source,"DV") ) {
             LOGINFO("Proceed with setDolbyVisionMode\n\n");
             ret = SetTVDolbyVisionMode(GetDolbyVisionEnumFromModeString(value.c_str()));
         }
@@ -2382,10 +2303,8 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            int params[3]={0};
-            params[0]=getDolbyModeIndex(value.c_str());
-            format = "DV";
-            int retval= updateAVoutputTVParam("set","DolbyVisionMode",pqmode,source,format,PQ_PARAM_DOLBY_MODE,params);
+            inputInfo.format = "DV"; //Update only for DV format
+            int retval= updateAVoutputTVParam("set","DolbyVisionMode",inputInfo,PQ_PARAM_DOLBY_MODE,getDolbyModeIndex(value.c_str()));
             if(retval != 0 ) {
                 LOGERR("Failed to Save Dolbyvision mode\n");
                 returnResponse(false);
@@ -2400,15 +2319,12 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,dolbyMode=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int dolbyMode=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "DolbyVisionMode",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "DolbyVisionMode",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
@@ -2417,24 +2333,26 @@ namespace Plugin {
 	    returnResponse(false);
 	}
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "DolbyVisionMode" )) {
+        if( !isCapablityCheckPassed( "DolbyVisionMode" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for DolbyVisionMode\n", __FUNCTION__);
             returnResponse(false);
         }
-
-        format = "DV";
-        int retval= updateAVoutputTVParam("reset","DolbyVisionMode",pqmode,source,format,PQ_PARAM_DOLBY_MODE,params);
+        inputInfo.format = "DV"; //Update only for DV format
+        int retval= updateAVoutputTVParam("reset","DolbyVisionMode",inputInfo,PQ_PARAM_DOLBY_MODE,dolbyMode);
         if(retval != 0 ) {
             LOGERR("Failed to reset DolbyVisionMode\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired("Current",source,format)) {
-                getParamIndex("Current","Current", format,sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("DolbyVisionMode",formatIndex,pqIndex,sourceIndex, dolbyMode, PQ_PARAM_DOLBY_MODE);
+            if (isSetRequired("Current",inputInfo.source,inputInfo.format)) {
+                inputInfo.source = "Current";
+                inputInfo.pqmode = "Current";
+                inputInfo.format = "DV";
+                getParamIndex("DolbyVisionMode",inputInfo,indexInfo);
+                int err = getLocalparam("DolbyVisionMode",indexInfo, dolbyMode, PQ_PARAM_DOLBY_MODE);
                 if( err == 0 ) {
-                    std::string dolbyModeValue = getDolbyModeStringFromEnum((tvDolbyMode_t)dolbyMode);
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d dolbyvalue : %s\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex, dolbyModeValue.c_str());
+
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d dolbyvalue : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex, dolbyMode);
                     ret = SetTVDolbyVisionMode((tvDolbyMode_t)dolbyMode);
                 }
                 else {
@@ -2456,12 +2374,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getDolbyVisionModeCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
-        std::string isPlatformSupport;
-        std::vector<std::string> indexInfo;
+        capVectors_t info;
 
         JsonArray rangeArray;
         JsonArray pqmodeArray;
@@ -2470,35 +2383,35 @@ namespace Plugin {
 
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"DolbyVisionMode", isPlatformSupport, indexInfo);
+        tvError_t ret = getParamsCaps("DolbyVisionMode", info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
 
-            response["platformSupport"] = (isPlatformSupport.compare("true") == 0 ) ? true : false;
+            response["platformSupport"] = (info.isPlatformSupportVector[0].compare("true") == 0 ) ? true : false;
 
-            for (index = 0; index < range.size(); index++) {
-                rangeArray.Add(range[index]);
+            for (index = 0; index < info.rangeVector.size(); index++) {
+                rangeArray.Add(info.rangeVector[index]);
             }
 
             response["options"]=rangeArray;
-            if ((pqmode.front()).compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -2553,20 +2466,17 @@ namespace Plugin {
 
         JsonArray rangeArray;
 
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"VideoFormat");
+        tvError_t ret = getParamsCaps("VideoFormat",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            if ((range.front()).compare("none") != 0) {
-                for (unsigned int index = 0; index < range.size(); index++) {
-                    rangeArray.Add(range[index]);
+            if ((info.rangeVector.front()).compare("none") != 0) {
+                for (unsigned int index = 0; index < info.rangeVector.size(); index++) {
+                    rangeArray.Add(info.rangeVector[index]);
                 }
                 response["options"]=rangeArray;
             }
@@ -2608,35 +2518,32 @@ namespace Plugin {
         JsonArray formatArray;
         JsonArray rangeArray;
 
-        std::vector<std::string> range;
-        std::vector<std::string> source;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         unsigned int index = 0;
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"PictureMode");
+        tvError_t ret = getParamsCaps("PictureMode",info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
 
-            if ((range.front()).compare("none") != 0) {
-                for (index = 0; index < range.size(); index++) {
-                    rangeArray.Add(range[index]);
+            if ((info.rangeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.rangeVector.size(); index++) {
+                    rangeArray.Add(info.rangeVector[index]);
                 }
                 response["options"]=rangeArray;
             }
 
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -2648,29 +2555,24 @@ namespace Plugin {
     uint32_t AVOutputTV::getPictureMode(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry\n");
-        std::string picturemode;
-        std::string source;
-        std::string format;
-        std::string dummyPqmode;
-        int current_source = 0;
-        int current_format = 0;
-        int pqIndex = 0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         std::string tr181_param_name;
         TR181_ParamData_t param = {0};
         tr181ErrorCode_t err = tr181Success;
 
-        if (parsingGetInputArgument(parameters, "PictureMode",source, dummyPqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "PictureMode",inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (getParamIndex(source,dummyPqmode,format,current_source,pqIndex,current_format) == -1) {
+        if (getParamIndex("PictureMode",inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
         tr181_param_name += std::string(AVOUTPUT_SOURCE_PICTUREMODE_STRING_RFC_PARAM);
-        tr181_param_name += "." + convertSourceIndexToString(current_source) + "." + "Format."+convertVideoFormatToString(current_format)+"."+"PictureModeString";
+        tr181_param_name += "." + convertSourceIndexToString(indexInfo.sourceIndex) + "." + "Format."+convertVideoFormatToString(indexInfo.formatIndex)+"."+"PictureModeString";
         err = getLocalParam(rfc_caller_id, tr181_param_name.c_str(), &param);
 
         if ( tr181Success != err ) {
@@ -2688,11 +2590,9 @@ namespace Plugin {
     uint32_t AVOutputTV::setPictureMode(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry\n");
-        std::string value;
-        std::string source;
-        std::string format;
-        std::string dummyPqmode;
+        capDetails_t inputInfo;
         char prevmode[PIC_MODE_NAME_MAX]={0};
+        std::string value;
         GetTVPictureMode(prevmode);
 
         tvError_t ret = tvERROR_NONE;
@@ -2700,7 +2600,7 @@ namespace Plugin {
         returnIfParamNotFound(parameters,"pictureMode");
 
         // As only source need to validate, so pqmode and formate passing as currrent
-        if (parsingSetInputArgument(parameters, "PictureMode",source, dummyPqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "PictureMode",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
@@ -2709,12 +2609,12 @@ namespace Plugin {
             LOGERR("%s: Range validation failed for PictureMode\n", __FUNCTION__);
             returnResponse(false);
         }
-        if( !isCapablityCheckPassed( dummyPqmode, source,format, "PictureMode" )) {
+        if( !isCapablityCheckPassed( "PictureMode" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for PictureMode\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( isSetRequired("Current",source,format) ) {
+        if( isSetRequired("Current",inputInfo.source,inputInfo.format) ) {
             LOGINFO("Proceed with SetTVPictureMode\n");
             ret = SetTVPictureMode(value.c_str());
          }
@@ -2722,15 +2622,14 @@ namespace Plugin {
             returnResponse(false);
         }
         else {
-            std::vector<int> pq_mode_vec;
-            std::vector<int> source_vec;
-            std::vector<int> format_vec;
+            valueVectors_t values;
+            inputInfo.pqmode = "Current";
 
-            getSaveConfig("Current", source.c_str(), format.c_str(), source_vec, pq_mode_vec, format_vec);
+            getSaveConfig("PictureMode" ,inputInfo, values);
 
-            for (int sourceType : source_vec) {
+            for (int sourceType : values.sourceValues) {
                 tvVideoSrcType_t source = (tvVideoSrcType_t)sourceType;
-                for (int formatType : format_vec) {
+                for (int formatType : values.formatValues) {
                     tvVideoFormatType_t format = (tvVideoFormatType_t)formatType;
                     std::string tr181_param_name = "";
                     tr181_param_name += std::string(AVOUTPUT_SOURCE_PICTUREMODE_STRING_RFC_PARAM);
@@ -2781,29 +2680,25 @@ namespace Plugin {
         tr181ErrorCode_t err = tr181Success;
         TR181_ParamData_t param = {0};
 
-        std::vector<int> pq_mode_vec;
-        std::vector<int> source_vec;
-        std::vector<int> format_vec;
-        std::string source;
-        std::string dummyPqmode;
-        std::string format;
+        valueVectors_t values;
+        capDetails_t inputInfo;
 
         // As only source need to validate, so pqmode and formate passing as currrent
-        if (parsingSetInputArgument(parameters, "PictureMode",source, dummyPqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "PictureMode",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( dummyPqmode, source,format, "PictureMode" )) {
+        if( !isCapablityCheckPassed( "PictureMode",inputInfo )) {
             LOGERR("%s: CapablityCheck failed for PictureMode\n", __FUNCTION__);
             returnResponse(false);
         }
+        inputInfo.pqmode = "Current";
+        getSaveConfig("PictureMode", inputInfo, values);
 
-        getSaveConfig("Current", source, format, source_vec, pq_mode_vec, format_vec);
-
-        for (int source : source_vec) {
+        for (int source : values.sourceValues) {
             tvVideoSrcType_t sourceType = (tvVideoSrcType_t)source;
-            for (int format : format_vec) {
+            for (int format : values.formatValues) {
                 tvVideoFormatType_t formatType = (tvVideoFormatType_t)format;
                 std::string tr181_param_name = "";
                 tr181_param_name += std::string(AVOUTPUT_SOURCE_PICTUREMODE_STRING_RFC_PARAM);
@@ -2878,10 +2773,7 @@ namespace Plugin {
         LOGINFO("Entry\n");
 
         std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int params[3]={0};
+        capDetails_t inputInfo;
         int lowLatencyIndex = 0,prevLowLatencyIndex = 0;
         tvError_t ret = tvERROR_NONE;
 
@@ -2893,41 +2785,37 @@ namespace Plugin {
 
         value = parameters.HasLabel("LowLatencyState") ? parameters["LowLatencyState"].String() : "";
         returnIfParamNotFound(parameters,"LowLatencyState");
-        lowLatencyIndex = stoi(value);
+        lowLatencyIndex = std::stoi(value);
 
         if (validateIntegerInputParameter("LowLatencyState",lowLatencyIndex) != 0) {
             LOGERR("Failed in Brightness range validation:%s", __FUNCTION__);
             returnResponse(false);
         }
 
-        if (parsingSetInputArgument(parameters, "LowLatencyState",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "LowLatencyState",inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed(pqmode, source, format, "LowLatencyState" )) {
+        if( !isCapablityCheckPassed( "LowLatencyState" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for LowLatencyState\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        params[0]=lowLatencyIndex;
-        int retval= updateAVoutputTVParam("set","LowLatencyState",pqmode,source,format,PQ_PARAM_LOWLATENCY_STATE,params);
+        int retval= updateAVoutputTVParam("set","LowLatencyState",inputInfo,PQ_PARAM_LOWLATENCY_STATE,lowLatencyIndex);
         if(retval != 0 ) {
             LOGERR("Failed to SaveLowLatency to ssm_data\n");
             returnResponse(false);
         } else {
-           
-            if( isSetRequired(pqmode,source,format) ) {
+
+            if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
              LOGINFO("Proceed with setLowLatencyState\n");
              ret = SetLowLatencyState( lowLatencyIndex );
             }
 
             if(ret != tvERROR_NONE) {
-                LOGERR("Failed to setLowLatency\n");
-                params[0]=prevLowLatencyIndex;
                 LOGERR("Failed to set low latency. Fallback to previous state %d\n", prevLowLatencyIndex);
-
-                retval=updateAVoutputTVParam("set","LowLatencyState",pqmode,source,format,PQ_PARAM_LOWLATENCY_STATE,params);
+                retval=updateAVoutputTVParam("set","LowLatencyState",inputInfo,PQ_PARAM_LOWLATENCY_STATE,prevLowLatencyIndex);
                 if(retval != 0 ){
                     LOGERR("Fallback to previous low latency state %d failed.\n", prevLowLatencyIndex);
                 }
@@ -2943,23 +2831,20 @@ namespace Plugin {
     {
         LOGINFO("Entry");
 
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        std::string key;
-        int sourceIndex=0,pqIndex=0,formatIndex=0;
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
         int lowlatencystate = 0;
 
-        if (parsingGetInputArgument(parameters, "LowLatencyState",source, pqmode, format) != 0) {
+        if (parsingGetInputArgument(parameters, "LowLatencyState",inputInfo) != 0) {
             LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
             returnResponse(false);
         }
-        if (getParamIndex(source,pqmode,format,sourceIndex,pqIndex,formatIndex) == -1) {
+        if (getParamIndex("LowLatencyState",inputInfo,indexInfo) == -1) {
             LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int err = getLocalparam("LowLatencyState",formatIndex,pqIndex,sourceIndex,lowlatencystate, PQ_PARAM_LOWLATENCY_STATE);
+        int err = getLocalparam("LowLatencyState", indexInfo ,lowlatencystate, PQ_PARAM_LOWLATENCY_STATE);
         if( err == 0 ) {
             response["lowLatencyState"] = std::to_string(lowlatencystate);
             LOGINFO("Exit : LowLatencyState Value: %d \n", lowlatencystate);
@@ -2974,35 +2859,35 @@ namespace Plugin {
     {
         LOGINFO("Entry\n");
 
-        std::string value;
-        std::string pqmode;
-        std::string source;
-        std::string format;
-        int sourceIndex=0,pqIndex=0,formatIndex=0,lowlatencystate=0;
-        int params[3]={0};
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int lowlatencystate=0;
         tvError_t ret = tvERROR_NONE;
 
-        if (parsingSetInputArgument(parameters, "LowLatencyState",source, pqmode, format) != 0) {
+        if (parsingSetInputArgument(parameters, "LowLatencyState", inputInfo) != 0) {
             LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
             returnResponse(false);
         }
 
-        if( !isCapablityCheckPassed( pqmode, source, format, "LowLatencyState" )) {
+        if( !isCapablityCheckPassed( "LowLatencyState" , inputInfo )) {
             LOGERR("%s: CapablityCheck failed for LowLatencyState\n", __FUNCTION__);
             returnResponse(false);
         }
 
-        int retval= updateAVoutputTVParam("reset","LowLatencyState",pqmode,source,format,PQ_PARAM_LOWLATENCY_STATE,params);
+        int retval= updateAVoutputTVParam("reset","LowLatencyState", inputInfo,PQ_PARAM_LOWLATENCY_STATE,lowlatencystate);
         if(retval != 0 ) {
             LOGERR("Failed to clear Lowlatency from ssmdata and localstore\n");
             returnResponse(false);
         }
         else {
-            if (isSetRequired(pqmode,source,format)) {
-                getParamIndex("Current","Current", "Current",sourceIndex,pqIndex,formatIndex);
-                int err = getLocalparam("LowLatencyState",formatIndex,pqIndex,sourceIndex, lowlatencystate, PQ_PARAM_LOWLATENCY_STATE);
+            if (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                inputInfo.pqmode = "Current";
+                inputInfo.source = "Current";
+                inputInfo.format = "Current";
+                getParamIndex("LowLatencyState",inputInfo, indexInfo);
+                int err = getLocalparam("LowLatencyState",indexInfo, lowlatencystate, PQ_PARAM_LOWLATENCY_STATE);
                 if( err == 0 ) {
-                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,formatIndex, sourceIndex, pqIndex, lowlatencystate);
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d value : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex, lowlatencystate);
                     ret = SetLowLatencyState(lowlatencystate);
                 }
                 else {
@@ -3024,10 +2909,7 @@ namespace Plugin {
     uint32_t AVOutputTV::getLowLatencyStateCaps(const JsonObject& parameters, JsonObject& response)
     {
         LOGINFO("Entry");
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
         JsonArray rangeArray;
         JsonArray pqmodeArray;
@@ -3036,32 +2918,32 @@ namespace Plugin {
 
         unsigned int index = 0;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"LowLatencyState");
+        tvError_t ret = getParamsCaps("LowLatencyState", info);
 
         if(ret != tvERROR_NONE) {
             returnResponse(false);
         }
         else {
-            for (index = 0; index < range.size(); index++) {
-                rangeArray.Add(stoi(range[index]));
+            for (index = 0; index < info.rangeVector.size(); index++) {
+                rangeArray.Add(stoi(info.rangeVector[index]));
 	    }
 
             response["LowLatencyInfo"]=rangeArray;
-            if ((pqmode.front()).compare("none") != 0) {
-                for (index = 0; index < pqmode.size(); index++) {
-                    pqmodeArray.Add(pqmode[index]);
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
                 }
                 response["pictureModeInfo"]=pqmodeArray;
             }
-            if ((source.front()).compare("none") != 0) {
-                for (index = 0; index < source.size(); index++) {
-                    sourceArray.Add(source[index]);
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
                 }
                 response["videoSourceInfo"]=sourceArray;
             }
-            if ((format.front()).compare("none") != 0) {
-                for (index = 0; index < format.size(); index++) {
-                    formatArray.Add(format[index]);
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
                 }
                 response["videoFormatInfo"]=formatArray;
             }
@@ -3070,6 +2952,972 @@ namespace Plugin {
         }
     }
 
+    uint32_t AVOutputTV::getCMS(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry");
+
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int level = 0;
+        tvPQParameterIndex_t tvPQEnum;
+
+        inputInfo.color = parameters.HasLabel("color") ? parameters["color"].String() : "";
+	    inputInfo.component = parameters.HasLabel("component") ? parameters["component"].String() : "";
+        
+        if( inputInfo.color.empty() || inputInfo.component.empty() ) {
+	        LOGERR("%s : Color/Component param not found!!!\n",__FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (isPlatformSupport("CMS") != 0) {
+            returnResponse(false);
+        }
+
+
+        if (parsingGetInputArgument(parameters, "CMS", inputInfo) != 0) {
+            LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (getParamIndex("CMS",inputInfo,indexInfo) == -1) {
+            LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if ( convertCMSParamToPQEnum(inputInfo.component,inputInfo.color,tvPQEnum) != 0 ) {
+            LOGINFO("%s: Component/Color Param Not Found \n",__FUNCTION__);
+            returnResponse(false);
+        }
+
+        int err = getLocalparam("CMS",indexInfo,level,tvPQEnum);
+        if( err == 0 ) {
+            response["level"] = level;
+            LOGINFO("Exit : params Value: %d \n", level);
+            returnResponse(true);
+        }
+        else {
+            returnResponse(false);
+        }
+    }
+
+    uint32_t AVOutputTV::setCMS(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+
+        capDetails_t inputInfo;
+        int level = 0,retVal = 0;
+        tvPQParameterIndex_t tvPQEnum;
+        tvDataComponentColor_t colorEnum=tvDataColor_NONE;
+        std::string color,component;
+        tvError_t ret = tvERROR_NONE;
+        std::string value;
+
+        inputInfo.color = parameters.HasLabel("color") ? parameters["color"].String() : "";
+	    inputInfo.component = parameters.HasLabel("component") ? parameters["component"].String() : "";
+
+        if( inputInfo.color.empty() || inputInfo.component.empty() ) {
+            LOGERR("%s : Color/Component param not found!!!\n",__FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (isPlatformSupport("CMS") != 0) {
+            returnResponse(false);
+        }
+
+        value = parameters.HasLabel("level") ? parameters["level"].String() : "";
+        returnIfParamNotFound(parameters,"level");
+        level = std::stoi(value);
+
+        if (validateCMSParameter(inputInfo.component,level) != 0) {
+            LOGERR("%s: CMS Failed in range validation", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (parsingSetInputArgument(parameters,"CMS",inputInfo) != 0) {
+            LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if( !isCapablityCheckPassed( "CMS",inputInfo )) {
+            LOGERR("%s: CapablityCheck failed for CMS\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if ( convertCMSParamToPQEnum(inputInfo.component,inputInfo.color,tvPQEnum) != 0 ) {
+            LOGERR("%s: %s/%s Param Not Found \n",__FUNCTION__,inputInfo.component.c_str(),inputInfo.color.c_str());
+            returnResponse(false);
+        }    
+
+        retVal = getCMSColorEnumFromString(inputInfo.color,colorEnum);
+        if( retVal == -1) {
+            LOGERR("%s: Invalid Color : %s\n",__FUNCTION__,inputInfo.color.c_str());
+            returnResponse(false);
+        }
+
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
+            LOGINFO("Proceed with %s\n",__FUNCTION__);
+            tvError_t ret = SetCMSState(true);
+            if(ret != tvERROR_NONE) {
+                LOGWARN("CMS enable failed\n");
+                returnResponse(false);
+            }
+            
+            if(inputInfo.component.compare("Saturation") == 0)
+                ret = SetCurrentComponentSaturation(colorEnum, level);
+            else if(inputInfo.component.compare("Hue") == 0 )
+                ret = SetCurrentComponentHue(colorEnum,level);
+            else if( inputInfo.component.compare("Luma") == 0 )
+                ret = SetCurrentComponentLuma(colorEnum,level);
+        
+        }      
+
+        if(ret != tvERROR_NONE) {
+            LOGERR("Failed to set CMS\n");
+            returnResponse(false);
+        }
+        else  {
+            std::string cmsParam;                   
+            cmsParam = inputInfo.color+"."+inputInfo.component;
+            
+            retVal= updateAVoutputTVParam("set","CMS",inputInfo,tvPQEnum,level);
+            if(retVal != 0 ) {
+                LOGERR("%s : Failed to Save CMS %s/%s(%s) to ssm_data\n",__FUNCTION__,inputInfo.component.c_str(),inputInfo.color.c_str(),cmsParam.c_str());
+                returnResponse(false);
+            }
+            LOGINFO("Exit : setCMS %s/%s successful to value: %d\n", inputInfo.component.c_str(),inputInfo.color.c_str(),level);
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::resetCMS(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+
+        capDetails_t inputInfo;
+        int retVal = 0;
+        std::string color,component;
+        tvError_t ret = tvERROR_NONE;
+        JsonArray sourceArray;
+        JsonArray pqmodeArray;
+        JsonArray formatArray;
+        JsonArray colorArray;
+        JsonArray componentArray;
+
+        if (isPlatformSupport("CMS") != 0) {
+            returnResponse(false);
+        }
+
+        pqmodeArray = parameters.HasLabel("pictureMode") ? parameters["pictureMode"].Array() : JsonArray();
+        for (int i = 0; i < pqmodeArray.Length(); ++i) {
+            inputInfo.pqmode += pqmodeArray[i].String();
+            if (i != (pqmodeArray.Length() - 1) ) {
+                inputInfo.pqmode += ",";
+            }
+        }
+
+        sourceArray = parameters.HasLabel("videoSource") ? parameters["videoSource"].Array() : JsonArray();
+        for (int i = 0; i < sourceArray.Length(); ++i) {
+            inputInfo.source += sourceArray[i].String();
+            if (i != (sourceArray.Length() - 1) ) {
+                inputInfo.source += ",";
+	        }
+        }
+
+        formatArray = parameters.HasLabel("videoFormat") ? parameters["videoFormat"].Array() : JsonArray();
+        for (int i = 0; i < formatArray.Length(); ++i) {
+            inputInfo.format += formatArray[i].String();
+            if (i != (formatArray.Length() - 1) ) {
+                inputInfo.format += ",";
+            }
+        }
+        colorArray = parameters.HasLabel("color") ? parameters["color"].Array() : JsonArray();
+        for (int i = 0; i < colorArray.Length(); ++i) {
+            inputInfo.color += colorArray[i].String();
+            if (i != (colorArray.Length() - 1) ) {
+                inputInfo.color += ",";
+            }
+        }
+        componentArray = parameters.HasLabel("component") ? parameters["component"].Array() : JsonArray();
+        for (int i = 0; i < componentArray.Length(); ++i) {
+            inputInfo.component += componentArray[i].String();
+            if (i != (componentArray.Length() - 1) ) {
+                inputInfo.component += ",";
+            }
+        }
+        if (inputInfo.source.empty()) {
+            inputInfo.source = "Global";
+	    }
+        if (inputInfo.pqmode.empty()) {
+            inputInfo.pqmode = "Global";
+	    }
+        if (inputInfo.format.empty()) {
+            inputInfo.format = "Global";
+	    }
+        if (inputInfo.color.empty()) {
+            inputInfo.color = "Global";
+	    }
+        if (inputInfo.component.empty()) {
+            inputInfo.component = "Global";
+	    }
+
+        if (convertToValidInputParameter("CMS", inputInfo) != 0) {
+            LOGERR("%s: Failed to convert the input paramters. \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if( !isCapablityCheckPassed( "CMS" , inputInfo )) {
+            LOGERR("%s: CapablityCheck failed for CMS\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
+            LOGINFO("Proceed with %s\n",__FUNCTION__);
+            tvError_t ret = SetCMSState(false);
+            if(ret != tvERROR_NONE) {
+                LOGWARN("CMS disable failed\n");
+                returnResponse(false);
+            } 
+        }      
+
+        if(ret != tvERROR_NONE) {
+            LOGERR("%s : Failed to setCMSState\n",__FUNCTION__);
+            returnResponse(false);
+        }
+        else  {
+            int cms = 0;
+            retVal= updateAVoutputTVParam("reset","CMS",inputInfo,PQ_PARAM_CMS_SATURATION_RED,cms);
+            if(retVal != 0 ) {
+                LOGERR("%s : Failed to Save CMS %s/%s to ssm_data\n",__FUNCTION__,inputInfo.component.c_str(),inputInfo.color.c_str() );
+                returnResponse(false);
+            }
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::getCMSCaps(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry");
+        capVectors_t info;
+
+        JsonArray rangeArray;
+        JsonArray pqmodeArray;
+        JsonArray formatArray;
+        JsonArray sourceArray;
+        JsonArray colorArray;
+        JsonArray componentArray;
+
+        JsonObject componentSaturationRangeInfo;
+        JsonObject componentHueRangeInfo;
+        JsonObject componentLumaRangeInfo;
+        unsigned int index = 0;
+
+        tvError_t ret = getParamsCaps("CMS",info);
+
+        if(ret != tvERROR_NONE) {
+            returnResponse(false);
+        }
+        else {
+
+            response["platformSupport"] = (info.isPlatformSupportVector[0].compare("true") == 0)  ? true : false;
+
+            componentSaturationRangeInfo["from"] = stoi(info.rangeVector[0]);
+            componentSaturationRangeInfo["to"]   = stoi(info.rangeVector[1]);
+            response["componentSaturationRangeInfo"]=componentSaturationRangeInfo;
+            
+            componentHueRangeInfo["from"] = stoi(info.rangeVector[2]);
+            componentHueRangeInfo["to"]   = stoi(info.rangeVector[3]);
+            response["componentHueRangeInfo"]=componentHueRangeInfo;
+
+            componentLumaRangeInfo["from"] = stoi(info.rangeVector[4]);
+            componentLumaRangeInfo["to"]   = stoi(info.rangeVector[5]);
+            response["componentLumaRangeInfo"]=componentLumaRangeInfo;
+
+
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
+                }
+                response["pictureModeInfo"]=pqmodeArray;
+            }
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
+                }
+                response["videoSourceInfo"]=sourceArray;
+            }
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
+                }
+                response["videoFormatInfo"]=formatArray;
+            }
+
+            if ((info.colorVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.colorVector.size(); index++) {
+                    colorArray.Add(info.colorVector[index]);
+                }
+                response["colorInfo"]=colorArray;
+            }
+
+            if ((info.componentVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.componentVector.size(); index++) {
+                    componentArray.Add(info.componentVector[index]);
+                }
+                response["componentInfo"]=componentArray;
+            }
+
+            LOGINFO("Exit\n");
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::getHDRMode(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry");
+        capDetails_t inputInfo;
+        int dolbyMode = 0;
+        int err = 0;
+        paramIndex_t indexInfo;
+
+        if (parsingGetInputArgument(parameters, "HDRMode", inputInfo) != 0) {
+            LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (isPlatformSupport("HDRMode") != 0) {
+            returnResponse(false);
+        }
+
+        if (getParamIndex("HDRMode",inputInfo,indexInfo) == -1) {
+            LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        err = getLocalparam("HDRMode", indexInfo,dolbyMode, PQ_PARAM_DOLBY_MODE);
+        if( err == 0 ) {
+            response["hdrMode"] = getDolbyModeStringFromEnum((tvDolbyMode_t)dolbyMode);
+            LOGINFO("Exit : hdrMode Value: %d \n", dolbyMode);
+            returnResponse(true);
+        }
+        else {
+            returnResponse(false);
+        }
+
+    }
+
+    uint32_t AVOutputTV::setHDRMode(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+        tvDolbyMode_t index;
+        capDetails_t inputInfo;
+        tvError_t ret  = tvERROR_NONE;
+        std::string value;
+	int retval = 0;
+
+        value = parameters.HasLabel("HDRMode") ? parameters["HDRMode"].String() : "";
+        returnIfParamNotFound(parameters,"HDRMode");
+
+        if (parsingSetInputArgument(parameters, "HDRMode", inputInfo) != 0) {
+            LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (isPlatformSupport("HDRMode") != 0) {
+            returnResponse(false);
+        }
+
+        if (validateInputParameter("HDRMode",value) != 0) {
+            LOGERR("%s: Range validation failed for hdrMode\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if( !isCapablityCheckPassed( "HDRMode", inputInfo )) {
+            LOGERR("%s: CapablityCheck failed for hdrMode\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if( isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format) ) {
+            LOGINFO("Proceed with HDRMode\n\n");
+            retval = getHDRModeIndex(value,inputInfo.format,index);
+            if( retval != 0 )
+            {
+                LOGERR("Failed to getHDRMode index\n");
+                returnResponse(false);
+            }
+            ret = SetTVDolbyVisionMode(index);
+        }
+
+        if(ret != tvERROR_NONE) {
+            LOGERR("Failed to set HDRMode\n\n");
+            returnResponse(false);
+        }
+        else {
+            retval= updateAVoutputTVParam("set","HDRMode",inputInfo,PQ_PARAM_DOLBY_MODE,(int)index);
+            if(retval != 0 ) {
+                LOGERR("Failed to Save hdrMode mode\n");
+                returnResponse(false);
+            }
+            LOGINFO("Exit : hdrMode successful to value: %s\n", value.c_str());
+            returnResponse(true);
+        }
+
+    }
+
+    uint32_t AVOutputTV::resetHDRMode(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int dolbyMode=0;
+        tvError_t ret = tvERROR_NONE;
+
+        if (parsingSetInputArgument(parameters, "HDRMode", inputInfo) != 0) {
+            LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (isPlatformSupport("HDRMode") != 0) {
+            returnResponse(false);
+        }
+
+        if( !isCapablityCheckPassed( "HDRMode" , inputInfo )) {
+            LOGERR("%s: CapablityCheck failed for HDRMode\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        int retval= updateAVoutputTVParam("reset","HDRMode",inputInfo,PQ_PARAM_DOLBY_MODE,dolbyMode);
+        if(retval != 0 ) {
+            LOGERR("Failed to reset HDRMode\n");
+            returnResponse(false);
+        }
+        else {
+            if (isSetRequired( inputInfo.pqmode,inputInfo.source,inputInfo.format)) {
+                getParamIndex( "HDRMode", inputInfo,indexInfo);
+                int err = getLocalparam("HDRMode", indexInfo, dolbyMode, PQ_PARAM_DOLBY_MODE);
+                if( err == 0 ) {
+                    LOGINFO("%s : getLocalparam success format :%d source : %d format : %d dolbyvalue : %d\n",__FUNCTION__,indexInfo.formatIndex, indexInfo.sourceIndex, indexInfo.pqmodeIndex, dolbyMode);
+                    ret = SetTVDolbyVisionMode((tvDolbyMode_t)dolbyMode);
+                }
+                else {
+                    LOGERR("%s : GetLocalParam Failed \n",__FUNCTION__);
+                    ret = tvERROR_GENERAL;
+                }
+            }
+        }
+
+        if(ret != tvERROR_NONE) {
+            returnResponse(false);
+        }
+        else {
+            LOGINFO("Exit : resetHDRMode Successful to value : %d \n",dolbyMode);
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::getHDRModeCaps(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry");
+        capVectors_t info;
+
+        JsonArray rangeArray;
+        JsonArray pqmodeArray;
+        JsonArray formatArray;
+        JsonArray sourceArray;
+
+        unsigned int index = 0;
+
+        tvError_t ret = getParamsCaps("HDRMode", info);
+
+        if(ret != tvERROR_NONE) {
+            returnResponse(false);
+        }
+        else {
+
+            response["platformSupport"] = (info.isPlatformSupportVector[0].compare("true") == 0 ) ? true : false;
+
+            for (index = 0; index < info.rangeVector.size(); index++) {
+                rangeArray.Add(info.rangeVector[index]);
+            }
+
+            response["options"]=rangeArray;
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
+                }
+                response["pictureModeInfo"]=pqmodeArray;
+            }
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
+                }
+                response["videoSourceInfo"]=sourceArray;
+            }
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
+                }
+                response["videoFormatInfo"]=formatArray;
+            }
+            LOGINFO("Exit\n");
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::get2PointWB(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry");
+
+        capDetails_t inputInfo;
+        paramIndex_t indexInfo;
+        int level = 0;
+        tvPQParameterIndex_t tvPQEnum;
+
+        inputInfo.color = parameters.HasLabel("color") ? parameters["color"].String() : "";
+        inputInfo.control = parameters.HasLabel("control") ? parameters["control"].String() : "";
+
+        if( inputInfo.color.empty() || inputInfo.control.empty() ) {
+            LOGERR("%s : Color/Control param not found!!!\n",__FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (isPlatformSupport("WhiteBalance") != 0) {
+            returnResponse(false);
+        }
+
+        if (parsingGetInputArgument(parameters, "WhiteBalance", inputInfo) != 0) {
+            LOGINFO("%s: Failed to parse argument\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (getParamIndex("WhiteBalance", inputInfo,indexInfo) == -1) {
+            LOGERR("%s: getParamIndex failed to get \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if ( convertWBParamToPQEnum(inputInfo.control,inputInfo.color,tvPQEnum) != 0 ) {
+            LOGINFO("%s: Control/Color Param Not Found \n",__FUNCTION__);
+            returnResponse(false);
+        }
+
+        int err = getLocalparam("WhiteBalance",indexInfo,level, tvPQEnum);
+        if( err == 0 ) {
+            response["level"] = level;
+            LOGINFO("Exit : params Value: %d \n", level);
+            returnResponse(true);
+        }
+        else {
+            returnResponse(false);
+        }
+    }
+
+    uint32_t AVOutputTV::set2PointWB(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+
+        capDetails_t inputInfo;
+        int level = 0;
+        tvPQParameterIndex_t tvPQEnum;
+        int retVal = 0;
+        std::string color,control,value;
+        tvError_t ret = tvERROR_NONE;
+
+        inputInfo.color = parameters.HasLabel("color") ? parameters["color"].String() : "";
+        inputInfo.control = parameters.HasLabel("control") ? parameters["control"].String() : "";
+
+        if (isPlatformSupport("WhiteBalance") != 0) {
+            returnResponse(false);
+        }
+
+        if( inputInfo.color.empty() || inputInfo.control.empty()  ) {
+            LOGERR("%s : Color/Control param not found!!!\n",__FUNCTION__);
+            returnResponse(false);
+        }
+
+        value = parameters.HasLabel("level") ? parameters["level"].String() : "";
+        returnIfParamNotFound(parameters,"level");
+        level = std::stoi(value);
+
+        if (validateWBParameter("WhiteBalance",inputInfo.control,level) != 0) {
+            LOGERR("%s: CMS Failed in range validation", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if (parsingSetInputArgument(parameters,"WhiteBalance",inputInfo) != 0) {
+            LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if( !isCapablityCheckPassed( "WhiteBalance",inputInfo )) {
+            LOGERR("%s: CapablityCheck failed for WhiteBalance\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if ( convertWBParamToPQEnum(inputInfo.control,inputInfo.color,tvPQEnum) != 0 ) {
+            LOGERR("%s: %s/%s Param Not Found \n",__FUNCTION__,inputInfo.component.c_str(),inputInfo.color.c_str());
+            returnResponse(false);
+        }    
+
+        if( (isSetRequired(inputInfo.pqmode,inputInfo.source,inputInfo.format))) {
+            LOGINFO("Proceed with %s\n",__FUNCTION__);
+
+            tvVideoSrcType_t currentSource = VIDEO_SOURCE_IP;
+            tvError_t ret = GetCurrentVideoSource(&currentSource);
+
+            if(ret != tvERROR_NONE) {
+                LOGWARN("%s: GetCurrentVideoSource( ) Failed \n",__FUNCTION__);
+                return -1;
+            }
+    
+            tvWBColor_t colorLevel;
+            if ( getWBColorEnumFromString(inputInfo.color,colorLevel ) == -1 ) {
+                LOGERR("%s : GetColorEnumFromString Failed!!! ",__FUNCTION__);
+                return -1;
+            }
+	
+            tvWBControl_t controlLevel;
+            if ( getWBControlEnumFromString(inputInfo.control,controlLevel ) == -1 ) {
+                LOGERR("%s : GetComponentEnumFromString Failed!!! ",__FUNCTION__);
+                return -1;
+            }
+             
+            ret = SetCustom2PointWhiteBalance(colorLevel,controlLevel,level);
+        }       
+
+        if(ret != tvERROR_NONE) {
+            LOGERR("%s: Failed to set WhiteBalance\n",__FUNCTION__);
+            returnResponse(false);
+        }
+        else  {
+            retVal= updateAVoutputTVParam("set","WhiteBalance",inputInfo,tvPQEnum,level);
+            if(retVal != 0 ) {
+                LOGERR("%s : Failed to Save WB %s/%s : %d to ssm_data\n",__FUNCTION__,inputInfo.control.c_str(),inputInfo.color.c_str(),level);
+                returnResponse(false);
+            }
+            LOGINFO("Exit : set2PointWB %s/%s successful to value: %d\n", inputInfo.control.c_str(),inputInfo.color.c_str(),level);
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::reset2PointWB(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+
+        capDetails_t inputInfo;
+        tvPQParameterIndex_t tvPQEnum;
+        int retVal = 0;
+        int level = 0;
+        std::string color,control;
+        inputInfo.color = parameters.HasLabel("color") ? parameters["color"].String() : "";
+        inputInfo.control = parameters.HasLabel("control") ? parameters["control"].String() : "";
+
+        if (isPlatformSupport("WhiteBalance") != 0) {
+            returnResponse(false);
+        }
+
+        if (parsingSetInputArgument(parameters,"WhiteBalance",inputInfo) != 0) {
+            LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if( !isCapablityCheckPassed( "WhiteBalance",inputInfo )) {
+            LOGERR("%s: CapablityCheck failed for WhiteBalance\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        for( int colorIndex= tvWB_COLOR_RED; colorIndex < tvWB_COLOR_MAX; colorIndex++)  {
+            for(int controlIndex = tvWB_CONTROL_GAIN;controlIndex < tvWB_CONTROL_MAX;controlIndex++) {
+                inputInfo.control = getWBControlStringFromEnum((tvWBControl_t)controlIndex);
+                inputInfo.color   = getWBColorStringFromEnum((tvWBColor_t)colorIndex);
+                if ( convertWBParamToPQEnum(inputInfo.control,inputInfo.color,tvPQEnum) != 0 ) {
+                    LOGERR("%s: %s/%s Param Not Found \n",__FUNCTION__,inputInfo.control.c_str(),inputInfo.color.c_str());
+                    returnResponse(false);
+                }    
+
+                retVal |= updateAVoutputTVParam("reset","WhiteBalance",inputInfo,tvPQEnum,level);
+            }
+        }
+
+        if( retVal != 0 ) {
+            LOGWARN("Failed to reset WhiteBalance\n");
+            returnResponse(false);
+        }
+        else {        
+            LOGINFO("Exit : reset2PointWB successful \n");
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::get2PointWBCaps(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+        capVectors_t info;
+
+        JsonArray rangeArray;
+        JsonArray pqmodeArray;
+        JsonArray formatArray;
+        JsonArray sourceArray;
+        JsonArray colorArray;
+        JsonArray controlArray;
+
+        JsonObject gainInfo;
+        JsonObject offsetInfo;
+
+        unsigned int index = 0;
+
+        tvError_t ret = getParamsCaps("WhiteBalance",info);
+
+        if(ret != tvERROR_NONE) {
+            returnResponse(false);
+        }
+        else {
+            response["platformSupport"] = (info.isPlatformSupportVector[0].compare("true") == 0)  ? true : false;
+
+            gainInfo["from"] = stoi(info.rangeVector[0]);
+            gainInfo["to"]   = stoi(info.rangeVector[1]);
+            response["gainInfo"]=gainInfo;
+
+            offsetInfo["from"] = stoi(info.rangeVector[0]);
+            offsetInfo["to"]   = stoi(info.rangeVector[1]);
+            response["offsetInfo"]=offsetInfo;
+            
+            
+
+            if ((info.pqmodeVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
+                }
+                response["pictureModeInfo"]=pqmodeArray;
+            }
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
+                }
+                response["videoSourceInfo"]=sourceArray;
+            }
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
+                }
+                response["videoFormatInfo"]=formatArray;
+            }
+
+            if ((info.colorVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.colorVector.size(); index++) {
+                    colorArray.Add(info.colorVector[index]);
+                }
+                response["colorInfo"]=colorArray;
+            }
+
+            if ((info.controlVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.controlVector.size(); index++) {
+                    controlArray.Add(info.controlVector[index]);
+                }
+                response["controlInfo"]=controlArray;
+            }
+
+            LOGINFO("Exit\n");
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::getAutoBacklightModeCaps(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry");
+        capVectors_t info;
+
+        JsonArray rangeArray;
+        JsonArray pqmodeArray;
+        JsonArray formatArray;
+        JsonArray sourceArray;
+
+        unsigned int index = 0;
+
+        tvError_t ret = getParamsCaps("AutoBacklightMode",info);
+
+        if(ret != tvERROR_NONE) {
+            returnResponse(false);
+        }
+        else {
+
+            response["platformSupport"] = (info.isPlatformSupportVector[0].compare("true") == 0 ) ? true : false;
+
+            for (index = 0; index < info.rangeVector.size(); index++) {
+                rangeArray.Add(info.rangeVector[index]);
+            }
+
+            response["options"]=rangeArray;
+
+            if (info.pqmodeVector.front().compare("none") != 0) {
+                for (index = 0; index < info.pqmodeVector.size(); index++) {
+                    pqmodeArray.Add(info.pqmodeVector[index]);
+                }
+                response["pictureModeInfo"]=pqmodeArray;
+            }
+            if ((info.sourceVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.sourceVector.size(); index++) {
+                    sourceArray.Add(info.sourceVector[index]);
+                }
+                response["videoSourceInfo"]=sourceArray;
+            }
+            if ((info.formatVector.front()).compare("none") != 0) {
+                for (index = 0; index < info.formatVector.size(); index++) {
+                    formatArray.Add(info.formatVector[index]);
+                }
+                response["videoFormatInfo"]=formatArray;
+            }
+            LOGINFO("Exit\n");
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::setAutoBacklightMode(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+        std::string value;
+        tvBacklightMode_t mode = tvBacklightMode_AMBIENT;
+        capDetails_t inputInfo;
+
+
+        value = parameters.HasLabel("mode") ? parameters["mode"].String() : "";
+        returnIfParamNotFound(parameters,"mode");
+
+        if (validateInputParameter("AutoBacklightMode",value) != 0) {
+            LOGERR("%s: Range validation failed for AutoBacklightMode\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+	if (isPlatformSupport("AutoBacklightMode") != 0) {
+            returnResponse(false);
+        }
+
+        if (parsingSetInputArgument(parameters,"AutoBacklightMode",inputInfo) != 0) {
+            LOGERR("%s: Failed to parse the input arguments \n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+	if( !isCapablityCheckPassed( "AutoBacklightMode",inputInfo )) {
+            LOGERR("%s: CapablityCheck failed for AutoBacklightMode\n", __FUNCTION__);
+            returnResponse(false);
+        }
+
+        if(!value.compare("Manual")) {
+            mode = tvBacklightMode_MANUAL;
+        }
+        else if (!value.compare("Ambient")) {
+            mode = tvBacklightMode_AMBIENT;
+        }
+        else {
+            returnResponse(false);
+        }
+        
+        tvError_t ret = SetCurrentBacklightMode (mode);
+
+        if(ret != tvERROR_NONE) {
+            returnResponse(false);
+        }
+        else {
+            //Save AutoBacklightMode to localstore
+
+            tr181ErrorCode_t err = setLocalParam(rfc_caller_id, AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM, value.c_str());
+            if ( err != tr181Success ) {
+                LOGERR("setLocalParam for %s Failed : %s\n", AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM, getTR181ErrorString(err));
+                returnResponse(false);
+            }
+            else {
+                LOGINFO("setLocalParam for %s Successful, Value: %s\n", AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM, value.c_str());
+            }
+            LOGINFO("Exit : SetAutoBacklightMode() value : %s\n",value.c_str());
+            returnResponse(true);
+        }
+    }
+
+    uint32_t AVOutputTV::getAutoBacklightMode(const JsonObject& parameters, JsonObject& response)
+    {
+
+        TR181_ParamData_t param;
+
+        if (isPlatformSupport("AutoBacklightMode") != 0) {
+            returnResponse(false);
+        }
+
+        tr181ErrorCode_t err = getLocalParam(rfc_caller_id, AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM, &param);
+        if (err!= tr181Success) {
+            returnResponse(false);
+        }
+        else {
+            std::string s;
+            s+=param.value;
+            response["mode"] = s;
+            LOGINFO("Exit getAutoBacklightMode(): %s\n",s.c_str());
+            returnResponse(true);
+        }
+    
+    }
+
+    uint32_t AVOutputTV::resetAutoBacklightMode(const JsonObject& parameters, JsonObject& response)
+    {
+        LOGINFO("Entry\n");
+
+        tvError_t ret = tvERROR_NONE;
+
+	if (isPlatformSupport("AutoBacklightMode") != 0) {
+            returnResponse(false);
+        }
+
+        tr181ErrorCode_t err = clearLocalParam(rfc_caller_id,AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM);
+        if ( err != tr181Success ) {
+            LOGWARN("clearLocalParam for %s Failed : %s\n", AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM, getTR181ErrorString(err));
+            ret  = tvERROR_GENERAL;
+        }
+        else {
+            LOGINFO("clearLocalParam for %s Successful\n", AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM);
+
+            TR181_ParamData_t param;
+            memset(&param, 0, sizeof(param));
+
+            tr181ErrorCode_t err = getLocalParam(rfc_caller_id, AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM,&param);
+            if ( err != tr181Success ) {
+                LOGWARN("getLocalParam for %s Failed : %s\n", AVOUTPUT_AUTO_BACKLIGHT_MODE_RFC_PARAM, getTR181ErrorString(err));
+                ret  = tvERROR_GENERAL;
+            }
+            else {
+                tvBacklightMode_t blMode = tvBacklightMode_NONE;
+
+                if(!std::string(param.value).compare("none")) {
+                    blMode = tvBacklightMode_NONE;
+                }
+                else if (!std::string(param.value).compare("Manual")){
+                    blMode = tvBacklightMode_MANUAL;
+                }
+                else if (!std::string(param.value).compare("Ambient")){
+                    blMode = tvBacklightMode_AMBIENT;
+                }
+                else if (!std::string(param.value).compare("Eco")){
+                    blMode = tvBacklightMode_ECO;
+                }
+                else {
+                    blMode = tvBacklightMode_NONE;
+                }
+                ret = SetCurrentBacklightMode(blMode);
+                if(ret != tvERROR_NONE) {
+                    LOGWARN("Autobacklight Mode set failed: %s\n",getErrorString(ret).c_str());
+                }
+                else {
+                    LOGINFO("Exit : Autobacklight Mode set successfully, value: %s\n", param.value);
+                }
+            } 
+        }
+        if(ret != tvERROR_NONE)
+        {
+            returnResponse(false);
+        }
+        else
+        {
+            returnResponse(true);
+        }
+    }    
+
     uint32_t AVOutputTV::getVideoSource(const JsonObject& parameters,JsonObject& response)
     {
         LOGINFO("Entry\n");
diff --git a/AVOutput/AVOutputTV.h b/AVOutput/AVOutputTV.h
index 0c39065..5e49306 100644
--- a/AVOutput/AVOutputTV.h
+++ b/AVOutput/AVOutputTV.h
@@ -68,6 +68,10 @@
 #define STRING_FORMAT  "Format."
 #define STRING_DEFAULT  "Default"
 #define STRING_SOURCE    "Source."
+#define STRING_COMPONENT    "Component."
+#define STRING_COLOR    "Color."
+#define STRING_CONTROL   "Control."
+#define STRING_COLORTEMPERATURE   "ColorTemperature."
 #define CREATE_DIRTY(__X__) (__X__+=STRING_DIRTY)
 #define CAPABLITY_FILE_NAME    "pq_capabilities.ini"
 
@@ -116,6 +120,61 @@ public:
 namespace WPEFramework {
 namespace Plugin {
 
+typedef struct
+{
+    std::string range;
+    std::string pqmode;
+    std::string format;
+    std::string source;
+    std::string isPlatformSupport;
+    std::string index;
+    std::string color;
+    std::string component;
+    std::string colorTemperature;
+    std::string control;
+}capDetails_t;
+
+typedef struct
+{
+    std::vector<std::string> rangeVector;
+    std::vector<std::string> pqmodeVector;
+    std::vector<std::string> formatVector;
+    std::vector<std::string> sourceVector;
+    std::vector<std::string> isPlatformSupportVector;
+    std::vector<std::string> indexVector;
+    std::vector<std::string> colorVector;
+    std::vector<std::string> componentVector;
+    std::vector<std::string> colorTempVector;
+    std::vector<std::string> controlVector;
+}capVectors_t;
+
+
+typedef struct
+{
+    std::vector<int> rangeValues;
+    std::vector<int> pqmodeValues;
+    std::vector<int> formatValues;
+    std::vector<int> sourceValues;
+    std::vector<int> isPlatformSupportValues;
+    std::vector<int> indexValues;
+    std::vector<int> colorValues;
+    std::vector<int> componentValues;
+    std::vector<int> colorTempValues;
+    std::vector<int> controlValues;
+}valueVectors_t;
+
+typedef struct
+{
+    uint8_t sourceIndex;
+    uint8_t pqmodeIndex;
+    uint8_t formatIndex;
+    uint8_t colorIndex;
+    uint8_t componentIndex;
+    uint8_t colorTempIndex;
+    uint8_t controlIndex;
+}paramIndex_t;
+
+
 //class AVOutputTV : public PluginHost::IPlugin, public PluginHost::JSONRPC {
 class AVOutputTV : public AVOutputBase {
     private:
@@ -142,6 +201,10 @@ class AVOutputTV : public AVOutputBase {
 		DECLARE_JSON_RPC_METHOD(getLowLatencyState)
 		DECLARE_JSON_RPC_METHOD(getZoomMode)
 		DECLARE_JSON_RPC_METHOD(getVideoContentType)
+		DECLARE_JSON_RPC_METHOD(getCMS)
+		DECLARE_JSON_RPC_METHOD(getHDRMode)
+		DECLARE_JSON_RPC_METHOD(get2PointWB)
+		DECLARE_JSON_RPC_METHOD(getAutoBacklightMode)
 
 
 		/*Get Capability API's*/
@@ -161,6 +224,10 @@ class AVOutputTV : public AVOutputBase {
 		DECLARE_JSON_RPC_METHOD(getVideoResolutionCaps)
 		DECLARE_JSON_RPC_METHOD(getLowLatencyStateCaps)
 		DECLARE_JSON_RPC_METHOD(getZoomModeCaps)
+		DECLARE_JSON_RPC_METHOD(getCMSCaps)
+		DECLARE_JSON_RPC_METHOD(get2PointWBCaps)
+		DECLARE_JSON_RPC_METHOD(getHDRModeCaps)
+		DECLARE_JSON_RPC_METHOD(getAutoBacklightModeCaps)
 
 		/*Set API's*/
 		DECLARE_JSON_RPC_METHOD(setBacklight)
@@ -176,7 +243,11 @@ class AVOutputTV : public AVOutputBase {
 		DECLARE_JSON_RPC_METHOD(setLowLatencyState)
 		DECLARE_JSON_RPC_METHOD(setZoomMode)
 		DECLARE_JSON_RPC_METHOD(setWBCtrl )
-		DECLARE_JSON_RPC_METHOD(signalFilmMakerMode)
+		DECLARE_JSON_RPC_METHOD(setHDRMode )
+		DECLARE_JSON_RPC_METHOD(setCMS )
+		DECLARE_JSON_RPC_METHOD(set2PointWB )
+ 		DECLARE_JSON_RPC_METHOD(signalFilmMakerMode)
+		DECLARE_JSON_RPC_METHOD(setAutoBacklightMode)
 
 		/*Reset API's*/
 		DECLARE_JSON_RPC_METHOD(resetBacklight)
@@ -191,6 +262,10 @@ class AVOutputTV : public AVOutputBase {
 		DECLARE_JSON_RPC_METHOD(resetPictureMode )
 		DECLARE_JSON_RPC_METHOD(resetLowLatencyState)
 		DECLARE_JSON_RPC_METHOD(resetZoomMode)
+		DECLARE_JSON_RPC_METHOD(resetHDRMode)
+		DECLARE_JSON_RPC_METHOD(resetCMS)
+		DECLARE_JSON_RPC_METHOD(reset2PointWB)
+		DECLARE_JSON_RPC_METHOD(resetAutoBacklightMode)
 
     private:
 
@@ -200,22 +275,26 @@ class AVOutputTV : public AVOutputBase {
 		int getSourceIndex(std::string source);
 		int getFormatIndex(std::string format);		
 		int getPqParamIndex();
-		int getParamIndex(string source,string pqmode,string format,int& sourceIndex,int& pqmodeIndex,int& formatIndex);
+		int getParamIndex(std::string param, capDetails_t& paramInfo, paramIndex_t& indexInfo);
 		int getDolbyModeIndex(const char * dolbyMode);
+		int getHDRModeIndex(const std::string HDRMode, const std::string format,tvDolbyMode_t &value);
 		tvDimmingMode_t getDimmingModeIndex(string mode);
 		
 		bool isIncluded(const std::set<string> set1,const std::set<string> set2);
 		bool isSetRequired(std::string pqmode,std::string source,std::string format);
 		int isPlatformSupport(std::string pqparam);
 		
-		void spliltCapablities( std::vector<std::string> &range,std::vector<std::string> &pqmode,std::vector<std::string> &format,std::vector<std::string> &source, std::vector<string> &index,std::string rangeInfo, std::string pqmodeInfo, std::string formatInfo, std::string sourceInfo, std::string indexInfo);
-		bool isCapablityCheckPassed( std::string pqmodeInputInfo,std::string sourceInputInfo,std::string formatInputInfo,std::string param );
-		int parsingSetInputArgument(const JsonObject& parameters, std::string pqparam,std::string & source, std::string & pqmode, std::string & format);
-		int parsingGetInputArgument(const JsonObject& parameters, std::string pqparam,std::string & source, std::string & pqmode, std::string & format);
+	
+		bool isCapablityCheckPassed( std::string param, capDetails_t inputInfo );
+		int parsingSetInputArgument(const JsonObject& parameters, std::string pqparam,capDetails_t& paramInfo);
+		int parsingGetInputArgument(const JsonObject& parameters, std::string pqparam, capDetails_t& info);
+		void spliltCapablities( capVectors_t& vectorInfo, capDetails_t stringInfo);
 		void spliltStringsAndConvertToSet( std::string pqmodeInfo,std::string formatInfo,std::string sourceInfo,std::set<string> &pqmode, std::set<string> &format, std::set<string> &source);
 		int validateIntegerInputParameter(std::string param, int inputValue);
-		int fetchCapablities(string pqparam, string & source, string & pqmode, string & format);
+		int fetchCapablities(string pqparam, capDetails_t& info);
 		int validateInputParameter(std::string param, std::string inputValue);
+		int validateWBParameter(std::string param,std::string control,int inputValue);
+		int validateCMSParameter(std::string component,int inputValue);
 
                 /* AVoutput ini file default entries */
 		void locatePQSettingsFile(void);
@@ -225,7 +304,7 @@ class AVOutputTV : public AVOutputBase {
 
 		std::string convertToString(std::vector<std::string> vec_strings);
 		void convertParamToLowerCase(std::string &source, std::string &pqmode, std::string &format);
-		int convertToValidInputParameter(std::string pqparam, std::string & source, std::string & pqmode, std::string & format);
+		int convertToValidInputParameter(std::string pqparam, capDetails_t& info);
 		string convertSourceIndexToString(int source);
 		string convertVideoFormatToString(int format);
 		string convertPictureIndexToString(int pqmode);
@@ -235,36 +314,37 @@ class AVOutputTV : public AVOutputBase {
 		void convertUserScaleBacklightToDriverScale(int format,int * params);
 	
 	        /* Update TR181 with new values when app calls set/reset calls */	
-		tvError_t updateAVoutputTVParamToHAL(std::string forParam, int source, int pqmode, int format, int value,bool setNotDelete);
+		tvError_t updateAVoutputTVParamToHAL(std::string forParam, paramIndex_t indexInfo, int value,bool setNotDelete);
 		/* updatePQParamsToCache will call updatePQParamToLocalCache for writing to TR181.
 		 * it will call TVSettings HAL for setting/saving the value
 		 * Will be called whenever the application invokes set/reset call
 		 */
-		int updateAVoutputTVParam( std::string action, std::string tr181ParamName, std::string pqmode, std::string source, std::string format, tvPQParameterIndex_t pqParamIndex, int params[] );
+		int updateAVoutputTVParam( std::string action, std::string tr181ParamName, capDetails_t info, tvPQParameterIndex_t pqParamIndex, int level );
 
 		/* Every bootup this function is called to sync TR181 to TVSettings HAL for saving the value */
 		tvError_t syncAvoutputTVParamsToHAL(std::string pqmode, std::string source, std::string format);
 		/* Every Bootup this function is called to sync TR181 to TVSettings HAL for saving the picture mode assiocation to source */
 		int syncAvoutputTVPQModeParamsToHAL(std::string pqmode, std::string source, std::string format);
+		void syncCMSParams( );
+		void syncWBParams( );
 		
-		uint32_t generateStorageIdentifier(std::string &key, std::string forParam,int contentFormat, int pqmode, int source);
+		uint32_t generateStorageIdentifier(std::string &key, std::string forParam,paramIndex_t info);
+		uint32_t generateStorageIdentifierCMS(std::string &key, std::string forParam, paramIndex_t info);
+		uint32_t generateStorageIdentifierWB(std::string &key, std::string forParam, paramIndex_t info);
 		uint32_t generateStorageIdentifierDirty(std::string &key, std::string forParam,uint32_t contentFormat, int pqmode);
 
 		std::string getErrorString (tvError_t eReturn);
 
 		/* Get function to query TR181 entries or pq capability.ini file*/
-		int getSaveConfig(std::string pqmode, std::string source, std::string format,std::vector<int> &sources,std::vector<int> &picturemodes, std::vector<int> &formats);
-		int getLocalparam(std::string forParam,int formatIndex,int pqIndex,int sourceIndex,int &value,
-		  tvPQParameterIndex_t pqParamIndex ,bool cms=false,int tunnel_type=0);
+		int getSaveConfig(std::string param, capDetails_t capInfo, valueVectors_t &values);
+		int getLocalparam( std::string forParam,paramIndex_t indexInfo,int & value,tvPQParameterIndex_t pqParamIndex,bool sync=false);
+		
 		tvDataComponentColor_t getComponentColorEnum(std::string colorName);
 		int getDolbyParams(tvContentFormatType_t format, std::string &s, std::string source = "");
-		tvError_t getParamsCaps(std::vector<std::string> &range, std::vector<std::string> &pqmode, std::vector<std::string> &source, std::vector<std::string> &format,std::string param );
-		tvError_t getParamsCaps(std::vector<std::string> &range, std::vector<std::string> &pqmode, std::vector<std::string> &source,
-		                        std::vector<std::string> &format,std::string param , std::string & isPlatformSupport,
-				std::vector<std::string> & index);
+		tvError_t getParamsCaps(std::string param, capVectors_t &vecInfo);
 		int GetPanelID(char *panelid);
 		int ConvertHDRFormatToContentFormat(tvhdr_type_t hdrFormat);
-		int ReadCapablitiesFromConf(std::string &rangeInfo,std::string &pqmodeInfo,std::string &formatInfo,std::string &sourceInfo,std::string param, std::string & isPlatformSupport, std::string & indexInfo);
+		int ReadCapablitiesFromConf(std::string param, capDetails_t& info);
 		void getDimmingModeStringFromEnum(int value, std::string &toStore);
 		void getColorTempStringFromEnum(int value, std::string &toStore);
 		int getCurrentPictureMode(char *picMode);
@@ -273,11 +353,26 @@ class AVOutputTV : public AVOutputBase {
 		std::string getDolbyModeStringFromEnum( tvDolbyMode_t mode);
 		JsonArray getSupportedVideoSource(void);
 		int getAvailableCapabilityModesWrapper(std::string param, std::string & outparam);
-		int getAvailableCapabilityModes(std::string & source, std::string & pqmode, std::string & format);
+		int getAvailableCapabilityModes( capDetails_t& info );
 		int getCapabilitySource(JsonArray &rangeArray);
 		int getRangeCapability(std::string param, std::vector<std::string> & rangeInfo);
 		void getDynamicAutoLatencyConfig();
 		tvError_t getUserSelectedAspectRatio (tvDisplayMode_t* mode);
+		std::string  getColorTemperatureStringFromEnum(tvColorTemp_t value);
+		std::string getCMSColorStringFromEnum(tvDataComponentColor_t value);
+		std::string getCMSComponentStringFromEnum(tvComponentType_t value);
+		std::string getWBControlStringFromEnum(tvWBControl_t value);
+		int getCMSColorEnumFromString(std::string color,tvDataComponentColor_t &value);
+		int getCMSComponentEnumFromString(std::string component, tvComponentType_t& value);
+		std::string getWBColorStringFromEnum(tvWBColor_t value);
+		int getWBColorEnumFromString(std::string color,tvWBColor_t& value);
+		int getWBControlEnumFromString(std::string color,tvWBControl_t& value);
+		int getColorTempEnumFromString(std::string color, tvColorTemp_t& value);
+
+		bool checkCMSColorAndComponentCapability(const std::string capValue, const std::string inputValue);
+		int convertCMSParamToPQEnum(const std::string component, const std::string color,tvPQParameterIndex_t& value);
+		int convertWBParamToPQEnum(const std::string control, const std::string color,tvPQParameterIndex_t& value);
+		int convertWBParamToRGBEnum(const std::string color,const std::string control,tvRGBType_t &value);
 
 		void broadcastLowLatencyModeChangeEvent(bool lowLatencyMode);
 		tvError_t setAspectRatioZoomSettings(tvDisplayMode_t mode);
@@ -313,6 +408,7 @@ class AVOutputTV : public AVOutputBase {
 		void DeinitializeIARM();
 };
 
+
 }//namespace Plugin
 }//namespace WPEFramework
 #endif
diff --git a/AVOutput/AVOutputTVHelper.cpp b/AVOutput/AVOutputTVHelper.cpp
index d5536fb..7e3b28c 100644
--- a/AVOutput/AVOutputTVHelper.cpp
+++ b/AVOutput/AVOutputTVHelper.cpp
@@ -22,6 +22,8 @@
 #include "UtilsIarm.h"
 #include "rfcapi.h"
 
+#define CAPABLITY_FILE_NAME    "pq_capabilities.ini"
+
 static std::map<std::string, int> supportedSourcemap;
 static std::map<std::string, int> supportedPictureModemap;
 static std::map<std::string, int> supportedFormatmap;
@@ -104,19 +106,14 @@ namespace Plugin {
 
     int AVOutputTV::getPqParamIndex()
     {
-        std::vector<std::string> localpq;
-        std::vector<std::string> localformat;
-        std::vector<std::string> localsource;
-        std::vector<std::string> localrange;
-        std::string platformsupport;
-        std::vector<std::string> index;
-
-        tvError_t ret = getParamsCaps(localrange, localpq, localformat, localsource,
-                                          "VideoSource", platformsupport, index);
+     
+        capVectors_t info;
+
+        tvError_t ret = getParamsCaps("VideoSource", info);
         if (ret == tvERROR_NONE) {
-            if (localrange.size() == index.size()) {
-                for (unsigned int i = 0; i< localrange.size(); i++) {
-                    supportedSourcemap[localrange[i]] = stoi(index[i]);
+            if (info.rangeVector.size() == info.indexVector.size()) {
+                for (unsigned int i = 0; i< info.rangeVector.size(); i++) {
+                    supportedSourcemap[info.rangeVector[i]] = stoi(info.indexVector[i]);
                 }
             }
         }
@@ -124,28 +121,18 @@ namespace Plugin {
             LOGERR("%s: Failed to fetch the source index \n", __FUNCTION__);
             return -1;
         }
-        if (!localpq.empty()) {
-	    localpq.clear();
-	}
-        if (!localformat.empty()) {
-	    localformat.clear();
-	}
-        if (!localsource.empty()) {
-	    localsource.clear();
-	}
-        if (!localrange.empty()) {
-	    localrange.clear();
-	}
-        if(!index.empty()) {
-	    index.clear();
-	}
+      
+        info.pqmodeVector.clear();
+        info.sourceVector.clear();
+        info.formatVector.clear();
+	info.indexVector.clear();
+	info.rangeVector.clear();
 
-        ret = getParamsCaps(localrange, localpq, localformat, localsource,
-                                      "PictureMode", platformsupport, index);
+        ret = getParamsCaps("PictureMode", info);
         if (ret == tvERROR_NONE) {
-            if (localrange.size() == index.size()) {
-                for (unsigned int i = 0; i< localrange.size(); i++) {
-                    supportedPictureModemap[localrange[i]] = stoi(index[i]);
+            if (info.rangeVector.size() == info.indexVector.size()) {
+                for (unsigned int i = 0; i< info.rangeVector.size(); i++) {
+                    supportedPictureModemap[info.rangeVector[i]] = stoi(info.indexVector[i]);
                 }
             }
         }
@@ -153,28 +140,18 @@ namespace Plugin {
             LOGERR("%s: Failed to fetch the picture index \n", __FUNCTION__);
             return -1;
         }
-        if (!localpq.empty()) {
-	    localpq.clear();
-	}
-        if (!localformat.empty()) {
-	    localformat.clear();
-	}
-        if (!localsource.empty()) {
-	    localsource.clear();
-	}
-        if (!localrange.empty()) {
-	    localrange.clear();
-	}
-        if(!index.empty()) {
-	    index.clear();
-	}
+        
+        info.pqmodeVector.clear();
+        info.sourceVector.clear();
+        info.formatVector.clear();
+	info.indexVector.clear();
+        info.rangeVector.clear();
 
-        ret = getParamsCaps(localrange, localpq, localformat, localsource,
-                                      "VideoFormat", platformsupport, index);
+        ret = getParamsCaps( "VideoFormat", info);
         if (ret == tvERROR_NONE) {
-            if (localrange.size() == index.size()) {
-                for (unsigned int i = 0; i< localrange.size(); i++) {
-                    supportedFormatmap[localrange[i]] = stoi(index[i]);
+            if ( info.rangeVector.size() == info.indexVector.size()) {
+                for (unsigned int i = 0; i< info.rangeVector.size(); i++) {
+                    supportedFormatmap[info.rangeVector[i]] = stoi(info.indexVector[i]);
                 }
             }
         }
@@ -186,50 +163,101 @@ namespace Plugin {
         return 0;
     }
 
-    int AVOutputTV::getParamIndex(string source,string pqmode,string format,int& sourceIndex,int& pqmodeIndex,int& formatIndex)
+    int AVOutputTV::getParamIndex(std::string param, capDetails_t& paramInfo, paramIndex_t& indexInfo)
     {
-        LOGINFO("Entry : %s pqmode : %s source :%s format :%s\n",__FUNCTION__,pqmode.c_str(),source.c_str(),format.c_str());
+        LOGINFO("Entry : %s  param : %s pqmode : %s source :%s format :%s\n",__FUNCTION__,param.c_str(),paramInfo.pqmode.c_str(),paramInfo.source.c_str(),paramInfo.format.c_str());
 
-        if( source.compare("none") == 0 || source.compare("Current") == 0 ) {
+        if( paramInfo.source.compare("none") == 0 || paramInfo.source.compare("Current") == 0 ) {
             tvVideoSrcType_t currentSource = VIDEO_SOURCE_IP;
             GetCurrentVideoSource(&currentSource);
-            sourceIndex = (int)currentSource;
+            indexInfo.sourceIndex = (int)currentSource;
         }
         else {
-            sourceIndex = getSourceIndex(source);
+            indexInfo.sourceIndex = getSourceIndex(paramInfo.source);
         }
-        if( pqmode.compare("none") == 0 || pqmode.compare("Current") == 0) {
+        if( paramInfo.pqmode.compare("none") == 0 || paramInfo.pqmode.compare("Current") == 0) {
             char picMode[PIC_MODE_NAME_MAX]={0};
             if(!getCurrentPictureMode(picMode)) {
                 LOGERR("Failed to get the Current picture mode\n");
             }
             else {
                 std::string local = picMode;
-                pqmodeIndex = getPictureModeIndex(local);
+                indexInfo.pqmodeIndex = getPictureModeIndex(local);
             }
         }
         else {
-            pqmodeIndex = getPictureModeIndex(pqmode);
+            indexInfo.pqmodeIndex = getPictureModeIndex(paramInfo.pqmode);
         }
 
-        if( format.compare("none") == 0 || format.compare("Current") == 0) {
+        if( paramInfo.format.compare("none") == 0 || paramInfo.format.compare("Current") == 0) {
             tvVideoFormatType_t currentFormat = VIDEO_FORMAT_NONE;
             GetCurrentVideoFormat(&currentFormat);
             if( VIDEO_FORMAT_NONE == currentFormat ) {
-		formatIndex = VIDEO_FORMAT_SDR;
+                indexInfo.formatIndex = VIDEO_FORMAT_SDR;
             }
             else {
-                formatIndex = (int)currentFormat;
+                indexInfo.formatIndex = (int)currentFormat;
 	    }
         }
         else {
-            formatIndex = getFormatIndex(format);
+            indexInfo.formatIndex = getFormatIndex(paramInfo.format);
         }
 
-        if (sourceIndex == -1 || pqmodeIndex == -1 || formatIndex == -1) {
-	    return -1;
-	}
-        LOGINFO("%s: Exit sourceIndex = %d pqmodeIndex = %d formatIndex = %d\n",__FUNCTION__,sourceIndex,pqmodeIndex,formatIndex);
+        if(param == "CMS")
+        {
+            tvDataComponentColor_t level = tvDataColor_NONE;
+            if ( getCMSColorEnumFromString(paramInfo.color,level ) == -1 ) {
+                LOGERR("%s : GetColorEnumFromString Failed!!! ",__FUNCTION__);
+                return -1;
+            }
+
+            indexInfo.colorIndex = level;
+
+            tvComponentType_t componentLevel;
+            if ( getCMSComponentEnumFromString(paramInfo.component,componentLevel ) == -1 ) {
+                LOGERR("%s : GetComponentEnumFromString Failed!!! ",__FUNCTION__);
+                return -1;
+            }
+
+            indexInfo.componentIndex = componentLevel;
+
+            LOGINFO("%s colorIndex : %d , componentIndex : %d\n",__FUNCTION__,indexInfo.colorIndex, indexInfo.componentIndex);
+        }
+
+        if(param == "WhiteBalance")
+        {
+            tvWBColor_t level;
+            if ( getWBColorEnumFromString(paramInfo.color,level ) == -1 ) {
+                LOGERR("%s : GetColorEnumFromString Failed!!! ",__FUNCTION__);
+                return -1;
+            }
+
+            indexInfo.colorIndex = level;
+
+            tvWBControl_t controlLevel;
+            if ( getWBControlEnumFromString(paramInfo.control,controlLevel ) == -1 ) {
+                LOGERR("%s : GetComponentEnumFromString Failed!!! ",__FUNCTION__);
+                return -1;
+            }
+
+            indexInfo.controlIndex = controlLevel;
+
+            /*tvColorTemp_t colorTemp;
+            if ( getColorTempEnumFromString(paramInfo.colorTemperature,colorTemp ) == -1 ) {
+                LOGERR("%s : GetComponentEnumFromString Failed!!! ",__FUNCTION__);
+                return -1;
+            }
+
+            indexInfo.colorTempIndex = colorTemp; */
+
+            LOGINFO("%s colorIndex : %d , controlIndex : %d \n",__FUNCTION__,indexInfo.colorIndex, indexInfo.controlIndex);
+
+        }
+
+        if (indexInfo.sourceIndex == -1 || indexInfo.pqmodeIndex == -1 || indexInfo.formatIndex == -1) {
+	        return -1;
+    	}
+        LOGINFO("%s: Exit sourceIndex = %d pqmodeIndex = %d formatIndex = %d\n",__FUNCTION__,indexInfo.sourceIndex,indexInfo.pqmodeIndex,indexInfo.formatIndex);
 
         return 0;
     }
@@ -251,16 +279,44 @@ namespace Plugin {
                     mode = dolbyModes[count];
                     break;
                 }
-
             }
         } else {
             mode = -1;
             printf("(%s):get supported mode is failed\n", __func__);
         }
-
         return mode;
     }
 
+    int AVOutputTV::getHDRModeIndex(const std::string HDRMode, const std::string format,tvDolbyMode_t &value) {
+        // Create a map to associate format-mode pairs with enum values
+        int ret = 0;
+        static const std::unordered_map<std::string, tvDolbyMode_t> hdrModeIndexMap = {
+	    {"DVDark", tvDolbyMode_Dark},
+            {"DVBright", tvDolbyMode_Bright},
+            {"DVGame", tvDolbyMode_Game},
+            {"HDR10Dark", tvHDR10Mode_Dark},
+            {"HDR10Bright", tvHDR10Mode_Bright},
+            {"HDR10Game", tvHDR10Mode_Game},
+            {"HLGDark", tvHLGMode_Dark},
+            {"HLGBright", tvHLGMode_Bright},
+            {"HLGGame", tvHLGMode_Game}
+        };
+
+        // Create the key by concatenating the format and HDRMode
+        std::string key = format+HDRMode;
+
+        // Look up the key in the map
+        auto it = hdrModeIndexMap.find(key);
+        if (it != hdrModeIndexMap.end()) {
+            value = it->second;
+            ret = 0;
+        } else {
+            LOGERR("%s : Invalid format/mode\n",__FUNCTION__);
+            ret = -1;
+        }
+        return ret;
+    }
+
     tvDimmingMode_t AVOutputTV::getDimmingModeIndex(std::string mode)
     {
         tvDimmingMode_t index = tvDimmingMode_MAX;
@@ -337,21 +393,16 @@ namespace Plugin {
 
     int AVOutputTV::isPlatformSupport(std::string pqparam)
     {
-        std::vector<std::string> range;
-        std::vector<std::string> sourceVec;
-        std::vector<std::string> pqmodeVec;
-        std::vector<std::string> formatVec;
-        std::string isPlatformSupport;
-        std::vector<std::string> index;
+        capVectors_t vectorInfo;
 
-        tvError_t ret = getParamsCaps(range, pqmodeVec, sourceVec, formatVec, pqparam, isPlatformSupport, index);
+        tvError_t ret = getParamsCaps(pqparam,vectorInfo);
 
         if (ret != tvERROR_NONE) {
            LOGINFO("%s: failed to get the capability \n", __FUNCTION__);
            return -1;
         }
         else {
-            if(isPlatformSupport.compare("true") != 0) {
+            if(vectorInfo.isPlatformSupportVector[0].compare("true") != 0) {
                 LOGERR("%s: platform support not available\n", __FUNCTION__);
                 return -1;
             }
@@ -359,51 +410,37 @@ namespace Plugin {
         return 0;
     }
 
-    void AVOutputTV::spliltCapablities( std::vector<std::string> &range,std::vector<std::string> &pqmode,std::vector<std::string> &format,
-                                        std::vector<std::string> &source, std::vector<std::string> &index, std::string rangeInfo,
-                                        std::string pqmodeInfo, std::string formatInfo, std::string sourceInfo, std::string indexInfo)
+    void AVOutputTV::spliltCapablities( capVectors_t& vectorInfo, capDetails_t stringInfo)
     {
-        std::string token;
-        std::stringstream rangeStream(rangeInfo);
-        std::stringstream pqmodeStream(pqmodeInfo);
-        std::stringstream formatStream(formatInfo);
-        std::stringstream sourceStream(sourceInfo);
-        std::stringstream indexStream(indexInfo);
-
-        while( getline(rangeStream,token,',')) {
-            range.push_back(token );
-            token.clear();
-        }
-
-        while( getline(pqmodeStream,token,',') ) {
-            pqmode.push_back(token );
-            token.clear();
-        }
-
-        while( getline(formatStream,token,',')) {
-            format.push_back( token );
-            token.clear();
-        }
-        while( getline(sourceStream,token,',') ) {
-            source.push_back( token );
-            token.clear();
-        }
-
-        while( getline(indexStream,token,',') ) {
-            index.push_back( token );
-            token.clear();
+        std::vector<std::pair<std::stringstream, std::vector<std::string>&>> streamVector;
+
+         // Initializing the streamVector with stringstreams and corresponding vectors
+        streamVector.push_back({std::stringstream(stringInfo.range), vectorInfo.rangeVector});
+        streamVector.push_back({std::stringstream(stringInfo.pqmode), vectorInfo.pqmodeVector});
+        streamVector.push_back({std::stringstream(stringInfo.format), vectorInfo.formatVector});
+        streamVector.push_back({std::stringstream(stringInfo.source), vectorInfo.sourceVector});
+        streamVector.push_back({std::stringstream(stringInfo.isPlatformSupport), vectorInfo.isPlatformSupportVector});
+        streamVector.push_back({std::stringstream(stringInfo.index), vectorInfo.indexVector});
+        streamVector.push_back({std::stringstream(stringInfo.color), vectorInfo.colorVector});
+        streamVector.push_back({std::stringstream(stringInfo.component), vectorInfo.componentVector});
+        streamVector.push_back({std::stringstream(stringInfo.colorTemperature), vectorInfo.colorTempVector});
+	streamVector.push_back({std::stringstream(stringInfo.control), vectorInfo.controlVector});
+
+        for (auto& pair : streamVector) {
+            std::stringstream& ss = pair.first;
+            std::vector<std::string>& vec = pair.second;
+    
+            std::string token;
+            while (getline(ss, token, ',')) {
+                vec.push_back(token);
+            }
         }
     }
-
-    bool AVOutputTV::isCapablityCheckPassed( std::string  pqmodeInputInfo,std::string sourceInputInfo,std::string formatInputInfo,std::string param )
+    
+    bool AVOutputTV::isCapablityCheckPassed( std::string param, capDetails_t inputInfo )
     {
 
-        std::string rangeCapInfo;
-        std::string sourceCapInfo;
-        std::string formatCapInfo;
-        std::string pqmodeCapInfo;
-        std::string isPlatformSupport;
-        std::string indexInfo;
+        capDetails_t paramInfo;
 
         std::set<string> pqmodeCapSet;
         std::set<string> formatCapSet;
@@ -412,17 +449,38 @@ namespace Plugin {
         std::set<string> formatInputSet;
         std::set<string> sourceInputSet;
 
-        if( ReadCapablitiesFromConf( rangeCapInfo, pqmodeCapInfo, formatCapInfo, sourceCapInfo,param, isPlatformSupport, indexInfo) ) {
+
+        if( ReadCapablitiesFromConf( param, paramInfo ) != 0 ) {
             LOGINFO( "%s: readCapablitiesFromConf Failed !!!\n",__FUNCTION__);
             return false;
         }
+
+        if( param == "CMS")
+        {
+            // Check color
+            if (! checkCMSColorAndComponentCapability(paramInfo.color, inputInfo.color)) {
+                LOGINFO( "%s:CMS color Capablity Failed CapColor : %s inputColor : %s!!!\n",__FUNCTION__,paramInfo.color.c_str(), inputInfo.color.c_str());
+                return false;
+            }
+
+            // Check component
+            if (! checkCMSColorAndComponentCapability(paramInfo.component, inputInfo.component)) {
+                LOGINFO( "%s:CMS component Capablity capComponent : %s inputComponent : %s Failed!!!.\n",__FUNCTION__,paramInfo.component.c_str(), inputInfo.component.c_str());
+                return false;
+            }
+        }
+        else if( param == "WhiteBalance")
+        {
+            if ( ( paramInfo.color.find(inputInfo.color) == std::string::npos ) || ( paramInfo.control.find(inputInfo.control) == std::string::npos) )
+                return false;
+        }
         //Compare capablityInfo with Input params
 
         //1.convertCapablity Info to set for comparison
-        spliltStringsAndConvertToSet( pqmodeCapInfo, formatCapInfo, sourceCapInfo, pqmodeCapSet, formatCapSet, sourceCapset);
+        spliltStringsAndConvertToSet( paramInfo.pqmode, paramInfo.format, paramInfo.source, pqmodeCapSet, formatCapSet, sourceCapset);
 
         //2.convert Application Input Info to set for comparison
-        spliltStringsAndConvertToSet( pqmodeInputInfo, formatInputInfo, sourceInputInfo, pqmodeInputSet, formatInputSet, sourceInputSet );
+        spliltStringsAndConvertToSet( inputInfo.pqmode, inputInfo.format, inputInfo.source, pqmodeInputSet, formatInputSet, sourceInputSet );
 
         //3.Compare Each pqmode/format/source InputInfo against CapablityInfo
         if ( isIncluded(pqmodeCapSet,pqmodeInputSet) && isIncluded(formatCapSet,formatInputSet) && isIncluded(sourceCapset,sourceInputSet) ) {
@@ -435,8 +493,7 @@ namespace Plugin {
         }
     }
 
-    int AVOutputTV::parsingSetInputArgument(const JsonObject& parameters, std::string pqparam, std::string & source,
-                                             std::string & pqmode, std::string & format) {
+    int AVOutputTV::parsingSetInputArgument(const JsonObject& parameters, std::string pqparam,capDetails_t& paramInfo) {
 
         JsonArray sourceArray;
         JsonArray pqmodeArray;
@@ -445,39 +502,60 @@ namespace Plugin {
 
         pqmodeArray = parameters.HasLabel("pictureMode") ? parameters["pictureMode"].Array() : JsonArray();
         for (int i = 0; i < pqmodeArray.Length(); ++i) {
-            pqmode += pqmodeArray[i].String();
+            paramInfo.pqmode += pqmodeArray[i].String();
             if (i != (pqmodeArray.Length() - 1) ) {
-		pqmode += ",";
+                paramInfo.pqmode += ",";
             }
         }
 
         sourceArray = parameters.HasLabel("videoSource") ? parameters["videoSource"].Array() : JsonArray();
         for (int i = 0; i < sourceArray.Length(); ++i) {
-            source += sourceArray[i].String();
+            paramInfo.source += sourceArray[i].String();
             if (i != (sourceArray.Length() - 1) ) {
-		source += ",";
-	    }
+                paramInfo.source += ",";
+	        }
         }
 
         formatArray = parameters.HasLabel("videoFormat") ? parameters["videoFormat"].Array() : JsonArray();
         for (int i = 0; i < formatArray.Length(); ++i) {
-            format += formatArray[i].String();
+            paramInfo.format += formatArray[i].String();
             if (i != (formatArray.Length() - 1) ) {
-		format += ",";
+                paramInfo.format += ",";
             }
         }
 
-	if (source.empty()) {
-	    source = "Global";
-	}
-        if (pqmode.empty()) {
-	    pqmode = "Global";
-	}
-        if (format.empty()) {
-	    format = "Global";
-	}
+	    if (paramInfo.source.empty()) {
+            paramInfo.source = "Global";
+	    }
+        if (paramInfo.pqmode.empty()) {
+            paramInfo.pqmode = "Global";
+	    }
+        if (paramInfo.format.empty()) {
+            paramInfo.format = "Global";
+	    }
+
+        if( pqparam.compare("WhiteBalance") == 0 )
+        {
+            if ( paramInfo.color.empty() )
+              paramInfo.color = "Global";
+
+            if ( paramInfo.control.empty() )
+              paramInfo.control = "Global";
+
+            if ( paramInfo.colorTemperature.empty() )
+              paramInfo.colorTemperature = "Global";
+        }
+
+        if( pqparam.compare("CMS") == 0 )
+        {
+            if ( paramInfo.color.empty() )
+              paramInfo.color = "Global";
+
+            if ( paramInfo.component.empty() )
+              paramInfo.component = "Global";
+        }
 
-        if (convertToValidInputParameter(pqparam, source, pqmode, format) != 0) {
+        if (convertToValidInputParameter(pqparam, paramInfo) != 0) {
             LOGERR("%s: Failed to convert the input paramters. \n", __FUNCTION__);
             return -1;
         }
@@ -485,30 +563,30 @@ namespace Plugin {
         return 0;
     }
 
-    int AVOutputTV::parsingGetInputArgument(const JsonObject& parameters, std::string pqparam,
-                                         std::string & source, std::string & pqmode, std::string & format) {
-        pqmode = parameters.HasLabel("pictureMode") ? parameters["pictureMode"].String() : "";
+    int AVOutputTV::parsingGetInputArgument(const JsonObject& parameters, std::string pqparam, capDetails_t& info)
+    {                                     
+        info.pqmode = parameters.HasLabel("pictureMode") ? parameters["pictureMode"].String() : "";
 
-        source = parameters.HasLabel("videoSource") ? parameters["videoSource"].String() : "";
+        info.source = parameters.HasLabel("videoSource") ? parameters["videoSource"].String() : "";
 
-        format = parameters.HasLabel("videoFormat") ? parameters["videoFormat"].String() : "";
+        info.format = parameters.HasLabel("videoFormat") ? parameters["videoFormat"].String() : "";
 
-        if ( (source.compare("Global") == 0) || (pqmode.compare("Global") == 0) || (format.compare("Global") == 0) ) {
+        if ( (info.source.compare("Global") == 0) || (info.pqmode.compare("Global") == 0) || (info.format.compare("Global") == 0) ) {
             LOGERR("%s: get cannot fetch the Global inputs \n", __FUNCTION__);
             return -1;
         }
 
-        if (source.empty()) {
-	    source = "Current";
-	}
-        if (pqmode.empty()) {
-	    pqmode = "Current";
-	}
-        if (format.empty()) {
-	    format = "Current";
-	}
+        if (info.source.empty()) {
+	       info.source = "Current";
+        }
+        if (info.pqmode.empty()) {
+	        info.pqmode = "Current";
+	    }
+        if (info.format.empty()) {
+	        info.format = "Current";
+        }
 
-        if (convertToValidInputParameter(pqparam,source, pqmode, format) != 0) {
+        if (convertToValidInputParameter(pqparam,info) != 0) {
             LOGERR("%s: Failed to convert the input paramters. \n", __FUNCTION__);
             return -1;
         }
@@ -541,13 +619,8 @@ namespace Plugin {
 
     int AVOutputTV::validateIntegerInputParameter(std::string param, int inputValue)
     {
-
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
-
-        tvError_t ret = getParamsCaps(range, pqmode, source, format, param);
+        capVectors_t info;
+        tvError_t ret = getParamsCaps(param, info);
 
         if (ret != tvERROR_NONE) {
             LOGERR("Failed to fetch the range capability[%s] \n", param.c_str());
@@ -557,9 +630,9 @@ namespace Plugin {
         if ( (param == "Brightness") || (param == "Contrast") ||
              (param == "Sharpness") || (param == "Saturation") ||
              (param == "Hue") || (param == "WhiteBalance") ||
-            (param == "ComponentSaturation") || (param == "Backlight") ||
-            (param == "ComponentHue") || (param == "ComponentLuma") || (param == "LowLatencyState") ) {
-            if (inputValue < stoi(range[0]) || inputValue > stoi(range[1])) {
+            (param == "CMS") || (param == "Backlight") ||
+            (param == "WhiteBalance") || (param == "LowLatencyState") ) {
+            if (inputValue < stoi(info.rangeVector[0]) || inputValue > std::stoi(info.rangeVector[1])) {
                 LOGERR("wrong Input value[%d]", inputValue);
                 return -1;
             }
@@ -567,32 +640,45 @@ namespace Plugin {
         return 0;
     }
 
-    int AVOutputTV::fetchCapablities(string pqparam, string & source, string & pqmode, string & format) {
+    int AVOutputTV::fetchCapablities(string pqparam, capDetails_t& info) {
 
-        std::vector<std::string> range;
-        std::vector<std::string> sourceVec;
-        std::vector<std::string> pqmodeVec;
-        std::vector<std::string> formatVec;
+       capVectors_t vectorInfo;
 
        tvError_t ret = tvERROR_NONE;
 
-       ret = getParamsCaps(range, pqmodeVec, sourceVec, formatVec, pqparam);
+       ret = getParamsCaps(pqparam, vectorInfo);
 
        if (ret != tvERROR_NONE) {
            LOGINFO("%s: failed to get the capability \n", __FUNCTION__);
            return -1;
        }
 
-       if (sourceVec.size() != 0) {
-            source = convertToString(sourceVec);
+       if (vectorInfo.sourceVector.size() != 0) {
+            info.source = convertToString(vectorInfo.sourceVector);
+       }
+
+       if (vectorInfo.pqmodeVector.size() != 0) {
+            info.pqmode = convertToString(vectorInfo.pqmodeVector);
+       }
+
+       if (vectorInfo.formatVector.size() != 0) {
+            info.format = convertToString(vectorInfo.formatVector);
+       }
+
+       if (vectorInfo.colorVector.size() != 0) {
+            info.color = convertToString(vectorInfo.colorVector);
+       }
+
+       if (vectorInfo.componentVector.size() != 0) {
+            info.component = convertToString(vectorInfo.componentVector);
        }
 
-       if (pqmodeVec.size() != 0) {
-            pqmode = convertToString(pqmodeVec);
+       if (vectorInfo.controlVector.size() != 0) {
+            info.control = convertToString(vectorInfo.controlVector);
        }
 
-       if (formatVec.size() != 0) {
-            format = convertToString(formatVec);
+       if (vectorInfo.colorTempVector.size() != 0) {
+            info.colorTemperature = convertToString(vectorInfo.colorTempVector);
        }
 
        return 0;
@@ -601,12 +687,9 @@ namespace Plugin {
     int AVOutputTV::validateInputParameter(std::string param, std::string inputValue)
     {
 
-        std::vector<std::string> range;
-        std::vector<std::string> pqmode;
-        std::vector<std::string> source;
-        std::vector<std::string> format;
+        capVectors_t info;
 
-        tvError_t ret = getParamsCaps(range, pqmode, source, format, param);
+        tvError_t ret = getParamsCaps( param, info);
 
         if (ret != tvERROR_NONE) {
             LOGERR("Failed to fetch the range capability[%s] \n", param.c_str());
@@ -614,12 +697,12 @@ namespace Plugin {
         }
 
         if ( (param == "ColorTemperature") ||
-             (param == "DimmingMode") || (param == "AutoBacklightControl") ||
+             (param == "DimmingMode") || (param == "AutoBacklightMode") ||
              (param == "DolbyVisionMode") || (param == "HDR10Mode") ||
-            (param == "HLGMode") || (param == "AspectRatio") || (param == "PictureMode") ) {
-            auto iter = find(range.begin(), range.end(), inputValue);
+            (param == "HLGMode") || (param == "AspectRatio") || (param == "PictureMode")  ) {
+            auto iter = find(info.rangeVector.begin(), info.rangeVector.end(), inputValue);
 
-            if (iter == range.end()) {
+            if (iter == info.rangeVector.end()) {
                 LOGERR("Not a valid input value[%s].\n", inputValue.c_str());
                 return -1;
             }
@@ -709,49 +792,36 @@ namespace Plugin {
         return result;
     }
 
-    int AVOutputTV::convertToValidInputParameter(std::string pqparam, std::string & source, std::string & pqmode, std::string & format)
+    int AVOutputTV::convertToValidInputParameter(std::string pqparam, capDetails_t& info)
     {
 
-        LOGINFO("Entry %s source %s pqmode %s format %s \n", __FUNCTION__, source.c_str(), pqmode.c_str(), format.c_str());
+        LOGINFO("Entry %s source %s pqmode %s format %s \n", __FUNCTION__, info.source.c_str(), info.pqmode.c_str(), info.format.c_str());
 
+        capDetails_t localInfo;
+        if (fetchCapablities(pqparam, localInfo) != 0) {
+            LOGINFO("%s, Failed to get capability fo %s\n", __FUNCTION__,pqparam.c_str());
+            return -1;
+        }
+        
         // converting pq to valid paramter format
-        if (pqmode == "Global") {
-            std::string localSource;
-            std::string localPqmode;
-            std::string localFormat;
-            if (fetchCapablities(pqparam, localSource, localPqmode, localFormat) == 0) {
-                pqmode = localPqmode;
-                //if pqmode none from capabilty then lets keep pqmode as global to fail the capabilty
-            }
-            else {
-                LOGINFO("%s, Failed to get picturemode capability\n", __FUNCTION__);
-                return -1;
-            }
+        if (info.pqmode == "Global") {
+            info.pqmode = localInfo.pqmode;
         }
-        else if (pqmode == "Current") {
+        else if (info.pqmode == "Current") {
             char picMode[PIC_MODE_NAME_MAX]={0};
             if(!getCurrentPictureMode(picMode)) {
                 LOGINFO("Failed to get the Current picture mode\n");
                 return -1;
             }
             else {
-                pqmode = picMode;
+                info.pqmode = picMode;
             }
         }
 
-        if (source == "Global") {
-            std::string localSource;
-            std::string localPqmode;
-            std::string localFormat;
-            if (fetchCapablities(pqparam, localSource, localPqmode, localFormat) == 0) {
-                source = localSource;
-            }
-            else {
-                LOGINFO("%s, Failed to get source capability\n", __FUNCTION__);
-                return -1;
-            }
+        if (info.source == "Global") {
+            info.source = localInfo.source;
         }
-        else if (source == "Current") {
+        else if (info.source == "Current") {
             tvVideoSrcType_t currentSource = VIDEO_SOURCE_IP;
             tvError_t ret = GetCurrentVideoSource(&currentSource);
 
@@ -759,32 +829,60 @@ namespace Plugin {
                 LOGWARN("%s: GetCurrentVideoSource( ) Failed \n",__FUNCTION__);
                 return -1;
             }
-            source = convertSourceIndexToString(currentSource);
+            info.source = convertSourceIndexToString(currentSource);
         }
 
         //convert format into valid parameter
-        if (format == "Global") {
-            std::string localSource;
-            std::string localPqmode;
-            std::string localFormat;
-            if (fetchCapablities(pqparam, localSource, localPqmode, localFormat) == 0) {
-                format = localFormat;
-            }
-            else {
-                LOGINFO("%s, Failed to get format capability\n", __FUNCTION__);
-                return -1;
-            }
+        if (info.format == "Global") {
+            info.format = localInfo.format;
         }
-        else if (format == "Current") {
+        else if (info.format == "Current") {
             tvVideoFormatType_t formatIndex = VIDEO_FORMAT_NONE;
             GetCurrentVideoFormat(&formatIndex);
             if ( formatIndex  == VIDEO_FORMAT_NONE) {
                 formatIndex  = VIDEO_FORMAT_SDR;
-	    }
-            format = convertVideoFormatToString(formatIndex);
+	        }
+            info.format = convertVideoFormatToString(formatIndex);
+        }
+
+        //convert WB and CMS params
+        if( pqparam.compare("WhiteBalance") == 0 )
+        {
+            if( info.control.compare("Global") == 0 )
+            {
+                info.control = localInfo.control;       
+            }
+            
+            if( info.color.compare("Global") == 0 )
+            {
+                info.color = localInfo.color;       
+            }
+
+            if( info.colorTemperature.compare("Global") == 0 )
+            {
+                info.colorTemperature= localInfo.colorTemperature;     
+            }
+
+            LOGINFO("%s : control : %s color : %s colorTemp : %s \n",__FUNCTION__,info.control.c_str(),info.color.c_str(),info.colorTemperature.c_str());
+            
+        }
+
+        if( pqparam.compare("CMS") == 0 )
+        {
+            if( info.component.compare("Global") == 0 )
+            {
+                info.component = localInfo.component;       
+            }
+            
+            if( info.color.compare("Global") == 0 )
+            {
+                info.color = localInfo.color;       
+            }
+
+            LOGINFO("%s : component : %s color : %s \n",__FUNCTION__,info.component.c_str(),info.color.c_str());
         }
 
-        LOGINFO("Exit %s source %s pqmode %s format %s \n", __FUNCTION__, source.c_str(), pqmode.c_str(), format.c_str());
+        LOGINFO("Exit %s source %s pqmode %s format %s \n", __FUNCTION__, info.source.c_str(), info.pqmode.c_str(), info.format.c_str());
         return 0;
     }
 
@@ -847,12 +945,18 @@ namespace Plugin {
         return ret;
     }
 
-    tvError_t AVOutputTV::updateAVoutputTVParamToHAL(std::string forParam, int source, int pqmode, int format, int value,bool setNotDelete)
+    tvError_t AVOutputTV::updateAVoutputTVParamToHAL(std::string forParam, paramIndex_t indexInfo, int value,bool setNotDelete)
     {
         tvError_t ret = tvERROR_NONE;
         std::string key;
 
-        generateStorageIdentifier(key,forParam,format,pqmode,source);
+        if( forParam.compare("CMS") == 0 )
+            generateStorageIdentifierCMS(key,forParam,indexInfo);
+        else if( forParam.compare("WhiteBalance") == 0 ) 
+            generateStorageIdentifierWB(key,forParam,indexInfo);
+        else 
+            generateStorageIdentifier(key,forParam,indexInfo);
+
         if(key.empty()) {
             LOGERR("generateStorageIdentifierDirty failed\n");
             ret = tvERROR_GENERAL;
@@ -867,7 +971,7 @@ namespace Plugin {
                 else if(forParam.compare("DimmingMode") == 0 ) {
                     getDimmingModeStringFromEnum(value, toStore);
                 }
-                else if (forParam.compare("DolbyVisionMode") == 0 ) {
+                else if (forParam.compare("DolbyVisionMode") == 0 || forParam.compare("HDRMode") == 0 ) {
                     toStore = getDolbyModeStringFromEnum((tvDolbyMode_t)value);
                 }
                 err = setLocalParam(rfc_caller_id, key.c_str(),toStore.c_str());
@@ -885,9 +989,11 @@ namespace Plugin {
         return ret;
     }
 
-    int AVOutputTV::updateAVoutputTVParam( std::string action, std::string tr181ParamName, std::string pqmode, std::string source, std::string format, tvPQParameterIndex_t pqParamIndex, int params[] )
+    int AVOutputTV::updateAVoutputTVParam( std::string action, std::string tr181ParamName, capDetails_t info, tvPQParameterIndex_t pqParamIndex, int level )
     {
         LOGINFO("Entry : %s\n",__FUNCTION__);
+        valueVectors_t values;
+        paramIndex_t paramIndex;
         std::vector<int> sources;
         std::vector<int> pictureModes;
         std::vector<int> formats;
@@ -896,14 +1002,15 @@ namespace Plugin {
         bool reset = !(action.compare("reset"));
         bool set = !(action.compare("set"));
 
-        LOGINFO("%s: Entry param : %s Action : %s pqmode : %s source :%s format :%s\n",__FUNCTION__,tr181ParamName.c_str(),action.c_str(),pqmode.c_str(),source.c_str(),format.c_str() );
-        ret = getSaveConfig(pqmode, source, format, sources, pictureModes, formats);
+        LOGINFO("%s: Entry param : %s Action : %s pqmode : %s source :%s format :%s color:%s component:%s control:%s\n",__FUNCTION__,tr181ParamName.c_str(),action.c_str(),info.pqmode.c_str(),info.source.c_str(),info.format.c_str(),info.color.c_str(),info.component.c_str(),info.control.c_str() );
+        ret = getSaveConfig(tr181ParamName,info, values);
         if( 0 == ret ) {
-            for(int sourceType: sources) {
-                tvVideoSrcType_t source = (tvVideoSrcType_t)sourceType;
-                for(int mode : pictureModes) {
-                    for(int formatType : formats) {
-                        tvVideoFormatType_t format = (tvVideoFormatType_t)formatType;
+            for( int sourceType: values.sourceValues ) {
+                paramIndex.sourceIndex = sourceType;
+                for( int modeType : values.pqmodeValues ) {
+                    paramIndex.pqmodeIndex = modeType;
+                    for( int formatType : values.formatValues ) {
+                        paramIndex.formatIndex = formatType;
                         switch(pqParamIndex) {
                             case PQ_PARAM_BRIGHTNESS:
                             case PQ_PARAM_CONTRAST:
@@ -916,17 +1023,17 @@ namespace Plugin {
                             case PQ_PARAM_LOWLATENCY_STATE:
                             case PQ_PARAM_DOLBY_MODE:
                                 if(reset) {
-                                    ret |= updateAVoutputTVParamToHAL(tr181ParamName,source, mode, format,0,false);
-				}
+                                    ret |= updateAVoutputTVParamToHAL(tr181ParamName,paramIndex,0,false);
+                                }
                                 if(sync || reset) {
                                     int value=0;
-                                    if(getLocalparam(tr181ParamName,format,mode,source,value,pqParamIndex,sync)) {
-					continue;
-			            }
-                                    params[0]=value;
+                                    if(getLocalparam(tr181ParamName,paramIndex,value,pqParamIndex,sync)) {
+                                        continue;
+                                    }
+                                    level=value;
                                 }
                                 if(set) {
-                                    ret |= updateAVoutputTVParamToHAL(tr181ParamName,source, mode, format, params[0],true);
+                                    ret |= updateAVoutputTVParamToHAL(tr181ParamName,paramIndex,level,true);
                                 }
                                 break;
                             default:
@@ -934,53 +1041,138 @@ namespace Plugin {
                         }
                         switch(pqParamIndex) {
                             case PQ_PARAM_BRIGHTNESS:
-                                ret |= SaveBrightness(source, mode,format,params[0]);
+                                ret |= SaveBrightness((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,level);
                                 break;
                             case PQ_PARAM_CONTRAST:
-                                ret |= SaveContrast(source, mode,format,params[0]);
+                                ret |= SaveContrast((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,level);
                                 break;
                             case PQ_PARAM_SHARPNESS:
-                                ret |= SaveSharpness(source, mode,format,params[0]);
+                                ret |= SaveSharpness((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,level);
                                 break;
                             case PQ_PARAM_HUE:
-                                ret |= SaveHue(source, mode,format,params[0]);
+                                ret |= SaveHue((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,level);
                                 break;
                             case PQ_PARAM_SATURATION:
-                                ret |= SaveSaturation(source, mode,format,params[0]);
+                                ret |= SaveSaturation((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,level);
                                 break;
                             case PQ_PARAM_COLOR_TEMPERATURE:
-                                ret |= SaveColorTemperature(source, mode,format,(tvColorTemp_t)params[0]);
+                                ret |= SaveColorTemperature((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,(tvColorTemp_t)level);
                                 break;
                             case PQ_PARAM_BACKLIGHT:
-                                ret |= SaveBacklight(source, mode,format,params[0]);
+                                ret |= SaveBacklight((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,level);
                                 break;
                             case PQ_PARAM_DIMMINGMODE:
-                                ret |= SaveTVDimmingMode(source,mode,format,(tvDimmingMode_t)params[0]);
+                                ret |= SaveTVDimmingMode((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,(tvDimmingMode_t)level);
                                 break;
                             case PQ_PARAM_LOWLATENCY_STATE:
-                                ret |= SaveLowLatencyState(source, mode,format,params[0]);
+                                ret |= SaveLowLatencyState((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,level);
                                 break;
                             case PQ_PARAM_DOLBY_MODE:
-                                 ret |= SaveTVDolbyVisionMode(source, mode,format,(tvDolbyMode_t)params[0]);
+                                 ret |= SaveTVDolbyVisionMode((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,(tvDolbyMode_t)level);
                                  break;
 
-                             case PQ_PARAM_ASPECT_RATIO:
-                                 ret |= SaveAspectRatio(source,mode,format,(tvDisplayMode_t)params[0]);
+                            case PQ_PARAM_ASPECT_RATIO:
+                                 ret |= SaveAspectRatio((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,(tvDisplayMode_t)level);
                                  break;
-                             case PQ_PARAM_LOCALDIMMING_LEVEL:
+                             
+                            case PQ_PARAM_CMS_SATURATION_RED:                
+                            case PQ_PARAM_CMS_SATURATION_BLUE:        
+                            case PQ_PARAM_CMS_SATURATION_GREEN:          
+                            case PQ_PARAM_CMS_SATURATION_YELLOW:         
+                            case PQ_PARAM_CMS_SATURATION_CYAN:         
+                            case PQ_PARAM_CMS_SATURATION_MAGENTA:        
+                            case PQ_PARAM_CMS_HUE_RED:        
+                            case PQ_PARAM_CMS_HUE_BLUE:                  
+                            case PQ_PARAM_CMS_HUE_GREEN:                 
+                            case PQ_PARAM_CMS_HUE_YELLOW:                
+                            case PQ_PARAM_CMS_HUE_CYAN:                
+                            case PQ_PARAM_CMS_HUE_MAGENTA:               
+                            case PQ_PARAM_CMS_LUMA_RED:               
+                            case PQ_PARAM_CMS_LUMA_BLUE:                 
+                            case PQ_PARAM_CMS_LUMA_GREEN:
+                            case PQ_PARAM_CMS_LUMA_YELLOW:               
+                            case PQ_PARAM_CMS_LUMA_CYAN:               
+                            case PQ_PARAM_CMS_LUMA_MAGENTA:
+                            {
+                                for( int componentType : values.componentValues ) {
+                                    paramIndex.componentIndex = componentType;
+                                    for( int colorType : values.colorValues ) {
+                                        paramIndex.colorIndex = colorType;                     
+                                        if(reset) {
+                                            ret |= updateAVoutputTVParamToHAL(tr181ParamName,paramIndex,0,false);
+		                		        }
+                                        if(sync || reset) {
+                                            int value=0;
+                                            tvPQParameterIndex_t pqIndex;
+                                            if ( convertCMSParamToPQEnum(getCMSComponentStringFromEnum((tvComponentType_t)paramIndex.componentIndex),getCMSColorStringFromEnum((tvDataComponentColor_t)paramIndex.colorIndex),pqIndex) != 0 )
+                                            {
+                                                LOGERR("%s:convertCMSParamToPQEnum failed color : %d component : %d \n",__FUNCTION__,paramIndex.colorIndex,paramIndex.componentIndex);
+                                                return -1;
+                                            }
+                                            if(getLocalparam(tr181ParamName,paramIndex,value,pqIndex,sync)) {
+					                            continue;
+			                                }
+                                            level=value;
+                                        }
+                                        ret |= SaveCMS((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,(tvComponentType_t)paramIndex.componentIndex,(tvDataComponentColor_t)paramIndex.colorIndex,level);
+
+                                        if(set) {
+                                            ret |= updateAVoutputTVParamToHAL(tr181ParamName,paramIndex,level,true);
+                                        }
+                                    }
+                                }
+                                break;
+                            }
+                            case PQ_PARAM_WB_GAIN_RED:
+                            case PQ_PARAM_WB_GAIN_GREEN:
+                            case PQ_PARAM_WB_GAIN_BLUE:
+                            case PQ_PARAM_WB_OFFSET_RED:
+                            case PQ_PARAM_WB_OFFSET_GREEN:
+                            case PQ_PARAM_WB_OFFSET_BLUE:
+                            {
+                               for( int colorType : values.colorValues ) {
+                                   paramIndex.colorIndex = colorType;
+                                   for( int controlType : values.controlValues ) {
+                                        paramIndex.controlIndex = controlType;
+                                        if(reset) {
+                                            ret |= updateAVoutputTVParamToHAL(tr181ParamName,paramIndex,0,false);
+		                	            }
+                                        if(sync || reset) {
+                                            int value=0;
+                                            if(getLocalparam(tr181ParamName,paramIndex,value,pqParamIndex,sync)) {
+					                            continue;
+			                                }
+                                            level=value;
+                                        }
+                                         /* tvRGBType_t rgbIndex;
+                                            if ( convertWBParamToRGBEnum(getWBColorStringFromEnum((tvWBColor_t)(paramIndex.colorIndex)),getWBControlStringFromEnum((tvWBControl_t)(paramIndex.controlIndex)),rgbIndex) != 0 )
+                                            {
+                                                LOGERR("%s:convertWBParamToRGBEnum failed Color : %d Control : %d  \n",__FUNCTION__,paramIndex.colorIndex,paramIndex.controlIndex);
+                                                return -1;  
+                                            }*/
+                                        ret |= SaveCustom2PointWhiteBalance((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,(tvWBColor_t)paramIndex.colorIndex,(tvWBControl_t)paramIndex.controlIndex,level);
+
+                                        if(set) {
+                                            ret |= updateAVoutputTVParamToHAL(tr181ParamName,paramIndex,level,true);
+                                        }   
+                                }
+                            }
+                                break;
+                            }
+                            case PQ_PARAM_LOCALDIMMING_LEVEL:
                              {
-                                 if(sync) {
-                                     int value=0;
-                                     getLocalparam(tr181ParamName,format,mode,source,value,pqParamIndex,sync);
-                                     params[0]=value;
-                                 }
-                                 ret |= SaveTVDimmingMode(source, mode,format,(tvDimmingMode_t)params[0]);
-                                 break;
-                             }
-                             case PQ_PARAM_CMS:
-                             case PQ_PARAM_LDIM:
-                             default:
-                                 break;
+                                if(sync) {
+                                    int value=0;
+                                    getLocalparam(tr181ParamName,paramIndex,value,pqParamIndex,sync);
+                                    level=value;
+                                }
+                                ret |= SaveTVDimmingMode((tvVideoSrcType_t)paramIndex.sourceIndex, paramIndex.pqmodeIndex,(tvVideoFormatType_t)paramIndex.formatIndex,(tvDimmingMode_t)level);
+                                break;
+                            }
+                            case PQ_PARAM_CMS:
+                            case PQ_PARAM_LDIM:
+                            default:
+                                break;
                         }
                     }
                 }
@@ -992,72 +1184,88 @@ namespace Plugin {
 
     tvError_t AVOutputTV::syncAvoutputTVParamsToHAL(std::string pqmode,std::string source,std::string format)
     {
-        int params[3]={0};
+        int level={0};
+        capDetails_t info;
+        info.pqmode = pqmode;
+        info.source = source;
+        info.format = format;
 
         LOGINFO("Entry %s : pqmode : %s source : %s format : %s\n",__FUNCTION__,pqmode.c_str(),source.c_str(),format.c_str());
 
-        if( !updateAVoutputTVParam("sync","Brightness",pqmode,source,format,PQ_PARAM_BRIGHTNESS,params)) {
+        if( !updateAVoutputTVParam("sync","Brightness",info,PQ_PARAM_BRIGHTNESS,level)) {
             LOGINFO("Brightness Successfully sync to Drive Cache\n");
-	}
+        }
         else {
             LOGERR("Brightness Sync to cache Failed !!!\n");
-	}
+        }
 
-        if( !updateAVoutputTVParam("sync","Contrast",pqmode,source,format,PQ_PARAM_CONTRAST,params)) {
+        if( !updateAVoutputTVParam("sync","Contrast",info,PQ_PARAM_CONTRAST,level)) {
             LOGINFO("Contrast Successfully Synced to Drive Cache\n");
-	}
+        }
         else {
             LOGERR("Contrast Sync to cache Failed !!!\n");
-	}
+        }
 
-        if( !updateAVoutputTVParam("sync","Sharpness",pqmode,source,format,PQ_PARAM_SHARPNESS,params)) {
+        if( !updateAVoutputTVParam("sync","Sharpness",info,PQ_PARAM_SHARPNESS,level)) {
             LOGINFO("Sharpness Successfully Synced to Drive Cache\n");
-	}
+        }
         else {
             LOGERR("Sharpness Sync to cache Failed !!!\n");
-	}
+        }
 
-        if( !updateAVoutputTVParam("sync","Saturation",pqmode,source,format,PQ_PARAM_SATURATION,params)) {
+        if( !updateAVoutputTVParam("sync","Saturation",info,PQ_PARAM_SATURATION,level)) {
             LOGINFO("Saturation Successfully Synced to Drive Cache\n");
-	}
+        }
         else {
             LOGERR("Saturation Sync to cache Failed !!!\n");
-	}
+        }
 
-        if( !updateAVoutputTVParam("sync","Hue",pqmode,source,format,PQ_PARAM_HUE,params)) {
+        if( !updateAVoutputTVParam("sync","Hue",info,PQ_PARAM_HUE,level)) {
             LOGINFO("Hue Successfully Synced to Drive Cache\n");
-	}
+        }
         else {
             LOGERR("Hue Sync to cache Failed !!!\n");
-	}
+        }
 
-        if( !updateAVoutputTVParam("sync","ColorTemp",pqmode,source,format,PQ_PARAM_COLOR_TEMPERATURE,params)) {
+        if( !updateAVoutputTVParam("sync","ColorTemp",info,PQ_PARAM_COLOR_TEMPERATURE,level)) {
             LOGINFO("ColorTemp Successfully Synced to Drive Cache\n");
-	}
+        }
         else {
             LOGERR("ColorTemp Sync to cache Failed !!!\n");
         }
-
-        if( !updateAVoutputTVParam("sync","DolbyVisionMode",pqmode,source,"DV",PQ_PARAM_DOLBY_MODE,params)) {
-            LOGINFO("dvmode Successfully Synced to Drive Cache\n");
-	}
+        if( !updateAVoutputTVParam("sync","HDRMode",info,PQ_PARAM_DOLBY_MODE,level)) {
+            LOGINFO("HDRmode Successfully Synced to Drive Cache\n");
+        }
         else {
-            LOGERR("dvmode Sync to cache Failed !!!\n");
-	}
+            LOGERR("HDRmode Sync to cache Failed !!!\n");
+        }
 
-        if( !updateAVoutputTVParam("sync","DimmingMode",pqmode,source,format,PQ_PARAM_DIMMINGMODE,params)) {
+        if( !updateAVoutputTVParam("sync","DimmingMode",info,PQ_PARAM_DIMMINGMODE,level)) {
             LOGINFO("dimmingmode Successfully Synced to Drive Cache\n");
-	}
+        }
         else {
             LOGERR("dimmingmode Sync to cache Failed !!!\n");
-	}
+        }
 
-        if( !updateAVoutputTVParam("sync","Backlight",pqmode,source,format,PQ_PARAM_BACKLIGHT,params) ) {
+        if( !updateAVoutputTVParam("sync","Backlight",info,PQ_PARAM_BACKLIGHT,level) ) {
             LOGINFO("Backlight Successfully Synced to Drive Cache\n");
-	}
+        }
         else {
             LOGERR("Backlight Sync to cache Failed !!!\n");
-	}
+        }
+
+        syncCMSParams(); //sync CMS 
+        
+        syncWBParams();
+
+        info.format = "DV";//Sync only for Dolby
+
+        if( !updateAVoutputTVParam("sync","DolbyVisionMode",info,PQ_PARAM_DOLBY_MODE,level)) {
+            LOGINFO("dvmode Successfully Synced to Drive Cache\n");
+        }
+        else {
+            LOGERR("dvmode Sync to cache Failed !!!\n");
+        }
 
         LOGINFO("Exit %s : pqmode : %s source : %s format : %s\n",__FUNCTION__,pqmode.c_str(),source.c_str(),format.c_str());
         return tvERROR_NONE;
@@ -1065,19 +1273,22 @@ namespace Plugin {
 
     int AVOutputTV::syncAvoutputTVPQModeParamsToHAL(std::string pqmode, std::string source, std::string format)
     {
-        std::vector<int> sources;
-        std::vector<int> pictureModes;
-        std::vector<int> formats;
+        capDetails_t inputInfo;
+        valueVectors_t valueVectors;
         tr181ErrorCode_t err = tr181Success;
         TR181_ParamData_t param = {0};
         int ret = 0;
 
-        ret = getSaveConfig(pqmode, source, format, sources, pictureModes, formats);
+        inputInfo.pqmode = pqmode;
+        inputInfo.source = source;
+        inputInfo.format = format;
+
+        ret = getSaveConfig("PictureMode", inputInfo, valueVectors);
 
         if (ret == 0 ) {
-            for (int source : sources) {
+            for (int source : valueVectors.sourceValues ) {
                 tvVideoSrcType_t sourceType = (tvVideoSrcType_t)source;
-                for (int format : formats) {
+                for (int format : valueVectors.formatValues ) {
                     tvVideoFormatType_t formatType = (tvVideoFormatType_t)format;
                     std::string tr181_param_name = "";
                     tr181_param_name += std::string(AVOUTPUT_SOURCE_PICTUREMODE_STRING_RFC_PARAM);
@@ -1105,13 +1316,29 @@ namespace Plugin {
         return ret;
    }
 
-    uint32_t AVOutputTV::generateStorageIdentifier(std::string &key, std::string forParam,int contentFormat, int pqmode, int source)
+    uint32_t AVOutputTV::generateStorageIdentifier(std::string &key, std::string forParam, paramIndex_t info)
+    {
+        key+=std::string(AVOUTPUT_GENERIC_STRING_RFC_PARAM);
+        key+=STRING_SOURCE+convertSourceIndexToString(info.sourceIndex)+std::string(".")+STRING_PICMODE+convertPictureIndexToString(info.pqmodeIndex)+std::string(".")+std::string(STRING_FORMAT)+convertVideoFormatToString(info.formatIndex)+std::string(".")+forParam;
+        return tvERROR_NONE;
+    }
+
+    uint32_t AVOutputTV::generateStorageIdentifierCMS(std::string &key, std::string forParam, paramIndex_t info)
+    {
+        key+=std::string(AVOUTPUT_GENERIC_STRING_RFC_PARAM);
+        key+=STRING_SOURCE+convertSourceIndexToString(info.sourceIndex)+std::string(".")+STRING_PICMODE+convertPictureIndexToString(info.pqmodeIndex)+std::string(".")+std::string(STRING_FORMAT)+convertVideoFormatToString(info.formatIndex)+std::string(".")+STRING_COLOR+getCMSColorStringFromEnum((tvDataComponentColor_t)info.colorIndex)+std::string(".")+STRING_COMPONENT+getCMSComponentStringFromEnum((tvComponentType_t)info.componentIndex)+std::string(".")+forParam;
+        return tvERROR_NONE;
+    }
+
+    uint32_t AVOutputTV::generateStorageIdentifierWB(std::string &key, std::string forParam, paramIndex_t info)
     {
         key+=std::string(AVOUTPUT_GENERIC_STRING_RFC_PARAM);
-        key+=STRING_SOURCE+convertSourceIndexToString(source)+std::string(".")+STRING_PICMODE+convertPictureIndexToString(pqmode)+std::string(".")+std::string(STRING_FORMAT)+convertVideoFormatToString(contentFormat)+std::string(".")+forParam;
+        key+=STRING_SOURCE+convertSourceIndexToString(info.sourceIndex)+std::string(".")+STRING_PICMODE+convertPictureIndexToString(info.pqmodeIndex)+std::string(".")+std::string(STRING_FORMAT)+convertVideoFormatToString(info.formatIndex)+std::string(".")+STRING_COLOR+getWBColorStringFromEnum((tvWBColor_t)info.colorIndex)+std::string(".")+STRING_CONTROL+getWBControlStringFromEnum((tvWBControl_t)info.controlIndex)+std::string(".")+forParam;
         return tvERROR_NONE;
     }
 
+
+
     uint32_t AVOutputTV::generateStorageIdentifierDirty(std::string &key, std::string forParam,uint32_t contentFormat, int pqmode)
     {
         key+=std::string(AVOUTPUT_GENERIC_STRING_RFC_PARAM);
@@ -1138,48 +1365,128 @@ namespace Plugin {
          return "UNKNOWN ERROR";
     }
 
-    int AVOutputTV::getSaveConfig(std::string pqmode, std::string source, std::string format,std::vector<int> &sources,std::vector<int> &picturemodes, std::vector<int> &formats)
+    int AVOutputTV::getSaveConfig(std::string param, capDetails_t capInfo, valueVectors_t &values)
     {
-        LOGINFO("Entry : %s pqmode : %s source :%s format :%s\n",__FUNCTION__,pqmode.c_str(),source.c_str(),format.c_str());
+        LOGINFO("Entry : %s pqmode : %s source :%s format :%s component : %s color : %s control:%s\n",__FUNCTION__,capInfo.pqmode.c_str(),capInfo.source.c_str(),capInfo.format.c_str(),capInfo.component.c_str(),capInfo.color.c_str(),capInfo.control.c_str());
 
         int ret = 0;
 
-        if (getAvailableCapabilityModes(source, pqmode, format) != 0) {
+        if (getAvailableCapabilityModes(capInfo) != 0) {
             LOGERR("%s: failed to get picture/source/format mode capability \n", __FUNCTION__);
             return -1;
         }
         //pqmode
-        char *modeString = strdup(pqmode.c_str());
+        char *modeString = strdup(capInfo.pqmode.c_str());
         char *token = NULL;
         while ((token = strtok_r(modeString,",",&modeString))) {
             std::string local = token;
-            picturemodes.push_back(getPictureModeIndex(local));
+            values.pqmodeValues.push_back(getPictureModeIndex(local));
         }
         //source
-        char *sourceString = strdup(source.c_str());
+        char *sourceString = strdup(capInfo.source.c_str());
         char *sourceToken = NULL;
         while ((sourceToken = strtok_r(sourceString,",",&sourceString))) {
             std::string local = sourceToken;
-            sources.push_back(getSourceIndex(local));
+            if( local == "All") continue;
+            values.sourceValues.push_back(getSourceIndex(local));
         }
         //3)check format
-        char *formatString = strdup(format.c_str());
+        char *formatString = strdup(capInfo.format.c_str());
         char *formatToken = NULL;
         while ((formatToken = strtok_r(formatString,",",&formatString))) {
             std::string local = formatToken;
-            formats.push_back(getFormatIndex(local));
+            values.formatValues.push_back(getFormatIndex(local));
+        }
+
+        if( param.compare("CMS") == 0 )
+        {
+            //Check Color
+            char *colorString = strdup(capInfo.color.c_str());
+            char *colorToken = NULL;
+            while ((colorToken = strtok_r(colorString,",",&colorString))) {
+                std::string local = colorToken;
+                tvDataComponentColor_t level = tvDataColor_NONE;
+                if ( getCMSColorEnumFromString(local,level ) == -1 ) {
+                    LOGERR("%s : GetColorEnumFromString Failed!!! ",__FUNCTION__);
+                    return -1;
+                }
+                values.colorValues.push_back(level);
+            }
+
+            //Check Component
+            char *componentString = strdup(capInfo.component.c_str());
+            char *componentToken = NULL;
+            while ((componentToken = strtok_r(componentString,",",&componentString))) {
+                std::string local = componentToken;
+                tvComponentType_t level;
+                if ( getCMSComponentEnumFromString(local,level ) == -1 ) {
+                    LOGERR("%s : GetComponentEnumFromString Failed!!! ",__FUNCTION__);
+                    return -1;
+                }
+                values.componentValues.push_back(level);
+            }
+        }
+
+        if( param.compare("WhiteBalance") == 0 )
+        {
+            //Check Color
+            char *colorString = strdup(capInfo.color.c_str());
+            char *colorToken = NULL;
+            while ((colorToken = strtok_r(colorString,",",&colorString))) {
+                std::string local = colorToken;
+                tvWBColor_t level=tvWB_COLOR_RED;
+                if ( getWBColorEnumFromString(local,level ) == -1 ) {
+                    LOGERR("%s : GetWBColorEnumFromString Failed!!! ",__FUNCTION__);
+                    return -1;
+                }
+                values.colorValues.push_back(level);
+            }
+
+            //Check Control
+            char *controlString = strdup(capInfo.control.c_str());
+            char *controlToken = NULL;
+            while ((controlToken = strtok_r(controlString,",",&controlString))) {
+                std::string local = controlToken;
+                tvWBControl_t level=tvWB_CONTROL_GAIN;;
+                if ( getWBControlEnumFromString(local,level ) == -1 ) {
+                    LOGERR("%s : GetWBControlEnumFromString Failed!!! ",__FUNCTION__);
+                    return -1;
+                }
+                values.controlValues.push_back(level);
+            }
+            
+            /*
+            //Check Color Temp
+            char *colorTempString = strdup(capInfo.colorTemperature.c_str());
+            char *colorTempToken = NULL;
+            while ((colorTempToken = strtok_r(colorTempString,",",&colorTempString))) {
+                std::string local = colorTempToken;
+                tvColorTemp_t level;
+                if ( getColorTempEnumFromString(local,level ) == -1 ) {
+                    LOGERR("%s : GetColorTempEnumFromString Failed!!! ",__FUNCTION__);
+                    return -1;
+                }
+                values.colorTempValues.push_back(level);
+            }*/
         }
 
-        LOGINFO("Exit : %s pqmode : %s source :%s format :%s ret:%d\n",__FUNCTION__,pqmode.c_str(),source.c_str(),format.c_str(), ret);
+        LOGINFO("Exit : %s pqmode : %s source :%s format :%s ret:%d\n",__FUNCTION__,capInfo.pqmode.c_str(),capInfo.source.c_str(),capInfo.format.c_str(), ret);
         return ret;
     }
 
-    int AVOutputTV::getLocalparam( std::string forParam,int formatIndex,int pqIndex,int sourceIndex,int & value,
-                                   tvPQParameterIndex_t pqParamIndex,bool sync,int color )
+    int AVOutputTV::getLocalparam( std::string forParam,paramIndex_t indexInfo,int & value,tvPQParameterIndex_t pqParamIndex,bool sync)
     {
         string key;
         TR181_ParamData_t param={0};
-        generateStorageIdentifier(key,forParam,formatIndex,pqIndex,sourceIndex);
+        
+        if( forParam.compare("CMS") == 0 ) {
+            generateStorageIdentifierCMS(key,forParam,indexInfo);
+        } else if( forParam.compare("WhiteBalance") == 0 ) {
+            generateStorageIdentifierWB(key,forParam,indexInfo);
+        } else {
+            generateStorageIdentifier(key,forParam,indexInfo);
+        }
+
         if(key.empty()) {
             LOGERR("generateStorageIdentifier failed\n");
             return -1;
@@ -1191,31 +1498,31 @@ namespace Plugin {
             if( forParam.compare("ColorTemp") == 0 ) {
                 if (strncmp(param.value, "Standard", strlen(param.value))==0) {
                     value=tvColorTemp_STANDARD;
-	        }
+                }
                 else if (strncmp(param.value, "Warm", strlen(param.value))==0) {
                     value=tvColorTemp_WARM;
-		}
+                }
                 else if (strncmp(param.value, "Cold", strlen(param.value))==0) {
                     value=tvColorTemp_COLD;
-		}
-                else if (strncmp(param.value, "User Defined", strlen(param.value))==0) {
+                }
+                else if (strncmp(param.value, "UserDefined", strlen(param.value))==0) {
                     value=tvColorTemp_USER;
-		}
+                }
                 else {
                     value=tvColorTemp_STANDARD;
-		}
+		        }
                 return 0;
-           }
+            }
            else if( forParam.compare("DimmingMode") == 0 ) {
                if (strncmp(param.value, "fixed", strlen(param.value))==0) {
                    value=tvDimmingMode_Fixed;
-	       }
+	           }
                else if (strncmp(param.value, "local", strlen(param.value))==0) {
                    value=tvDimmingMode_Local;
-	       }
+	           }
                else if (strncmp(param.value, "global", strlen(param.value))==0) {
                    value=tvDimmingMode_Global;
-	       }
+	           }
                return 0;
            }
            else if ( forParam.compare("DolbyVisionMode") == 0) {
@@ -1229,17 +1536,41 @@ namespace Plugin {
                    value = tvDolbyMode_Bright;
                }
                return 0;
+           }
+	       else if ( forParam.compare("HDRMode") == 0) {
+               if (strncmp(param.value, "Dark", strlen(param.value)) == 0 && key.find("DV") != std::string::npos ) {
+                   value = tvDolbyMode_Dark;
+               }
+               else if(strncmp(param.value, "Bright", strlen(param.value)) == 0 && key.find("DV") != std::string::npos ) {
+                   value = tvDolbyMode_Game;
+               }
+	           else if(strncmp(param.value, "Dark", strlen(param.value)) == 0 && key.find("HDR10") != std::string::npos ) {
+                   value = tvHDR10Mode_Dark;
+               }
+	           else if(strncmp(param.value, "Bright", strlen(param.value)) == 0 && key.find("HDR10") != std::string::npos ) {
+                   value = tvHDR10Mode_Bright;
+               }
+	           else if(strncmp(param.value, "Dark", strlen(param.value)) == 0 && key.find("HLG") != std::string::npos ) {
+                   value = tvHLGMode_Dark;
+               }
+               else if(strncmp(param.value, "Bright", strlen(param.value)) == 0 && key.find("HLG") != std::string::npos ) {
+                   value = tvHLGMode_Bright;
+               }
+               else {
+                   value = tvDolbyMode_Game;
+               }
+               return 0;
            }
            else {
                value=std::stoi(param.value);
-               return 0;
+               return 0;  
            }
         }
         else {// default value from DB
             if( sync ) {
                 return 1;
             }
-            GetDefaultPQParams(pqIndex,(tvVideoSrcType_t)sourceIndex,(tvVideoFormatType_t)formatIndex,pqParamIndex,&value);
+            GetDefaultPQParams(indexInfo.pqmodeIndex,(tvVideoSrcType_t)indexInfo.sourceIndex,(tvVideoFormatType_t)indexInfo.formatIndex,pqParamIndex,&value);
             LOGINFO("Default value from DB : %s : %d \n",key.c_str(),value);
             return 0;
         }
@@ -1273,102 +1604,20 @@ namespace Plugin {
         return CompColorEnum;
     }
 
-    int AVOutputTV::getDolbyParams(tvContentFormatType_t format, std::string &s, std::string source)
-    {
-        int ret = -1;
-        TR181_ParamData_t param;
-        std::string rfc_param = AVOUTPUT_HDR10MODE_RFC_PARAM;
-        int dolby_mode_value = 0;
-        tvVideoSrcType_t sourceIndex = VIDEO_SOURCE_IP;
-        /*Since dolby vision is source specific, we should for check for specific source*/
-        if (!source.empty()) {
-            sourceIndex = (tvVideoSrcType_t)getSourceIndex(source);
-        }
-        else {
-            GetCurrentVideoSource(&sourceIndex);
-        }
-
-        char picMode[PIC_MODE_NAME_MAX]={0};
-        int pqmodeIndex = 0;
-        if(!getCurrentPictureMode(picMode)) {
-            LOGERR("Failed to get the Current picture mode\n");
-        }
-        else {
-            std::string local = picMode;
-            pqmodeIndex = getPictureModeIndex(local);
-        }
-        memset(&param, 0, sizeof(param));
-        if (format == tvContentFormatType_HLG ) {
-            rfc_param = AVOUTPUT_HLGMODE_RFC_PARAM;
-        }
-        else if (format == tvContentFormatType_DOVI) {
-            rfc_param = AVOUTPUT_SOURCE_PICTUREMODE_STRING_RFC_PARAM + std::to_string(sourceIndex) + "."+"DolbyVisionMode";
-        }
-
-        tr181ErrorCode_t err = getLocalParam(rfc_caller_id, rfc_param.c_str(), &param);
-        if ( tr181Success != err) {
-            tvError_t retVal = GetDefaultPQParams(pqmodeIndex,(tvVideoSrcType_t)sourceIndex,
-                                                 (tvVideoFormatType_t)ConvertHDRFormatToContentFormat((tvhdr_type_t)format),
-                                                 PQ_PARAM_DOLBY_MODE,&dolby_mode_value);
-            if( retVal != tvERROR_NONE ) {
-                LOGERR("%s : failed\n",__FUNCTION__);
-                return ret;
-            }
-            s = getDolbyModeStringFromEnum((tvDolbyMode_t)dolby_mode_value);
-            ret = 0;
-        }
-        else {
-            s += param.value;
-            ret = 0;
-        }
-        return ret;
-    }
-
-    tvError_t AVOutputTV::getParamsCaps(std::vector<std::string> &range
-                , std::vector<std::string> &pqmode, std::vector<std::string> &source, std::vector<std::string> &format,std::string param )
+    tvError_t AVOutputTV::getParamsCaps(std::string param, capVectors_t &vecInfo)
     {
         tvError_t ret = tvERROR_NONE;
-
-        std::string rangeInfo;
-        std::string sourceInfo;
-        std::string formatInfo;
-        std::string pqmodeInfo;
-
-        std::string platformsupport;
-        std::string indexInfo;
-        std::vector<std::string> localIndex;
-
-        if( ReadCapablitiesFromConf( rangeInfo, pqmodeInfo, formatInfo ,sourceInfo,param, platformsupport, indexInfo)) {
-            LOGERR( "%s: ReadCapablitiesFromConf Failed !!!\n",__FUNCTION__);
-            return tvERROR_GENERAL;
-        }
-        else {
-            spliltCapablities( range, pqmode, format, source, localIndex,rangeInfo, pqmodeInfo, formatInfo, sourceInfo , indexInfo);
-        }
-
-        return ret;
-    }
-
-    tvError_t AVOutputTV::getParamsCaps(std::vector<std::string> &range
-                , std::vector<std::string> &pqmode, std::vector<std::string> &source, std::vector<std::string> &format,std::string param,
-                 std::string & isPlatformSupport, std::vector<std::string> & index)
-    {
-        tvError_t ret = tvERROR_NONE;
-
-        std::string rangeInfo;
-        std::string sourceInfo;
-        std::string formatInfo;
-        std::string pqmodeInfo;
-        std::string indexInfo;
-
-        if( ReadCapablitiesFromConf( rangeInfo, pqmodeInfo, formatInfo ,sourceInfo,param, isPlatformSupport, indexInfo)) {
+        capDetails_t stringInfo;
+    
+        if( ReadCapablitiesFromConf( param, stringInfo) != 0 )
+        {
             LOGERR( "%s: ReadCapablitiesFromConf Failed !!!\n",__FUNCTION__);
             return tvERROR_GENERAL;
         }
-        else {
-            spliltCapablities( range, pqmode, format, source, index,rangeInfo, pqmodeInfo, formatInfo, sourceInfo, indexInfo);
+        else
+        {
+            spliltCapablities( vecInfo, stringInfo);
         }
-
         return ret;
     }
 
@@ -1431,60 +1680,6 @@ namespace Plugin {
         return ret;
     }
 
-
-    int AVOutputTV::ReadCapablitiesFromConf(std::string &rangeInfo,std::string &pqmodeInfo,std::string &formatInfo,std::string &sourceInfo,
-                           std::string param, std::string & isPlatformSupport, std::string & indexInfo)
-    {
-        int ret = 0;
-
-        try {
-            CIniFile inFile(CAPABLITY_FILE_NAME);
-            std::string configString;
-            if ((param == "DolbyVisionMode") || (param == "Backlight") ) {
-                configString = param + ".platformsupport";
-                isPlatformSupport = inFile.Get<std::string>(configString);
-                printf(" platfromsupport : %s\n",isPlatformSupport.c_str() );
-            }
-
-            if ( (param == "ColorTemperature") || (param == "DimmingMode") ||
-                ( param == "AutoBacklightControl") || (param == "DolbyVisionMode") ||
-                (param == "HDR10Mode") || (param == "HLGMode") || (param == "AspectRatio") ||
-                (param == "PictureMode") || (param == "VideoSource") || (param == "VideoFormat") ||
-                (param == "VideoFrameRate") ) {
-                configString =  param + ".range";
-                rangeInfo = inFile.Get<std::string>(configString);
-                printf(" String Range info : %s\n",rangeInfo.c_str() );
-            } else {
-                configString = param + ".range_from";
-                rangeInfo = inFile.Get<std::string>(configString);
-                configString = param + ".range_to";
-                rangeInfo += ","+inFile.Get<std::string>(configString);
-                printf(" Integer Range Info : %s\n",rangeInfo.c_str() );
-            }
-
-            if ((param == "VideoSource") || (param == "PictureMode") || (param == "VideoFormat") ) {
-                configString.clear();
-                configString = param + ".index";
-                indexInfo = inFile.Get<std::string>(configString);
-                printf("Index value %s\n", indexInfo.c_str());
-            }
-
-            configString.clear();
-            configString = param + ".pqmode";
-            pqmodeInfo = inFile.Get<std::string>(configString);
-            configString = param + ".format";
-            formatInfo = inFile.Get<std::string>(configString);
-            configString = param + ".source";
-            sourceInfo = inFile.Get<std::string>(configString);
-            ret = 0;
-        }
-        catch(const boost::property_tree::ptree_error &e) {
-            printf("%s: error %s::config table entry not found in ini file\n",__FUNCTION__,e.what());
-            ret = -1;
-        }
-        return ret;
-    }
-
     void AVOutputTV::getDimmingModeStringFromEnum(int value, std::string &toStore)
     {
         const char *color_temp_string[] = {
@@ -1502,7 +1697,7 @@ namespace Plugin {
                     [tvColorTemp_STANDARD] = "Standard",
                     [tvColorTemp_WARM] = "Warm",
                     [tvColorTemp_COLD] = "Cold",
-                    [tvColorTemp_USER] = "User Defined"
+                    [tvColorTemp_USER] = "UserDefined"
                 };
         toStore.clear();
         toStore+=color_temp_string[value];
@@ -1540,44 +1735,11 @@ namespace Plugin {
             return 1;
         }
         else {
-            LOGERR("getLocalParam failed");
+            LOGERR("getLocalParam failed %s\n",tr181_param_name.c_str());
             return 0;
         }
     }
-
-    int AVOutputTV::getDolbyParamToSync(int sourceIndex, int formatIndex, int& value)
-    {
-        int ret=0;
-        TR181_ParamData_t param;
-        int pqmodeIndex = 0;
-        char picMode[PIC_MODE_NAME_MAX]={0};
-        if(!getCurrentPictureMode(picMode)) {
-            LOGERR("Failed to get the Current picture mode\n");
-        }
-        else {
-            std::string local = picMode;
-            pqmodeIndex = getPictureModeIndex(local);
-        }
-        std ::string rfc_param = AVOUTPUT_SOURCE_PICTUREMODE_STRING_RFC_PARAM + std::to_string(sourceIndex) + "."+"DolbyVisionMode";
-        memset(&param, 0, sizeof(param));
-        tr181ErrorCode_t err = getLocalParam(rfc_caller_id, rfc_param.c_str(), &param);
-
-        if ( tr181Success != err) {
-            tvError_t retVal = GetDefaultPQParams(pqmodeIndex,(tvVideoSrcType_t)sourceIndex, (tvVideoFormatType_t)formatIndex,
-                                                PQ_PARAM_DOLBY_MODE, &value);
-            if( retVal != tvERROR_NONE ) {
-                LOGERR("%s : failed\n",__FUNCTION__);
-                return -1;
-            }
-            ret = 0;
-        }
-        else {
-            value=getDolbyModeIndex(param.value);
-            ret = 0;
-        }
-
-        return ret;
-    }
+    
     tvDolbyMode_t AVOutputTV::GetDolbyVisionEnumFromModeString(const char* modeString)
     {
         if (strcmp(modeString, "Invalid") == 0) {
@@ -1588,45 +1750,31 @@ namespace Plugin {
             return tvDolbyMode_Bright;
         } else if (strcmp(modeString, "Game") == 0) {
             return tvDolbyMode_Game;
-        } else if (strcmp(modeString, "HDR10 Dark") == 0) {
-            return tvHDR10Mode_Dark;
-        } else if (strcmp(modeString, "HDR10 Bright") == 0) {
-            return tvHDR10Mode_Bright;
-        } else if (strcmp(modeString, "HDR10 Game") == 0) {
-            return tvHDR10Mode_Game;
-        } else if (strcmp(modeString, "HLG Dark") == 0) {
-            return tvHLGMode_Dark;
-        } else if (strcmp(modeString, "HLG Bright") == 0) {
-            return tvHLGMode_Bright;
-        } else if (strcmp(modeString, "HLG Game") == 0) {
-            return tvHLGMode_Game;
         }
-
         return tvDolbyMode_Invalid; // Default case for invalid input
     }
 
     std::string AVOutputTV::getDolbyModeStringFromEnum( tvDolbyMode_t mode)
-
     {
             std::string value;
             switch(mode) {
                 case tvDolbyMode_Dark:
                 case tvHDR10Mode_Dark:
                 case tvHLGMode_Dark:
-                        value = "Dark";
-                        break;
+                     value = "Dark";
+                     break;
                 case tvDolbyMode_Bright:
                 case tvHDR10Mode_Bright:
                 case tvHLGMode_Bright:
-                        value = "Bright";
-                        break;
-                case tvDolbyMode_Game:
+                     value = "Bright";
+                     break;
+	        case tvDolbyMode_Game:
                 case tvHDR10Mode_Game:
                 case tvHLGMode_Game:
                     value = "Game";
                     break;
                 default:
-                        break;
+                    break;
             }
 
             return value;
@@ -1635,39 +1783,36 @@ namespace Plugin {
     int AVOutputTV::getAvailableCapabilityModesWrapper(std::string param, std::string & outparam)
     {
         tvError_t err = tvERROR_NONE;
-        std::vector<std::string> range;
-        std::vector<std::string> picmodeVec;
-        std::vector<std::string> sourceVec;
-        std::vector<std::string> formatVec;
+        capVectors_t info;
 
-         err = getParamsCaps(range,picmodeVec,sourceVec,formatVec, param);
+         err = getParamsCaps(param,info);
          if (err != tvERROR_NONE) {
              LOGERR("%s: failed to get [%s] capability \n", __FUNCTION__, param.c_str());
              return -1;
          }
-         outparam = convertToString(range);
+         outparam = convertToString(info.rangeVector);
 
          return 0;
     }
 
-    int AVOutputTV::getAvailableCapabilityModes(std::string & source, std::string & pqmode, std::string & format)
+    int AVOutputTV::getAvailableCapabilityModes( capDetails_t &info)
     {
-        if ((pqmode.compare("none") == 0 )) {
-            if (getAvailableCapabilityModesWrapper("PictureMode", pqmode) != 0) {
+        if ((info.pqmode.compare("none") == 0 )) {
+            if (getAvailableCapabilityModesWrapper("PictureMode", info.pqmode) != 0) {
                 LOGERR("%s: failed to get picture mode capability \n", __FUNCTION__);
                 return -1;
             }
         }
 
-        if( (source.compare("none") == 0)) {
-            if (getAvailableCapabilityModesWrapper("VideoSource",source) != 0) {
+        if( (info.source.compare("none") == 0)) {
+            if (getAvailableCapabilityModesWrapper("VideoSource",info.source) != 0) {
                 LOGERR("%s: failed to get source capability \n", __FUNCTION__);
                 return -1;
             }
         }
 
-        if( (format.compare("none") == 0) ) {
-            if (getAvailableCapabilityModesWrapper("VideoFormat",format) != 0) {
+        if( (info.format.compare("none") == 0) ) {
+            if (getAvailableCapabilityModesWrapper("VideoFormat",info.format) != 0) {
                 LOGERR("%s: failed to get format capability \n", __FUNCTION__);
                 return -1;
             }
@@ -1677,17 +1822,17 @@ namespace Plugin {
 
     int AVOutputTV::getCapabilitySource(JsonArray & rangeArray)
     {
-        std::vector<string> range,pqmode,source,format;
+        capVectors_t info;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format,"VideoSource");
+        tvError_t ret = getParamsCaps("VideoSource",info);
 
         if(ret != tvERROR_NONE) {
             return -1;
         }
         else {
-            if ((range.front()).compare("none") != 0) {
-                for (unsigned int index = 0; index < range.size(); index++) {
-                    rangeArray.Add(range[index]);
+            if ((info.rangeVector.front()).compare("none") != 0) {
+                for (unsigned int index = 0; index < info.rangeVector.size(); index++) {
+                    rangeArray.Add(info.rangeVector[index]);
                 }
             }
         }
@@ -1696,16 +1841,16 @@ namespace Plugin {
 
     int AVOutputTV::getRangeCapability(std::string param, std::vector<std::string> & rangeInfo)
     {
-        std::vector<string> range,pqmode,source,format;
+        capVectors_t info;
 
-        tvError_t ret = getParamsCaps(range,pqmode,source,format, param);
+        tvError_t ret = getParamsCaps(param,info);
 
         if(ret != tvERROR_NONE) {
             return -1;
         }
         else {
-            if ((range.front()).compare("none") != 0) {
-                rangeInfo = range;
+            if ((info.rangeVector.front()).compare("none") != 0) {
+                rangeInfo = info.rangeVector;
             }
         }
         return 0;
@@ -1783,6 +1928,11 @@ namespace Plugin {
         tvDisplayMode_t mode = tvDisplayMode_MAX;
         TR181_ParamData_t param;
         tvError_t ret = tvERROR_NONE;
+        capDetails_t inputInfo;
+        
+        inputInfo.pqmode = pqmode;
+        inputInfo.source = source;
+        inputInfo.format = format;
 
         memset(&param, 0, sizeof(param));
         tr181ErrorCode_t err = getLocalParam(rfc_caller_id, AVOUTPUT_ASPECTRATIO_RFC_PARAM, &param);
@@ -1829,9 +1979,7 @@ namespace Plugin {
             }
             else {
                 //Save DisplayMode to ssm_data
-                int params[3]={0};
-                params[0]=mode;
-                int retval=updateAVoutputTVParam("set","AspectRatio",pqmode,source,format,PQ_PARAM_ASPECT_RATIO,params);
+                int retval=updateAVoutputTVParam("set","ZoomMode",inputInfo,PQ_PARAM_ASPECT_RATIO,mode);
 
                 if(retval != 0) {
                     LOGERR("Failed to Save DisplayMode to ssm_data\n");
@@ -1848,5 +1996,473 @@ namespace Plugin {
         return ret;
     }
 
+    int AVOutputTV::getCMSComponentEnumFromString(std::string component, tvComponentType_t& value)
+    {
+        int ret = 0;
+	
+        if( component.compare("Luma") == 0 )
+            value = COMP_LUMA;
+        else if( component.compare("Saturation") == 0 )
+            value =  COMP_SATURATION;
+        else if( component.compare("Hue") == 0 )
+           value = COMP_HUE;
+        else
+           ret = -1;
+		
+        return ret;
+    }
+
+    int AVOutputTV::getCMSColorEnumFromString(std::string color,tvDataComponentColor_t& value)
+    {
+        int ret = 0;
+	
+        if( color.compare("Red") == 0 )
+            value = tvDataColor_RED;
+        else if( color.compare("Green") == 0 )
+            value = tvDataColor_GREEN;
+        else if( color.compare("Blue") == 0 )
+            value = tvDataColor_BLUE;
+        else if( color.compare("Yellow") == 0)
+            value = tvDataColor_YELLOW;
+        else if( color.compare("Cyan") == 0)
+            value = tvDataColor_CYAN;
+        else if( color.compare("Magenta") == 0)
+            value = tvDataColor_MAGENTA;
+        else
+            ret = -1;
+	
+        return ret;
+    }
+
+    int AVOutputTV::getColorTempEnumFromString(std::string color, tvColorTemp_t& value)
+    {
+        int ret = 0;
+	
+        if( color.compare("Standard") == 0 )
+            value = tvColorTemp_STANDARD;
+        else if( color.compare("Warm") == 0 )
+            value =  tvColorTemp_WARM;
+        else if( color.compare("Cold") == 0 )
+            value = tvColorTemp_COLD;
+        else if( color.compare("UserDefined") == 0 )
+            value =tvColorTemp_USER;
+        else
+            ret = -1;
+        return ret;
+    }
+
+    void AVOutputTV::syncCMSParams( )
+    {
+        int level = 0;
+        std::string cmsParam;
+        tvPQParameterIndex_t tvPQEnum;
+        capDetails_t inputInfo;
+        tvDataComponentColor_t colors[] = {tvDataColor_RED,tvDataColor_GREEN,tvDataColor_BLUE,tvDataColor_YELLOW,tvDataColor_CYAN,tvDataColor_MAGENTA};
+        
+        inputInfo.pqmode = "none";
+        inputInfo.source = "none";
+        inputInfo.format = "none";
+
+        for ( int component = COMP_HUE; component < COMP_MAX;component++) {
+            for(int count = 0;count < (int)(sizeof(colors)/sizeof(colors[0])); ++count) {
+                tvDataComponentColor_t color = colors[count];
+                std::string componentString = getCMSComponentStringFromEnum((tvComponentType_t)component);
+                std::string colorString = getCMSColorStringFromEnum((tvDataComponentColor_t)color);
+                cmsParam = componentString+"."+colorString;
+			
+                if ( convertCMSParamToPQEnum(componentString,colorString,tvPQEnum) != 0 ) {
+                    LOGINFO("%s: %s/%s Param Not Found \n",__FUNCTION__,componentString.c_str(),componentString.c_str());
+                    continue;
+                }
+
+                inputInfo.color = colorString;
+                inputInfo.component = componentString;
+                if( !updateAVoutputTVParam("sync","CMS", inputInfo,tvPQEnum,level))
+                    LOGINFO("CMS Successfully Synced to Drive Cache\n");
+                else
+                    LOGERR("CMS Sync to cache Failed !!!\n");
+            }
+        }
+    }
+
+    void AVOutputTV::syncWBParams( )
+    {
+        int level = 0;
+        tvPQParameterIndex_t tvPQEnum;
+        capDetails_t inputInfo;
+	
+        inputInfo.pqmode = "none";
+        inputInfo.source = "none";
+        inputInfo.format = "none";
+	
+        for( int colorIndex= tvWB_COLOR_RED; colorIndex < tvWB_COLOR_MAX; colorIndex++) {
+           for(int controlIndex = tvWB_CONTROL_GAIN;controlIndex < tvWB_CONTROL_MAX;controlIndex++) {
+                inputInfo.control = getWBControlStringFromEnum((tvWBControl_t)controlIndex);
+                inputInfo.color   = getWBColorStringFromEnum((tvWBColor_t)colorIndex);
+
+                if ( convertWBParamToPQEnum(inputInfo.control,inputInfo.color,tvPQEnum) != 0 ) {
+                    LOGERR("%s: %s/%s Param Not Found \n",__FUNCTION__,inputInfo.control.c_str(),inputInfo.color.c_str());
+                }    
+                updateAVoutputTVParam("sync","WhiteBalance",inputInfo,tvPQEnum,level);
+            }
+        }
+    }
+    
+
+    int AVOutputTV:: convertCMSParamToPQEnum(const std::string component, const std::string color,tvPQParameterIndex_t& value) {
+    // Create a map to associate color-component pairs with enum values
+        int ret = 0;
+        static const std::unordered_map<std::string, tvPQParameterIndex_t> colorComponentMap = {
+            {"SaturationRed", PQ_PARAM_CMS_SATURATION_RED},
+            {"SaturationGreen", PQ_PARAM_CMS_SATURATION_GREEN},
+            {"SaturationBlue", PQ_PARAM_CMS_SATURATION_BLUE},
+            {"SaturationCyan", PQ_PARAM_CMS_SATURATION_CYAN},
+            {"SaturationMagenta", PQ_PARAM_CMS_SATURATION_MAGENTA},
+            {"SaturationYellow", PQ_PARAM_CMS_SATURATION_YELLOW},
+            {"HueRed", PQ_PARAM_CMS_HUE_RED},
+            {"HueGreen", PQ_PARAM_CMS_HUE_GREEN},
+            {"HueBlue", PQ_PARAM_CMS_HUE_BLUE},
+            {"HueCyan", PQ_PARAM_CMS_HUE_CYAN},
+            {"HueMagenta", PQ_PARAM_CMS_HUE_MAGENTA},
+            {"HueYellow", PQ_PARAM_CMS_HUE_YELLOW},
+            {"LumaRed", PQ_PARAM_CMS_LUMA_RED},
+            {"LumaGreen", PQ_PARAM_CMS_LUMA_GREEN},
+            {"LumaBlue", PQ_PARAM_CMS_LUMA_BLUE},
+            {"LumaCyan", PQ_PARAM_CMS_LUMA_CYAN},
+            {"LumaMagenta", PQ_PARAM_CMS_LUMA_MAGENTA},
+            {"LumaYellow", PQ_PARAM_CMS_LUMA_YELLOW}
+        };
+
+        // Create the key by concatenating the component and color
+        std::string key = component + color;
+
+        // Look up the key in the map
+        auto it = colorComponentMap.find(key);
+        if (it != colorComponentMap.end()) {
+            value = it->second;
+            ret = 0;
+        } else {
+            LOGERR("%s : Invalid color/component\n",__FUNCTION__);
+            ret = -1;
+        }
+        return ret;
+    }
+
+    int AVOutputTV:: convertWBParamToRGBEnum(const std::string color,std::string control,tvRGBType_t &value)
+    {
+        // Create a map to associate color-ntrol pairs with enum values
+        int ret = 0;
+        static const std::unordered_map<std::string, tvRGBType_t> colorControlMap = {
+            {"RedGain", R_GAIN},
+            {"GreenGain", G_GAIN},
+            {"BlueGain", B_GAIN},
+            {"RedOffset", R_POST_OFFSET},
+            {"GreenOffset", G_POST_OFFSET},
+            {"BlueOffset", B_POST_OFFSET}
+        };
+
+        // Create the key by concatenating the color and control
+        std::string key = color + control;
+
+        // Look up the key in the map
+        auto it = colorControlMap.find(key);
+        if (it != colorControlMap.end()) {
+            value = it->second;
+            ret = 0;
+        } else {
+            LOGERR("%s : Invalid color/control\n",__FUNCTION__);
+            ret = -1;
+        }
+        return ret; 
+    }
+
+    int AVOutputTV:: convertWBParamToPQEnum(const std::string control, const std::string color,tvPQParameterIndex_t& value) {
+    // Create a map to associate color-component pairs with enum values
+	    int ret = 0;
+        static const std::unordered_map<std::string, tvPQParameterIndex_t> colorControlMap = {
+            {"RedGain", PQ_PARAM_WB_GAIN_RED},
+            {"RedOffset", PQ_PARAM_WB_OFFSET_RED},
+            {"GreenGain", PQ_PARAM_WB_GAIN_GREEN},
+            {"GreenOffset", PQ_PARAM_WB_OFFSET_GREEN},
+            {"BlueGain", PQ_PARAM_WB_GAIN_BLUE},
+            {"BlueOffset", PQ_PARAM_WB_OFFSET_BLUE},
+        };
+
+        // Create the key by concatenating the component and color
+        std::string key = color+control;
+
+        // Look up the key in the map
+        auto it = colorControlMap.find(key);
+        if (it != colorControlMap.end()) {
+            value = it->second;
+            ret = 0;
+        } else {
+            LOGERR("%s : Invalid color/control\n",__FUNCTION__);
+            ret = -1;
+        }
+        return ret;
+    }
+
+    std::string AVOutputTV::getCMSColorStringFromEnum(tvDataComponentColor_t value)
+    {
+        switch(value)
+        {
+            case tvDataColor_RED: return "Red";
+            case tvDataColor_GREEN: return "Green";
+            case tvDataColor_BLUE: return "Blue";
+            case tvDataColor_YELLOW: return "Yellow";
+            case tvDataColor_CYAN: return "Cyan";
+            case tvDataColor_MAGENTA: return "Magenta";
+            default : return "Max";
+        }
+    }
+
+    std::string AVOutputTV::getCMSComponentStringFromEnum(tvComponentType_t value) {
+        switch(value) {
+            case COMP_HUE: return "Hue";
+            case COMP_SATURATION: return "Saturation";
+            case COMP_LUMA: return "Luma";
+            default : return "Max";
+        }
+    }
+
+    std::string AVOutputTV::getWBColorStringFromEnum(tvWBColor_t value) {
+        switch(value) {
+            case tvWB_COLOR_RED: return "Red";
+            case tvWB_COLOR_GREEN: return "Green";
+            case tvWB_COLOR_BLUE: return "Blue";
+            default : return "Max";
+        }
+    }
+
+    std::string AVOutputTV::getWBControlStringFromEnum(tvWBControl_t value) {
+        switch(value)
+        {
+            case tvWB_CONTROL_GAIN: return "Gain";
+            case tvWB_CONTROL_OFFSET: return "Offset";
+            default: return "Max";
+        }
+    }
+
+    int AVOutputTV::getWBColorEnumFromString(std::string color,tvWBColor_t& value) {
+        int ret = 0;
+	
+        if( color.compare("Red") == 0 )
+            value = tvWB_COLOR_RED;
+        else if( color.compare("Green") == 0 )
+            value = tvWB_COLOR_GREEN;
+        else if( color.compare("Blue") == 0 )
+            value = tvWB_COLOR_BLUE;
+        else
+            ret = -1;
+	
+        return ret;
+    }
+
+    int AVOutputTV::getWBControlEnumFromString(std::string color,tvWBControl_t& value) {
+        int ret = 0;
+	
+        if( color.compare("Gain") == 0 )
+            value = tvWB_CONTROL_GAIN;
+        else if( color.compare("Offset") == 0 )
+            value = tvWB_CONTROL_OFFSET;
+        else
+            ret = -1;
+	
+        return ret;
+    }
+
+    std::string  AVOutputTV::getColorTemperatureStringFromEnum(tvColorTemp_t value) {
+        switch(value)  {
+            case tvColorTemp_STANDARD: return "Standard";
+            case tvColorTemp_WARM: return "Warm";
+            case tvColorTemp_COLD: return "Cold";
+	    case tvColorTemp_USER : return "UserDefined";
+            default : return "Max";
+        }
+    }
+
+    int AVOutputTV:: validateCMSParameter(std::string component,int inputValue)
+    {
+        capVectors_t info;
+        tvError_t ret = getParamsCaps("CMS", info);
+
+        LOGINFO("%s : component : %s inputValue : %d\n",__FUNCTION__,component.c_str(),inputValue);
+
+        if (ret != tvERROR_NONE) {
+            LOGERR("Failed to fetch the range capability \n");
+            return -1;
+        }
+	
+        if( component == "Saturation" ) {
+            if (inputValue < stoi(info.rangeVector[0]) || inputValue > std::stoi(info.rangeVector[1])) {
+                LOGERR("wrong Input value[%d] for %s\n", inputValue,component.c_str());
+                return -1;
+            }
+        } else if ( component == "Hue" ) {
+            if (inputValue < stoi(info.rangeVector[2]) || inputValue > std::stoi(info.rangeVector[3])) {
+                LOGERR("wrong Input value[%d] for %s\n", inputValue,component.c_str());
+                return -1;
+            }
+    	} else if ( component == "Luma" ) {
+            if (inputValue < stoi(info.rangeVector[4]) || inputValue > std::stoi(info.rangeVector[5])) {
+                LOGERR("wrong Input value[%d] for %s\n", inputValue,component.c_str());
+                return -1;
+            }
+        }
+        return 0;
+    }
+
+    int AVOutputTV:: validateWBParameter(std::string param,std::string control,int inputValue)
+    {
+        capVectors_t info;
+        tvError_t ret = getParamsCaps(param, info);
+
+        if (ret != tvERROR_NONE) {
+            LOGERR("Failed to fetch the range capability[%s] \n", param.c_str());
+            return -1;
+        }
+	
+        if( control == "Gain" ) {
+            if (inputValue < stoi(info.rangeVector[0]) || inputValue > std::stoi(info.rangeVector[1])) {
+                LOGERR("wrong Input value[%d] for %s\n", inputValue,control.c_str());
+                return -1;
+            }
+        } else if ( control == "Offset" ) {
+            if (inputValue < stoi(info.rangeVector[2]) || inputValue > std::stoi(info.rangeVector[3])) {
+                LOGERR("wrong Input value[%d] for %s\n", inputValue,control.c_str());
+                return -1;
+	    }
+        }
+        return 0;
+    }
+
+    int AVOutputTV::ReadCapablitiesFromConf(std::string param, capDetails_t& info)
+    {
+        int ret = 0;
+
+        /*Consider User WhiteBalance as CustomWhiteBalance
+        To avoid clash with Factory WhiteBalance Calibration capablities*/
+
+        if ( param == "WhiteBalance") {
+            param = "CustomWhiteBalance";
+        } else if ( param == "AutoBacklightMode") {
+            param = "BacklightControl";
+        }
+
+        try {
+            CIniFile inFile(CAPABLITY_FILE_NAME);
+            std::string configString;
+
+            if(param == "CMS")
+            {
+                configString = param + ".color";
+                info.color = inFile.Get<std::string>(configString);
+
+                configString = param + ".component";
+                info.component = inFile.Get<std::string>(configString);
+            }
+
+            if(param == "CustomWhiteBalance")
+            {
+                configString = param + ".color";
+                info.color = inFile.Get<std::string>(configString);
+
+                configString = param + ".control";
+                info.control = inFile.Get<std::string>(configString);
+
+            }
+
+            if ((param == "DolbyVisionMode") || (param == "Backlight") || (param == "CMS") || (param == "CustomWhiteBalance") || (param == "HDRMode") || (param == "BacklightControl")) {
+                configString = param + ".platformsupport";
+                info.isPlatformSupport = inFile.Get<std::string>(configString);
+                printf(" platformsupport : %s\n",info.isPlatformSupport.c_str() );
+            }
+
+            if ( (param == "ColorTemperature") || (param == "DimmingMode") ||
+                 ( param == "BacklightControl") || (param == "DolbyVisionMode") ||
+                 (param == "HDR10Mode") || (param == "HLGMode") || (param == "AspectRatio") ||
+                 (param == "PictureMode") || (param == "VideoSource") || (param == "VideoFormat") ||
+                 (param == "VideoFrameRate") || (param == "HDRMode") ) {
+                configString =  param + ".range";
+                info.range = inFile.Get<std::string>(configString);
+                printf(" String Range info : %s\n",info.range.c_str() );
+            } else if ( (param == "CMS" ))  {
+                configString.clear();
+                configString = param + ".range_Saturation_from";
+                info.range = inFile.Get<std::string>(configString);
+                configString = param + ".range_Saturation_to";
+                info.range += ","+inFile.Get<std::string>(configString);
+
+                configString = param + ".range_Hue_from";
+                info.range += ","+inFile.Get<std::string>(configString);
+                configString = param + ".range_Hue_to";
+                info.range += ","+inFile.Get<std::string>(configString);
+
+                configString = param + ".range_Luma_from";
+                info.range += ","+inFile.Get<std::string>(configString);
+                configString = param + ".range_Luma_to";
+                info.range += ","+inFile.Get<std::string>(configString);
+            } else if ( (param == "CustomWhiteBalance")) {
+                configString = param + ".range_Gain_from";
+                info.range = inFile.Get<std::string>(configString);
+                configString = param + ".range_Gain_to";
+                info.range += ","+inFile.Get<std::string>(configString);
+
+                configString = param + ".range_Offset_from";
+                info.range += ","+inFile.Get<std::string>(configString);
+                configString = param + ".range_Offset_to";
+                info.range += ","+inFile.Get<std::string>(configString);
+            } else {
+                configString = param + ".range_from";
+                info.range = inFile.Get<std::string>(configString);
+                configString = param + ".range_to";
+                info.range += ","+inFile.Get<std::string>(configString);
+                printf(" Integer Range Info : %s\n",info.range.c_str() );
+            }
+
+            if ((param == "VideoSource") || (param == "PictureMode") || (param == "VideoFormat") ) {
+                configString.clear();
+                configString = param + ".index";
+                info.index = inFile.Get<std::string>(configString);
+                printf("Index value %s\n", info.index.c_str());
+            }
+
+            configString.clear();
+            configString = param + ".pqmode";
+            info.pqmode = inFile.Get<std::string>(configString);
+            configString = param + ".format";
+            info.format = inFile.Get<std::string>(configString);
+            configString = param + ".source";
+            info.source = inFile.Get<std::string>(configString);
+            ret = 0;
+        }
+        catch(const boost::property_tree::ptree_error &e) {
+            printf("%s: error %s::config table entry not found in ini file\n",__FUNCTION__,e.what());
+            ret = -1;
+        }
+        return ret;
+   }
+
+   bool AVOutputTV::checkCMSColorAndComponentCapability(const std::string capValue, const std::string inputValue) {
+        // Parse capValue into a set
+        std::set<std::string> capSet;
+        std::istringstream capStream(capValue);
+        std::string token;
+
+        while (std::getline(capStream, token, ',')) {
+            capSet.insert(token);
+        }
+
+        // Parse inputValue and check if each item exists in the set
+        std::istringstream inputStream(inputValue);
+        while (std::getline(inputStream, token, ',')) {
+            if (capSet.find(token) == capSet.end()) {
+                return false;
+            }
+        }
+        return true;
+    }
+
 } //namespace Plugin
 } //namespace WPEFramework
diff --git a/AVOutput/CHANGELOG.md b/AVOutput/CHANGELOG.md
index d9497c1..a3afa12 100644
--- a/AVOutput/CHANGELOG.md
+++ b/AVOutput/CHANGELOG.md
@@ -14,6 +14,10 @@ All notable changes to this RDK Service will be documented in this file.
 
 * Changes in CHANGELOG should be updated when commits are added to the main or release branches. There should be one CHANGELOG entry per JIRA Ticket. This is not enforced on sprint branches since there could be multiple changes for the same JIRA ticket during development. 
 
+## [1.1.0] - 2025-03-14
+### Added
+- Add additional features on AVOutput
+
 ## [1.0.10] - 2025-02-17
 ### Fixed
 ODM API removal changes phase 1 and Fixed PQ Mode Camel Case issue
-- 
2.34.1

